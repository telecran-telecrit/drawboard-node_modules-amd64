{"ast":null,"code":"import { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { getSelectedElements, globalSceneState } from \"../scene\";\nimport { rescalePoints } from \"../points\";\nimport { rotate, resizeXYWidthHightWithRotation } from \"../math\";\nimport { getElementAbsoluteCoords, getCommonBounds } from \"./bounds\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize, normalizeDimensions } from \"./sizeHelpers\";\nimport { getCursorForResizingElement, normalizeResizeHandle } from \"./resizeTest\";\n\nconst arrowResizeOrigin = (element, pointIndex, deltaX, deltaY, pointerX, pointerY, sidesWithSameLength) => {\n  const [px, py] = element.points[pointIndex];\n  let x = element.x + deltaX;\n  let y = element.y + deltaY;\n  let pointX = px - deltaX;\n  let pointY = py - deltaY;\n\n  if (sidesWithSameLength) {\n    const {\n      width,\n      height\n    } = getPerfectElementSize(element.type, px + element.x - pointerX, py + element.y - pointerY);\n    x = px + element.x - width;\n    y = py + element.y - height;\n    pointX = width;\n    pointY = height;\n  }\n\n  mutateElement(element, {\n    x,\n    y,\n    points: element.points.map((point, i) => i === pointIndex ? [pointX, pointY] : point)\n  });\n};\n\nconst arrowResizeEnd = (element, pointIndex, deltaX, deltaY, pointerX, pointerY, sidesWithSameLength) => {\n  const [px, py] = element.points[pointIndex];\n\n  if (sidesWithSameLength) {\n    const {\n      width,\n      height\n    } = getPerfectElementSize(element.type, pointerX - element.x, pointerY - element.y);\n    mutateElement(element, {\n      points: element.points.map((point, i) => i === pointIndex ? [width, height] : point)\n    });\n  } else {\n    mutateElement(element, {\n      points: element.points.map((point, i) => i === pointIndex ? [px + deltaX, py + deltaY] : point)\n    });\n  }\n};\n\nconst applyResizeArrowFn = (element, resizeArrowFn, setResizeArrowFn, isResizeEnd, sidesWithSameLength, x, y, lastX, lastY) => {\n  const angle = element.angle;\n  const [deltaX, deltaY] = rotate(x - lastX, y - lastY, 0, 0, -angle);\n\n  if (!resizeArrowFn) {\n    if (isResizeEnd) {\n      resizeArrowFn = arrowResizeEnd;\n    } else {\n      resizeArrowFn = arrowResizeOrigin;\n    }\n  }\n\n  resizeArrowFn(element, 1, deltaX, deltaY, x, y, sidesWithSameLength);\n  setResizeArrowFn(resizeArrowFn);\n};\n\nexport const resizeElements = (resizeHandle, setResizeHandle, appState, setAppState, resizeArrowFn, setResizeArrowFn, event, xPointer, yPointer, lastX, lastY) => {\n  setAppState({\n    isResizing: resizeHandle !== \"rotation\",\n    isRotating: resizeHandle === \"rotation\"\n  });\n  const selectedElements = getSelectedElements(globalSceneState.getElements(), appState);\n  const handleOffset = 4 / appState.zoom; // XXX import constant\n\n  const dashedLinePadding = 4 / appState.zoom; // XXX import constant\n\n  const offsetPointer = handleOffset + dashedLinePadding;\n  const minSize = handleOffset * 4;\n\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n\n    if (resizeHandle === \"rotation\") {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n      const cx = (x1 + x2) / 2;\n      const cy = (y1 + y2) / 2;\n      let angle = 5 * Math.PI / 2 + Math.atan2(yPointer - cy, xPointer - cx);\n\n      if (event.shiftKey) {\n        angle += SHIFT_LOCKING_ANGLE / 2;\n        angle -= angle % SHIFT_LOCKING_ANGLE;\n      }\n\n      if (angle >= 2 * Math.PI) {\n        angle -= 2 * Math.PI;\n      }\n\n      mutateElement(element, {\n        angle\n      });\n    } else if (isLinearElement(element) && element.points.length === 2 && (resizeHandle === \"nw\" || resizeHandle === \"ne\" || resizeHandle === \"sw\" || resizeHandle === \"se\")) {\n      const [, [px, py]] = element.points;\n      const isResizeEnd = resizeHandle === \"nw\" && (px < 0 || py < 0) || resizeHandle === \"ne\" && px >= 0 || resizeHandle === \"sw\" && px <= 0 || resizeHandle === \"se\" && (px > 0 || py > 0);\n      applyResizeArrowFn(element, resizeArrowFn, setResizeArrowFn, isResizeEnd, event.shiftKey, xPointer, yPointer, lastX, lastY);\n    } else if (resizeHandle) {\n      const [x1, y1] = getElementAbsoluteCoords(element);\n      const resized = resizeXYWidthHightWithRotation(resizeHandle, x1, y1, element.width, element.height, x1 - element.x, y1 - element.y, element.angle, xPointer, yPointer, offsetPointer, event.shiftKey);\n\n      if (resized.width !== 0 && resized.height !== 0) {\n        mutateElement(element, { ...resized,\n          ...(isLinearElement(element) ? {\n            points: rescalePoints(0, resized.width, rescalePoints(1, resized.height, element.points))\n          } : {})\n        });\n      }\n    }\n\n    if (resizeHandle) {\n      setResizeHandle(normalizeResizeHandle(element, resizeHandle));\n    }\n\n    normalizeDimensions(element); // do we need this?\n\n    document.documentElement.style.cursor = getCursorForResizingElement({\n      element,\n      resizeHandle\n    }); // why do we need this?\n\n    if (appState.resizingElement) {\n      mutateElement(appState.resizingElement, {\n        x: element.x,\n        y: element.y\n      });\n    }\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    const minScale = Math.max(minSize / (x2 - x1), minSize / (y2 - y1));\n\n    switch (resizeHandle) {\n      case \"se\":\n        {\n          const scale = Math.max((xPointer - offsetPointer - x1) / (x2 - x1), (yPointer - offsetPointer - y1) / (y2 - y1));\n\n          if (scale > minScale) {\n            selectedElements.forEach(element => {\n              const width = element.width * scale;\n              const height = element.height * scale;\n              const x = element.x + (element.x - x1) * (scale - 1);\n              const y = element.y + (element.y - y1) * (scale - 1);\n              mutateElement(element, {\n                width,\n                height,\n                x,\n                y\n              });\n            });\n          }\n\n          return true;\n        }\n\n      case \"nw\":\n        {\n          const scale = Math.max((x2 - offsetPointer - xPointer) / (x2 - x1), (y2 - offsetPointer - yPointer) / (y2 - y1));\n\n          if (scale > minScale) {\n            selectedElements.forEach(element => {\n              const width = element.width * scale;\n              const height = element.height * scale;\n              const x = element.x - (x2 - element.x) * (scale - 1);\n              const y = element.y - (y2 - element.y) * (scale - 1);\n              mutateElement(element, {\n                width,\n                height,\n                x,\n                y\n              });\n            });\n          }\n\n          return true;\n        }\n\n      case \"ne\":\n        {\n          const scale = Math.max((xPointer - offsetPointer - x1) / (x2 - x1), (y2 - offsetPointer - yPointer) / (y2 - y1));\n\n          if (scale > minScale) {\n            selectedElements.forEach(element => {\n              const width = element.width * scale;\n              const height = element.height * scale;\n              const x = element.x + (element.x - x1) * (scale - 1);\n              const y = element.y - (y2 - element.y) * (scale - 1);\n              mutateElement(element, {\n                width,\n                height,\n                x,\n                y\n              });\n            });\n          }\n\n          return true;\n        }\n\n      case \"sw\":\n        {\n          const scale = Math.max((x2 - offsetPointer - xPointer) / (x2 - x1), (yPointer - offsetPointer - y1) / (y2 - y1));\n\n          if (scale > minScale) {\n            selectedElements.forEach(element => {\n              const width = element.width * scale;\n              const height = element.height * scale;\n              const x = element.x - (x2 - element.x) * (scale - 1);\n              const y = element.y + (element.y - y1) * (scale - 1);\n              mutateElement(element, {\n                width,\n                height,\n                x,\n                y\n              });\n            });\n          }\n\n          return true;\n        }\n    }\n  }\n\n  return false;\n};\nexport const canResizeMutlipleElements = elements => {\n  return elements.every(element => [\"rectangle\", \"diamond\", \"ellipse\"].includes(element.type));\n};","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/resizeElements.ts"],"names":["SHIFT_LOCKING_ANGLE","getSelectedElements","globalSceneState","rescalePoints","rotate","resizeXYWidthHightWithRotation","getElementAbsoluteCoords","getCommonBounds","isLinearElement","mutateElement","getPerfectElementSize","normalizeDimensions","getCursorForResizingElement","normalizeResizeHandle","arrowResizeOrigin","element","pointIndex","deltaX","deltaY","pointerX","pointerY","sidesWithSameLength","px","py","points","x","y","pointX","pointY","width","height","type","map","point","i","arrowResizeEnd","applyResizeArrowFn","resizeArrowFn","setResizeArrowFn","isResizeEnd","lastX","lastY","angle","resizeElements","resizeHandle","setResizeHandle","appState","setAppState","event","xPointer","yPointer","isResizing","isRotating","selectedElements","getElements","handleOffset","zoom","dashedLinePadding","offsetPointer","minSize","length","x1","y1","x2","y2","cx","cy","Math","PI","atan2","shiftKey","resized","document","documentElement","style","cursor","resizingElement","minScale","max","scale","forEach","canResizeMutlipleElements","elements","every","includes"],"mappings":"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","sourcesContent":["import { AppState } from \"../types\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\nimport { getSelectedElements, globalSceneState } from \"../scene\";\nimport { rescalePoints } from \"../points\";\n\nimport { rotate, resizeXYWidthHightWithRotation } from \"../math\";\nimport {\n  ExcalidrawLinearElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n  ResizeArrowFnType,\n} from \"./types\";\nimport { getElementAbsoluteCoords, getCommonBounds } from \"./bounds\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { mutateElement } from \"./mutateElement\";\nimport { getPerfectElementSize, normalizeDimensions } from \"./sizeHelpers\";\nimport {\n  resizeTest,\n  getCursorForResizingElement,\n  normalizeResizeHandle,\n} from \"./resizeTest\";\n\ntype ResizeTestType = ReturnType<typeof resizeTest>;\n\nconst arrowResizeOrigin: ResizeArrowFnType = (\n  element,\n  pointIndex,\n  deltaX,\n  deltaY,\n  pointerX,\n  pointerY,\n  sidesWithSameLength,\n) => {\n  const [px, py] = element.points[pointIndex];\n  let x = element.x + deltaX;\n  let y = element.y + deltaY;\n  let pointX = px - deltaX;\n  let pointY = py - deltaY;\n\n  if (sidesWithSameLength) {\n    const { width, height } = getPerfectElementSize(\n      element.type,\n      px + element.x - pointerX,\n      py + element.y - pointerY,\n    );\n    x = px + element.x - width;\n    y = py + element.y - height;\n    pointX = width;\n    pointY = height;\n  }\n\n  mutateElement(element, {\n    x,\n    y,\n    points: element.points.map((point, i) =>\n      i === pointIndex ? ([pointX, pointY] as const) : point,\n    ),\n  });\n};\n\nconst arrowResizeEnd: ResizeArrowFnType = (\n  element,\n  pointIndex,\n  deltaX,\n  deltaY,\n  pointerX,\n  pointerY,\n  sidesWithSameLength,\n) => {\n  const [px, py] = element.points[pointIndex];\n  if (sidesWithSameLength) {\n    const { width, height } = getPerfectElementSize(\n      element.type,\n      pointerX - element.x,\n      pointerY - element.y,\n    );\n    mutateElement(element, {\n      points: element.points.map((point, i) =>\n        i === pointIndex ? ([width, height] as const) : point,\n      ),\n    });\n  } else {\n    mutateElement(element, {\n      points: element.points.map((point, i) =>\n        i === pointIndex ? ([px + deltaX, py + deltaY] as const) : point,\n      ),\n    });\n  }\n};\n\nconst applyResizeArrowFn = (\n  element: NonDeleted<ExcalidrawLinearElement>,\n  resizeArrowFn: ResizeArrowFnType | null,\n  setResizeArrowFn: (fn: ResizeArrowFnType) => void,\n  isResizeEnd: boolean,\n  sidesWithSameLength: boolean,\n  x: number,\n  y: number,\n  lastX: number,\n  lastY: number,\n) => {\n  const angle = element.angle;\n  const [deltaX, deltaY] = rotate(x - lastX, y - lastY, 0, 0, -angle);\n  if (!resizeArrowFn) {\n    if (isResizeEnd) {\n      resizeArrowFn = arrowResizeEnd;\n    } else {\n      resizeArrowFn = arrowResizeOrigin;\n    }\n  }\n  resizeArrowFn(element, 1, deltaX, deltaY, x, y, sidesWithSameLength);\n  setResizeArrowFn(resizeArrowFn);\n};\n\nexport const resizeElements = (\n  resizeHandle: ResizeTestType,\n  setResizeHandle: (nextResizeHandle: ResizeTestType) => void,\n  appState: AppState,\n  setAppState: (obj: any) => void,\n  resizeArrowFn: ResizeArrowFnType | null,\n  setResizeArrowFn: (fn: ResizeArrowFnType) => void,\n  event: PointerEvent,\n  xPointer: number,\n  yPointer: number,\n  lastX: number,\n  lastY: number,\n) => {\n  setAppState({\n    isResizing: resizeHandle !== \"rotation\",\n    isRotating: resizeHandle === \"rotation\",\n  });\n  const selectedElements = getSelectedElements(\n    globalSceneState.getElements(),\n    appState,\n  );\n  const handleOffset = 4 / appState.zoom; // XXX import constant\n  const dashedLinePadding = 4 / appState.zoom; // XXX import constant\n  const offsetPointer = handleOffset + dashedLinePadding;\n  const minSize = handleOffset * 4;\n  if (selectedElements.length === 1) {\n    const [element] = selectedElements;\n    if (resizeHandle === \"rotation\") {\n      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n      const cx = (x1 + x2) / 2;\n      const cy = (y1 + y2) / 2;\n      let angle = (5 * Math.PI) / 2 + Math.atan2(yPointer - cy, xPointer - cx);\n      if (event.shiftKey) {\n        angle += SHIFT_LOCKING_ANGLE / 2;\n        angle -= angle % SHIFT_LOCKING_ANGLE;\n      }\n      if (angle >= 2 * Math.PI) {\n        angle -= 2 * Math.PI;\n      }\n      mutateElement(element, { angle });\n    } else if (\n      isLinearElement(element) &&\n      element.points.length === 2 &&\n      (resizeHandle === \"nw\" ||\n        resizeHandle === \"ne\" ||\n        resizeHandle === \"sw\" ||\n        resizeHandle === \"se\")\n    ) {\n      const [, [px, py]] = element.points;\n      const isResizeEnd =\n        (resizeHandle === \"nw\" && (px < 0 || py < 0)) ||\n        (resizeHandle === \"ne\" && px >= 0) ||\n        (resizeHandle === \"sw\" && px <= 0) ||\n        (resizeHandle === \"se\" && (px > 0 || py > 0));\n      applyResizeArrowFn(\n        element,\n        resizeArrowFn,\n        setResizeArrowFn,\n        isResizeEnd,\n        event.shiftKey,\n        xPointer,\n        yPointer,\n        lastX,\n        lastY,\n      );\n    } else if (resizeHandle) {\n      const [x1, y1] = getElementAbsoluteCoords(element);\n      const resized = resizeXYWidthHightWithRotation(\n        resizeHandle,\n        x1,\n        y1,\n        element.width,\n        element.height,\n        x1 - element.x,\n        y1 - element.y,\n        element.angle,\n        xPointer,\n        yPointer,\n        offsetPointer,\n        event.shiftKey,\n      );\n      if (resized.width !== 0 && resized.height !== 0) {\n        mutateElement(element, {\n          ...resized,\n          ...(isLinearElement(element)\n            ? {\n                points: rescalePoints(\n                  0,\n                  resized.width,\n                  rescalePoints(1, resized.height, element.points),\n                ),\n              }\n            : {}),\n        });\n      }\n    }\n\n    if (resizeHandle) {\n      setResizeHandle(normalizeResizeHandle(element, resizeHandle));\n    }\n    normalizeDimensions(element);\n\n    // do we need this?\n    document.documentElement.style.cursor = getCursorForResizingElement({\n      element,\n      resizeHandle,\n    });\n    // why do we need this?\n    if (appState.resizingElement) {\n      mutateElement(appState.resizingElement, {\n        x: element.x,\n        y: element.y,\n      });\n    }\n\n    return true;\n  } else if (selectedElements.length > 1) {\n    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);\n    const minScale = Math.max(minSize / (x2 - x1), minSize / (y2 - y1));\n    switch (resizeHandle) {\n      case \"se\": {\n        const scale = Math.max(\n          (xPointer - offsetPointer - x1) / (x2 - x1),\n          (yPointer - offsetPointer - y1) / (y2 - y1),\n        );\n        if (scale > minScale) {\n          selectedElements.forEach((element) => {\n            const width = element.width * scale;\n            const height = element.height * scale;\n            const x = element.x + (element.x - x1) * (scale - 1);\n            const y = element.y + (element.y - y1) * (scale - 1);\n            mutateElement(element, { width, height, x, y });\n          });\n        }\n        return true;\n      }\n      case \"nw\": {\n        const scale = Math.max(\n          (x2 - offsetPointer - xPointer) / (x2 - x1),\n          (y2 - offsetPointer - yPointer) / (y2 - y1),\n        );\n        if (scale > minScale) {\n          selectedElements.forEach((element) => {\n            const width = element.width * scale;\n            const height = element.height * scale;\n            const x = element.x - (x2 - element.x) * (scale - 1);\n            const y = element.y - (y2 - element.y) * (scale - 1);\n            mutateElement(element, { width, height, x, y });\n          });\n        }\n        return true;\n      }\n      case \"ne\": {\n        const scale = Math.max(\n          (xPointer - offsetPointer - x1) / (x2 - x1),\n          (y2 - offsetPointer - yPointer) / (y2 - y1),\n        );\n        if (scale > minScale) {\n          selectedElements.forEach((element) => {\n            const width = element.width * scale;\n            const height = element.height * scale;\n            const x = element.x + (element.x - x1) * (scale - 1);\n            const y = element.y - (y2 - element.y) * (scale - 1);\n            mutateElement(element, { width, height, x, y });\n          });\n        }\n        return true;\n      }\n      case \"sw\": {\n        const scale = Math.max(\n          (x2 - offsetPointer - xPointer) / (x2 - x1),\n          (yPointer - offsetPointer - y1) / (y2 - y1),\n        );\n        if (scale > minScale) {\n          selectedElements.forEach((element) => {\n            const width = element.width * scale;\n            const height = element.height * scale;\n            const x = element.x - (x2 - element.x) * (scale - 1);\n            const y = element.y + (element.y - y1) * (scale - 1);\n            mutateElement(element, { width, height, x, y });\n          });\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport const canResizeMutlipleElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n) => {\n  return elements.every((element) =>\n    [\"rectangle\", \"diamond\", \"ellipse\"].includes(element.type),\n  );\n};\n"]},"metadata":{},"sourceType":"module"}