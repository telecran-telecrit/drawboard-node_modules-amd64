{"ast":null,"code":"import _classCallCheck from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport var DotFiller =\n/*#__PURE__*/\nfunction () {\n  function DotFiller(helper) {\n    _classCallCheck(this, DotFiller);\n\n    this.helper = helper;\n  }\n\n  _createClass(DotFiller, [{\n    key: \"fillPolygon\",\n    value: function fillPolygon(points, o) {\n      o = Object.assign({}, o, {\n        curveStepCount: 4,\n        hachureAngle: 0,\n        roughness: 1\n      });\n      var lines = polygonHachureLines(points, o);\n      return this.dotsOnLines(lines, o);\n    }\n  }, {\n    key: \"dotsOnLines\",\n    value: function dotsOnLines(lines, o) {\n      var ops = [];\n      var gap = o.hachureGap;\n\n      if (gap < 0) {\n        gap = o.strokeWidth * 4;\n      }\n\n      gap = Math.max(gap, 0.1);\n      var fweight = o.fillWeight;\n\n      if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var line = _step.value;\n          var length = lineLength(line);\n          var dl = length / gap;\n          var count = Math.ceil(dl) - 1;\n          var alpha = Math.atan((line[1][1] - line[0][1]) / (line[1][0] - line[0][0]));\n\n          for (var i = 0; i < count; i++) {\n            var l = gap * (i + 1);\n            var dy = l * Math.sin(alpha);\n            var dx = l * Math.cos(alpha);\n            var c = [line[0][0] - dx, line[0][1] + dy];\n            var cx = this.helper.randOffsetWithRange(c[0] - gap / 4, c[0] + gap / 4, o);\n            var cy = this.helper.randOffsetWithRange(c[1] - gap / 4, c[1] + gap / 4, o);\n            var el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n            ops = ops.concat(el.ops);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return {\n        type: 'fillSketch',\n        ops: ops\n      };\n    }\n  }]);\n\n  return DotFiller;\n}();","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/fillers/dot-filler.js"],"names":["lineLength","polygonHachureLines","DotFiller","helper","points","o","Object","assign","curveStepCount","hachureAngle","roughness","lines","dotsOnLines","ops","gap","hachureGap","strokeWidth","Math","max","fweight","fillWeight","line","length","dl","count","ceil","alpha","atan","i","l","dy","sin","dx","cos","c","cx","randOffsetWithRange","cy","el","ellipse","concat","type"],"mappings":"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","sourcesContent":["import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0, roughness: 1 });\n        const lines = polygonHachureLines(points, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        let ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const alpha = Math.atan((line[1][1] - line[0][1]) / (line[1][0] - line[0][0]));\n            for (let i = 0; i < count; i++) {\n                const l = gap * (i + 1);\n                const dy = l * Math.sin(alpha);\n                const dx = l * Math.cos(alpha);\n                const c = [line[0][0] - dx, line[0][1] + dy];\n                const cx = this.helper.randOffsetWithRange(c[0] - gap / 4, c[0] + gap / 4, o);\n                const cy = this.helper.randOffsetWithRange(c[1] - gap / 4, c[1] + gap / 4, o);\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops = ops.concat(el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}