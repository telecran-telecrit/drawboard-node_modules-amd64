{"ast":null,"code":"export function getSizeFromPoints(points) {\n  const xs = points.map(point => point[0]);\n  const ys = points.map(point => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys)\n  };\n}\nexport function rescalePoints(dimension, nextDimensionSize, prevPoints) {\n  const prevDimValues = prevPoints.map(point => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n  const dimensionScaleFactor = nextDimensionSize / prevDimensionSize;\n  let nextMinDimension = Infinity;\n  const scaledPoints = prevPoints.map(prevPoint => prevPoint.map((value, currentDimension) => {\n    if (currentDimension !== dimension) {\n      return value;\n    }\n\n    const scaledValue = value * dimensionScaleFactor;\n    nextMinDimension = Math.min(scaledValue, nextMinDimension);\n    return scaledValue;\n  }));\n  const translation = prevMinDimension - nextMinDimension;\n  const nextPoints = scaledPoints.map(scaledPoint => scaledPoint.map((value, currentDimension) => {\n    return currentDimension === dimension ? value + translation : value;\n  }));\n  return nextPoints;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/points.ts"],"names":["getSizeFromPoints","points","xs","map","point","ys","width","Math","max","min","height","rescalePoints","dimension","nextDimensionSize","prevPoints","prevDimValues","prevMaxDimension","prevMinDimension","prevDimensionSize","dimensionScaleFactor","nextMinDimension","Infinity","scaledPoints","prevPoint","value","currentDimension","scaledValue","translation","nextPoints","scaledPoint"],"mappings":"AAEA,OAAO,SAASA,iBAAT,CAA2BC,MAA3B,EAAqD;AAC1D,QAAMC,EAAE,GAAGD,MAAM,CAACE,GAAP,CAAYC,KAAD,IAAWA,KAAK,CAAC,CAAD,CAA3B,CAAX;AACA,QAAMC,EAAE,GAAGJ,MAAM,CAACE,GAAP,CAAYC,KAAD,IAAWA,KAAK,CAAC,CAAD,CAA3B,CAAX;AACA,SAAO;AACLE,IAAAA,KAAK,EAAEC,IAAI,CAACC,GAAL,CAAS,GAAGN,EAAZ,IAAkBK,IAAI,CAACE,GAAL,CAAS,GAAGP,EAAZ,CADpB;AAELQ,IAAAA,MAAM,EAAEH,IAAI,CAACC,GAAL,CAAS,GAAGH,EAAZ,IAAkBE,IAAI,CAACE,GAAL,CAAS,GAAGJ,EAAZ;AAFrB,GAAP;AAID;AACD,OAAO,SAASM,aAAT,CACLC,SADK,EAELC,iBAFK,EAGLC,UAHK,EAII;AACT,QAAMC,aAAa,GAAGD,UAAU,CAACX,GAAX,CAAgBC,KAAD,IAAWA,KAAK,CAACQ,SAAD,CAA/B,CAAtB;AACA,QAAMI,gBAAgB,GAAGT,IAAI,CAACC,GAAL,CAAS,GAAGO,aAAZ,CAAzB;AACA,QAAME,gBAAgB,GAAGV,IAAI,CAACE,GAAL,CAAS,GAAGM,aAAZ,CAAzB;AACA,QAAMG,iBAAiB,GAAGF,gBAAgB,GAAGC,gBAA7C;AAEA,QAAME,oBAAoB,GAAGN,iBAAiB,GAAGK,iBAAjD;AAEA,MAAIE,gBAAgB,GAAGC,QAAvB;AAEA,QAAMC,YAAY,GAAGR,UAAU,CAACX,GAAX,CAAgBoB,SAAD,IAClCA,SAAS,CAACpB,GAAV,CAAc,CAACqB,KAAD,EAAQC,gBAAR,KAA6B;AACzC,QAAIA,gBAAgB,KAAKb,SAAzB,EAAoC;AAClC,aAAOY,KAAP;AACD;;AACD,UAAME,WAAW,GAAGF,KAAK,GAAGL,oBAA5B;AACAC,IAAAA,gBAAgB,GAAGb,IAAI,CAACE,GAAL,CAASiB,WAAT,EAAsBN,gBAAtB,CAAnB;AACA,WAAOM,WAAP;AACD,GAPD,CADmB,CAArB;AAWA,QAAMC,WAAW,GAAGV,gBAAgB,GAAGG,gBAAvC;AAEA,QAAMQ,UAAU,GAAGN,YAAY,CAACnB,GAAb,CAChB0B,WAAD,IACEA,WAAW,CAAC1B,GAAZ,CAAgB,CAACqB,KAAD,EAAQC,gBAAR,KAA6B;AAC3C,WAAOA,gBAAgB,KAAKb,SAArB,GAAiCY,KAAK,GAAGG,WAAzC,GAAuDH,KAA9D;AACD,GAFD,CAFe,CAAnB;AAOA,SAAOI,UAAP;AACD","sourcesContent":["import { Point } from \"./types\";\n\nexport function getSizeFromPoints(points: readonly Point[]) {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n}\nexport function rescalePoints(\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor = nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map((prevPoint) =>\n    prevPoint.map((value, currentDimension) => {\n      if (currentDimension !== dimension) {\n        return value;\n      }\n      const scaledValue = value * dimensionScaleFactor;\n      nextMinDimension = Math.min(scaledValue, nextMinDimension);\n      return scaledValue;\n    }),\n  );\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n}\n"]},"metadata":{},"sourceType":"module"}