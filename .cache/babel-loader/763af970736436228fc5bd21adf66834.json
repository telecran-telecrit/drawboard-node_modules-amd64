{"ast":null,"code":"import _toArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _slicedToArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// https://stackoverflow.com/a/6853926/232122\nexport function distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) {\n  var A = x - x1;\n  var B = y - y1;\n  var C = x2 - x1;\n  var D = y2 - y1;\n  var dot = A * C + B * D;\n  var lenSquare = C * C + D * D;\n  var param = -1;\n\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  var xx, yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  var dx = x - xx;\n  var dy = y - yy;\n  return Math.hypot(dx, dy);\n}\nexport function rotate(x1, y1, x2, y2, angle) {\n  // ùëé‚Ä≤ùë•=(ùëéùë•‚àíùëêùë•)cosùúÉ‚àí(ùëéùë¶‚àíùëêùë¶)sinùúÉ+ùëêùë•\n  // ùëé‚Ä≤ùë¶=(ùëéùë•‚àíùëêùë•)sinùúÉ+(ùëéùë¶‚àíùëêùë¶)cosùúÉ+ùëêùë¶.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [(x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2, (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2];\n}\nexport var getPointOnAPath = function getPointOnAPath(point, path) {\n  var _point = _slicedToArray(point, 2),\n      px = _point[0],\n      py = _point[1];\n\n  var _path = _toArray(path),\n      start = _path[0],\n      other = _path.slice(1);\n\n  var _start = _slicedToArray(start, 2),\n      lastX = _start[0],\n      lastY = _start[1];\n\n  var kLine = 0;\n  var idx = 0; // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n\n  var retVal = other.some(function (_ref, i) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        x2 = _ref2[0],\n        y2 = _ref2[1];\n\n    // we always take a line when dealing with line segments\n    var x1 = lastX;\n    var y1 = lastY;\n    lastX = x2;\n    lastY = y2; // if a point is not within the domain of the line segment\n    // it is not on the line segment\n\n    if (px < x1 || px > x2) {\n      return false;\n    } // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n    // coefficient for the line (p0, p1)\n\n\n    var kL = (y2 - y1) / (x2 - x1); // coefficient for the line segment (p0, point)\n\n    var kP1 = (py - y1) / (px - x1); // coefficient for the line segment (point, p1)\n\n    var kP2 = (py - y2) / (px - x2); // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n    // using it for floating point comparisons\n\n    var epsilon = 0.3; // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    } // store the coefficient because we are goint to need it\n\n\n    kLine = kL;\n    idx = i;\n    return true;\n  }); // Return a coordinate that is always on the line segment\n\n  if (retVal === true) {\n    return {\n      x: point[0],\n      y: kLine * point[0],\n      segment: idx\n    };\n  }\n\n  return null;\n};","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/math.ts"],"names":["distanceBetweenPointAndSegment","x","y","x1","y1","x2","y2","A","B","C","D","dot","lenSquare","param","xx","yy","dx","dy","Math","hypot","rotate","angle","cos","sin","getPointOnAPath","point","path","px","py","start","other","lastX","lastY","kLine","idx","retVal","some","i","kL","kP1","kP2","epsilon","abs","segment"],"mappings":"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","sourcesContent":["import { Point } from \"roughjs/bin/geometry\";\n\n// https://stackoverflow.com/a/6853926/232122\nexport function distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\n\nexport function rotate(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n) {\n  // ùëé‚Ä≤ùë•=(ùëéùë•‚àíùëêùë•)cosùúÉ‚àí(ùëéùë¶‚àíùëêùë¶)sinùúÉ+ùëêùë•\n  // ùëé‚Ä≤ùë¶=(ùëéùë•‚àíùëêùë•)sinùúÉ+(ùëéùë¶‚àíùëêùë¶)cosùúÉ+ùëêùë¶.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n}\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n"]},"metadata":{},"sourceType":"module"}