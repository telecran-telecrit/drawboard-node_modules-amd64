{"ast":null,"code":"import _objectSpread from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { isInvisiblySmallElement, normalizeDimensions } from \"../element\";\nimport nanoid from \"nanoid\";\nimport { calculateScrollCenter } from \"../scene\";\nexport function restore(savedElements, savedState, opts) {\n  var elements = savedElements.filter(function (el) {\n    return !isInvisiblySmallElement(el);\n  }).map(function (element) {\n    var points = [];\n\n    if (element.type === \"arrow\") {\n      if (Array.isArray(element.points)) {\n        // if point array is empty, add one point to the arrow\n        // this is used as fail safe to convert incoming data to a valid\n        // arrow. In the new arrow, width and height are not being usde\n        points = element.points.length > 0 ? element.points : [[0, 0]];\n      } else {\n        // convert old arrow type to a new one\n        // old arrow spec used width and height\n        // to determine the endpoints\n        points = [[0, 0], [element.width, element.height]];\n      }\n    } else if (element.type === \"line\") {\n      // old spec, pre-arrows\n      // old spec, post-arrows\n      if (!Array.isArray(element.points) || element.points.length === 0) {\n        points = [[0, 0], [element.width, element.height]];\n      } else {\n        points = element.points;\n      }\n    } else {\n      normalizeDimensions(element);\n    }\n\n    return _objectSpread({}, element, {\n      id: element.id || nanoid(),\n      fillStyle: element.fillStyle || \"hachure\",\n      strokeWidth: element.strokeWidth || 1,\n      roughness: element.roughness || 1,\n      opacity: element.opacity === null || element.opacity === undefined ? 100 : element.opacity,\n      points: points\n    });\n  });\n\n  if ((opts === null || opts === void 0 ? void 0 : opts.scrollToContent) && savedState) {\n    savedState = _objectSpread({}, savedState, {}, calculateScrollCenter(elements));\n  }\n\n  return {\n    elements: elements,\n    appState: savedState\n  };\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/data/restore.ts"],"names":["isInvisiblySmallElement","normalizeDimensions","nanoid","calculateScrollCenter","restore","savedElements","savedState","opts","elements","filter","el","map","element","points","type","Array","isArray","length","width","height","id","fillStyle","strokeWidth","roughness","opacity","undefined","scrollToContent","appState"],"mappings":";AAKA,SAASA,uBAAT,EAAkCC,mBAAlC,QAA6D,YAA7D;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,SAASC,qBAAT,QAAsC,UAAtC;AAEA,OAAO,SAASC,OAAT,CACLC,aADK,EAELC,UAFK,EAGLC,IAHK,EAIM;AACX,MAAMC,QAAQ,GAAGH,aAAa,CAC3BI,MADc,CACP,UAAAC,EAAE;AAAA,WAAI,CAACV,uBAAuB,CAACU,EAAD,CAA5B;AAAA,GADK,EAEdC,GAFc,CAEV,UAAAC,OAAO,EAAI;AACd,QAAIC,MAAe,GAAG,EAAtB;;AACA,QAAID,OAAO,CAACE,IAAR,KAAiB,OAArB,EAA8B;AAC5B,UAAIC,KAAK,CAACC,OAAN,CAAcJ,OAAO,CAACC,MAAtB,CAAJ,EAAmC;AACjC;AACA;AACA;AACAA,QAAAA,MAAM,GAAGD,OAAO,CAACC,MAAR,CAAeI,MAAf,GAAwB,CAAxB,GAA4BL,OAAO,CAACC,MAApC,GAA6C,CAAC,CAAC,CAAD,EAAI,CAAJ,CAAD,CAAtD;AACD,OALD,MAKO;AACL;AACA;AACA;AACAA,QAAAA,MAAM,GAAG,CACP,CAAC,CAAD,EAAI,CAAJ,CADO,EAEP,CAACD,OAAO,CAACM,KAAT,EAAgBN,OAAO,CAACO,MAAxB,CAFO,CAAT;AAID;AACF,KAfD,MAeO,IAAIP,OAAO,CAACE,IAAR,KAAiB,MAArB,EAA6B;AAClC;AACA;AACA,UAAI,CAACC,KAAK,CAACC,OAAN,CAAcJ,OAAO,CAACC,MAAtB,CAAD,IAAkCD,OAAO,CAACC,MAAR,CAAeI,MAAf,KAA0B,CAAhE,EAAmE;AACjEJ,QAAAA,MAAM,GAAG,CACP,CAAC,CAAD,EAAI,CAAJ,CADO,EAEP,CAACD,OAAO,CAACM,KAAT,EAAgBN,OAAO,CAACO,MAAxB,CAFO,CAAT;AAID,OALD,MAKO;AACLN,QAAAA,MAAM,GAAGD,OAAO,CAACC,MAAjB;AACD;AACF,KAXM,MAWA;AACLZ,MAAAA,mBAAmB,CAACW,OAAD,CAAnB;AACD;;AAED,6BACKA,OADL;AAEEQ,MAAAA,EAAE,EAAER,OAAO,CAACQ,EAAR,IAAclB,MAAM,EAF1B;AAGEmB,MAAAA,SAAS,EAAET,OAAO,CAACS,SAAR,IAAqB,SAHlC;AAIEC,MAAAA,WAAW,EAAEV,OAAO,CAACU,WAAR,IAAuB,CAJtC;AAKEC,MAAAA,SAAS,EAAEX,OAAO,CAACW,SAAR,IAAqB,CALlC;AAMEC,MAAAA,OAAO,EACLZ,OAAO,CAACY,OAAR,KAAoB,IAApB,IAA4BZ,OAAO,CAACY,OAAR,KAAoBC,SAAhD,GACI,GADJ,GAEIb,OAAO,CAACY,OAThB;AAUEX,MAAAA,MAAM,EAANA;AAVF;AAYD,GA9Cc,CAAjB;;AAgDA,MAAI,CAAAN,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAEmB,eAAN,KAAyBpB,UAA7B,EAAyC;AACvCA,IAAAA,UAAU,qBAAQA,UAAR,MAAuBH,qBAAqB,CAACK,QAAD,CAA5C,CAAV;AACD;;AAED,SAAO;AACLA,IAAAA,QAAQ,EAAEA,QADL;AAELmB,IAAAA,QAAQ,EAAErB;AAFL,GAAP;AAID","sourcesContent":["import { Point } from \"roughjs/bin/geometry\";\n\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { DataState } from \"./types\";\nimport { isInvisiblySmallElement, normalizeDimensions } from \"../element\";\nimport nanoid from \"nanoid\";\nimport { calculateScrollCenter } from \"../scene\";\n\nexport function restore(\n  savedElements: readonly ExcalidrawElement[],\n  savedState: AppState | null,\n  opts?: { scrollToContent: boolean },\n): DataState {\n  const elements = savedElements\n    .filter(el => !isInvisiblySmallElement(el))\n    .map(element => {\n      let points: Point[] = [];\n      if (element.type === \"arrow\") {\n        if (Array.isArray(element.points)) {\n          // if point array is empty, add one point to the arrow\n          // this is used as fail safe to convert incoming data to a valid\n          // arrow. In the new arrow, width and height are not being usde\n          points = element.points.length > 0 ? element.points : [[0, 0]];\n        } else {\n          // convert old arrow type to a new one\n          // old arrow spec used width and height\n          // to determine the endpoints\n          points = [\n            [0, 0],\n            [element.width, element.height],\n          ];\n        }\n      } else if (element.type === \"line\") {\n        // old spec, pre-arrows\n        // old spec, post-arrows\n        if (!Array.isArray(element.points) || element.points.length === 0) {\n          points = [\n            [0, 0],\n            [element.width, element.height],\n          ];\n        } else {\n          points = element.points;\n        }\n      } else {\n        normalizeDimensions(element);\n      }\n\n      return {\n        ...element,\n        id: element.id || nanoid(),\n        fillStyle: element.fillStyle || \"hachure\",\n        strokeWidth: element.strokeWidth || 1,\n        roughness: element.roughness || 1,\n        opacity:\n          element.opacity === null || element.opacity === undefined\n            ? 100\n            : element.opacity,\n        points,\n      };\n    });\n\n  if (opts?.scrollToContent && savedState) {\n    savedState = { ...savedState, ...calculateScrollCenter(elements) };\n  }\n\n  return {\n    elements: elements,\n    appState: savedState,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}