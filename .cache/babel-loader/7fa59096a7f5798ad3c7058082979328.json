{"ast":null,"code":"import { rotate } from \"../math\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\"; // If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n\nexport function getElementAbsoluteCoords(element) {\n  if (isLinearElement(element)) {\n    return getLinearElementAbsoluteBounds(element);\n  }\n\n  return [element.x, element.y, element.x + element.width, element.y + element.height];\n}\nexport function getDiamondPoints(element) {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n}\nexport function getCurvePathOps(shape) {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n\n  return shape.sets[0].ops;\n}\nexport function getLinearElementAbsoluteBounds(element) {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    const {\n      minX,\n      minY,\n      maxX,\n      maxY\n    } = element.points.reduce((limits, [x, y]) => {\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n      return limits;\n    }, {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    });\n    return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n  }\n\n  const shape = getShapeForElement(element); // first element is always the curve\n\n  const ops = getCurvePathOps(shape[0]);\n  let currentP = [0, 0];\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY\n  } = ops.reduce((limits, {\n    op,\n    data\n  }) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data; // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]];\n      const p2 = [data[2], data[3]];\n      const p3 = [data[4], data[5]];\n      const p0 = currentP;\n      currentP = p3;\n\n      const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n\n      let t = 0;\n\n      while (t <= 1.0) {\n        const x = equation(t, 0);\n        const y = equation(t, 1);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        t += 0.1;\n      }\n    } else if (op === \"lineTo\") {// TODO: Implement this\n    } else if (op === \"qcurveTo\") {// TODO: Implement this\n    }\n\n    return limits;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  });\n  return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n}\nexport function getArrowPoints(element, shape) {\n  const ops = getCurvePathOps(shape[0]);\n  const data = ops[ops.length - 1].data;\n  const p3 = [data[4], data[5]];\n  const p2 = [data[2], data[3]];\n  const p1 = [data[0], data[1]]; // we need to find p0 of the bezier curve\n  // it is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation\n\n  const prevOp = ops[ops.length - 2];\n  let p0 = [0, 0];\n\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  } // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n\n\n  const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3); // we know the last point of the arrow\n\n\n  const [x2, y2] = p3; // by using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases\n\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)]; // find the normalized direction vector based on the\n  // previously calculated points\n\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n  const size = 30; // pixels\n\n  const arrowLength = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0); // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  // This value is selected by minizing a minmum size with the whole length of the arrow\n  // intead of last segment of the arrow\n\n  const minSize = Math.min(size, arrowLength / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n  const angle = 20; // degrees\n\n  const [x3, y3] = rotate(xs, ys, x2, y2, -angle * Math.PI / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, angle * Math.PI / 180);\n  return [x2, y2, x3, y3, x4, y4];\n} // this function has some code in common with getLinearElementAbsoluteBounds\n// there might be more efficient way\n\nconst getLinearElementRotatedBounds = (element, cx, cy) => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    const {\n      minX,\n      minY,\n      maxX,\n      maxY\n    } = element.points.reduce((limits, [x, y]) => {\n      [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n      return limits;\n    }, {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    });\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element); // first element is always the curve\n\n  const ops = getCurvePathOps(shape[0]);\n  let currentP = [0, 0];\n  const {\n    minX,\n    minY,\n    maxX,\n    maxY\n  } = ops.reduce((limits, {\n    op,\n    data\n  }) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data; // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]];\n      const p2 = [data[2], data[3]];\n      const p3 = [data[4], data[5]];\n      const p0 = currentP;\n      currentP = p3;\n\n      const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n\n      let t = 0;\n\n      while (t <= 1.0) {\n        let x = equation(t, 0);\n        let y = equation(t, 1);\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        t += 0.1;\n      }\n    } else if (op === \"lineTo\") {// TODO: Implement this\n    } else if (op === \"qcurveTo\") {// TODO: Implement this\n    }\n\n    return limits;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  });\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getElementBounds = element => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  if (isLinearElement(element)) {\n    return getLinearElementRotatedBounds(element, cx, cy);\n  }\n\n  if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    return [minX, minY, maxX, maxY];\n  }\n\n  if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    return [cx - ww, cy - hh, cx + ww, cy + hh];\n  }\n\n  const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n  const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n  const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n  const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n  const minX = Math.min(x11, x12, x22, x21);\n  const minY = Math.min(y11, y12, y22, y21);\n  const maxX = Math.max(x11, x12, x22, x21);\n  const maxY = Math.max(y11, y12, y22, y21);\n  return [minX, minY, maxX, maxY];\n};\nexport const getCommonBounds = elements => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n  return [minX, minY, maxX, maxY];\n};","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/bounds.ts"],"names":["rotate","getShapeForElement","isLinearElement","getElementAbsoluteCoords","element","getLinearElementAbsoluteBounds","x","y","width","height","getDiamondPoints","topX","Math","floor","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","getCurvePathOps","shape","set","sets","type","ops","points","length","minX","minY","maxX","maxY","reduce","limits","min","max","Infinity","currentP","op","data","p1","p2","p3","p0","equation","t","idx","pow","getArrowPoints","prevOp","x2","y2","x1","y1","distance","hypot","nx","ny","size","arrowLength","total","cx","cy","px","py","minSize","xs","ys","angle","x3","y3","PI","x4","y4","getLinearElementRotatedBounds","getElementBounds","x11","y11","x12","y12","x22","y22","x21","y21","w","h","cos","sin","ww","hh","getCommonBounds","elements","forEach"],"mappings":"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","sourcesContent":["import { ExcalidrawElement, ExcalidrawLinearElement } from \"./types\";\nimport { rotate } from \"../math\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport function getElementAbsoluteCoords(\n  element: ExcalidrawElement,\n): [number, number, number, number] {\n  if (isLinearElement(element)) {\n    return getLinearElementAbsoluteBounds(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n}\n\nexport function getDiamondPoints(element: ExcalidrawElement) {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n}\n\nexport function getCurvePathOps(shape: Drawable): Op[] {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n}\n\nexport function getLinearElementAbsoluteBounds(\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  let currentP: Point = [0, 0];\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          const x = equation(t, 0);\n          const y = equation(t, 1);\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n}\n\nexport function getArrowPoints(\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n) {\n  const ops = getCurvePathOps(shape[0]);\n\n  const data = ops[ops.length - 1].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // we need to find p0 of the bezier curve\n  // it is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation\n  const prevOp = ops[ops.length - 2];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = (prevOp.data as unknown) as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // we know the last point of the arrow\n  const [x2, y2] = p3;\n\n  // by using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // find the normalized direction vector based on the\n  // previously calculated points\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = 30; // pixels\n  const arrowLength = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0);\n\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  // This value is selected by minizing a minmum size with the whole length of the arrow\n  // intead of last segment of the arrow\n  const minSize = Math.min(size, arrowLength / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x2, y2, x3, y3, x4, y4];\n}\n\n// this function has some code in common with getLinearElementAbsoluteBounds\n// there might be more efficient way\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  let currentP: Point = [0, 0];\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isLinearElement(element)) {\n    return getLinearElementRotatedBounds(element, cx, cy);\n  }\n  if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x2, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    return [minX, minY, maxX, maxY];\n  }\n  if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    return [cx - ww, cy - hh, cx + ww, cy + hh];\n  }\n  const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n  const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n  const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n  const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n  const minX = Math.min(x11, x12, x22, x21);\n  const minY = Math.min(y11, y12, y22, y21);\n  const maxX = Math.max(x11, x12, x22, x21);\n  const maxY = Math.max(y11, y12, y22, y21);\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n"]},"metadata":{},"sourceType":"module"}