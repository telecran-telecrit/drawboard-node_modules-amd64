{"ast":null,"code":"import { getElementAbsoluteCoords } from \"./bounds\";\nimport { rotate } from \"../math\";\nconst handleSizes = {\n  mouse: 8,\n  pen: 16,\n  touch: 28\n};\nconst ROTATION_HANDLER_GAP = 16;\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  rotation: true\n};\n\nfunction generateHandler(x, y, width, height, cx, cy, angle) {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n}\n\nexport function handlerRectanglesFromCoords([x1, y1, x2, y2], angle, zoom, pointerType = \"mouse\", omitSides = {}) {\n  const size = handleSizes[pointerType];\n  const handlerWidth = size / zoom;\n  const handlerHeight = size / zoom;\n  const handlerMarginX = size / zoom;\n  const handlerMarginY = size / zoom;\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  const dashedLineMargin = 4 / zoom;\n  const centeringOffset = (size - 8) / (2 * zoom);\n  const handlers = {\n    nw: omitSides[\"nw\"] ? undefined : generateHandler(x1 - dashedLineMargin - handlerMarginX + centeringOffset, y1 - dashedLineMargin - handlerMarginY + centeringOffset, handlerWidth, handlerHeight, cx, cy, angle),\n    ne: omitSides[\"ne\"] ? undefined : generateHandler(x2 + dashedLineMargin - centeringOffset, y1 - dashedLineMargin - handlerMarginY + centeringOffset, handlerWidth, handlerHeight, cx, cy, angle),\n    sw: omitSides[\"sw\"] ? undefined : generateHandler(x1 - dashedLineMargin - handlerMarginX + centeringOffset, y2 + dashedLineMargin - centeringOffset, handlerWidth, handlerHeight, cx, cy, angle),\n    se: omitSides[\"se\"] ? undefined : generateHandler(x2 + dashedLineMargin - centeringOffset, y2 + dashedLineMargin - centeringOffset, handlerWidth, handlerHeight, cx, cy, angle),\n    rotation: omitSides[\"rotation\"] ? undefined : generateHandler(x1 + width / 2 - handlerWidth / 2, y1 - dashedLineMargin - handlerMarginY + centeringOffset - ROTATION_HANDLER_GAP / zoom, handlerWidth, handlerHeight, cx, cy, angle)\n  }; // We only want to show height handlers (all cardinal directions)  above a certain size\n\n  const minimumSizeForEightHandlers = 5 * size / zoom;\n\n  if (Math.abs(width) > minimumSizeForEightHandlers) {\n    if (!omitSides[\"n\"]) {\n      handlers[\"n\"] = generateHandler(x1 + width / 2 - handlerWidth / 2, y1 - dashedLineMargin - handlerMarginY + centeringOffset, handlerWidth, handlerHeight, cx, cy, angle);\n    }\n\n    if (!omitSides[\"s\"]) {\n      handlers[\"s\"] = generateHandler(x1 + width / 2 - handlerWidth / 2, y2 + dashedLineMargin - centeringOffset, handlerWidth, handlerHeight, cx, cy, angle);\n    }\n  }\n\n  if (Math.abs(height) > minimumSizeForEightHandlers) {\n    if (!omitSides[\"w\"]) {\n      handlers[\"w\"] = generateHandler(x1 - dashedLineMargin - handlerMarginX + centeringOffset, y1 + height / 2 - handlerHeight / 2, handlerWidth, handlerHeight, cx, cy, angle);\n    }\n\n    if (!omitSides[\"e\"]) {\n      handlers[\"e\"] = generateHandler(x2 + dashedLineMargin - centeringOffset, y1 + height / 2 - handlerHeight / 2, handlerWidth, handlerHeight, cx, cy, angle);\n    }\n  }\n\n  return handlers;\n}\nexport function handlerRectangles(element, zoom, pointerType = \"mouse\") {\n  const handlers = handlerRectanglesFromCoords(getElementAbsoluteCoords(element), element.angle, zoom, pointerType);\n\n  if (element.type === \"arrow\" || element.type === \"line\") {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n\n      if (p1[0] === 0 || p1[1] === 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se\n        };\n      }\n\n      if (p1[0] > 0 && p1[1] < 0) {\n        return {\n          ne: handlers.ne,\n          sw: handlers.sw\n        };\n      }\n\n      if (p1[0] > 0 && p1[1] > 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se\n        };\n      }\n\n      if (p1[0] < 0 && p1[1] > 0) {\n        return {\n          ne: handlers.ne,\n          sw: handlers.sw\n        };\n      }\n\n      if (p1[0] < 0 && p1[1] < 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se\n        };\n      }\n    }\n  }\n\n  return handlers;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/handlerRectangles.ts"],"names":["getElementAbsoluteCoords","rotate","handleSizes","mouse","pen","touch","ROTATION_HANDLER_GAP","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","e","s","n","w","rotation","generateHandler","x","y","width","height","cx","cy","angle","xx","yy","handlerRectanglesFromCoords","x1","y1","x2","y2","zoom","pointerType","omitSides","size","handlerWidth","handlerHeight","handlerMarginX","handlerMarginY","dashedLineMargin","centeringOffset","handlers","nw","undefined","ne","sw","se","minimumSizeForEightHandlers","Math","abs","handlerRectangles","element","type","points","length","p1"],"mappings":"AAEA,SAASA,wBAAT,QAAyC,UAAzC;AACA,SAASC,MAAT,QAAuB,SAAvB;AAIA,MAAMC,WAA2C,GAAG;AAClDC,EAAAA,KAAK,EAAE,CAD2C;AAElDC,EAAAA,GAAG,EAAE,EAF6C;AAGlDC,EAAAA,KAAK,EAAE;AAH2C,CAApD;AAMA,MAAMC,oBAAoB,GAAG,EAA7B;AAEA,OAAO,MAAMC,gCAAgC,GAAG;AAC9CC,EAAAA,CAAC,EAAE,IAD2C;AAE9CC,EAAAA,CAAC,EAAE,IAF2C;AAG9CC,EAAAA,CAAC,EAAE,IAH2C;AAI9CC,EAAAA,CAAC,EAAE,IAJ2C;AAK9CC,EAAAA,QAAQ,EAAE;AALoC,CAAzC;;AAQP,SAASC,eAAT,CACEC,CADF,EAEEC,CAFF,EAGEC,KAHF,EAIEC,MAJF,EAKEC,EALF,EAMEC,EANF,EAOEC,KAPF,EAQoC;AAClC,QAAM,CAACC,EAAD,EAAKC,EAAL,IAAWrB,MAAM,CAACa,CAAC,GAAGE,KAAK,GAAG,CAAb,EAAgBD,CAAC,GAAGE,MAAM,GAAG,CAA7B,EAAgCC,EAAhC,EAAoCC,EAApC,EAAwCC,KAAxC,CAAvB;AACA,SAAO,CAACC,EAAE,GAAGL,KAAK,GAAG,CAAd,EAAiBM,EAAE,GAAGL,MAAM,GAAG,CAA/B,EAAkCD,KAAlC,EAAyCC,MAAzC,CAAP;AACD;;AAED,OAAO,SAASM,2BAAT,CACL,CAACC,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,CADK,EAELP,KAFK,EAGLQ,IAHK,EAILC,WAAwB,GAAG,OAJtB,EAKLC,SAAqC,GAAG,EALnC,EAMwD;AAC7D,QAAMC,IAAI,GAAG7B,WAAW,CAAC2B,WAAD,CAAxB;AACA,QAAMG,YAAY,GAAGD,IAAI,GAAGH,IAA5B;AACA,QAAMK,aAAa,GAAGF,IAAI,GAAGH,IAA7B;AAEA,QAAMM,cAAc,GAAGH,IAAI,GAAGH,IAA9B;AACA,QAAMO,cAAc,GAAGJ,IAAI,GAAGH,IAA9B;AAEA,QAAMZ,KAAK,GAAGU,EAAE,GAAGF,EAAnB;AACA,QAAMP,MAAM,GAAGU,EAAE,GAAGF,EAApB;AACA,QAAMP,EAAE,GAAG,CAACM,EAAE,GAAGE,EAAN,IAAY,CAAvB;AACA,QAAMP,EAAE,GAAG,CAACM,EAAE,GAAGE,EAAN,IAAY,CAAvB;AAEA,QAAMS,gBAAgB,GAAG,IAAIR,IAA7B;AAEA,QAAMS,eAAe,GAAG,CAACN,IAAI,GAAG,CAAR,KAAc,IAAIH,IAAlB,CAAxB;AAEA,QAAMU,QAEL,GAAG;AACFC,IAAAA,EAAE,EAAET,SAAS,CAAC,IAAD,CAAT,GACAU,SADA,GAEA3B,eAAe,CACbW,EAAE,GAAGY,gBAAL,GAAwBF,cAAxB,GAAyCG,eAD5B,EAEbZ,EAAE,GAAGW,gBAAL,GAAwBD,cAAxB,GAAyCE,eAF5B,EAGbL,YAHa,EAIbC,aAJa,EAKbf,EALa,EAMbC,EANa,EAObC,KAPa,CAHjB;AAYFqB,IAAAA,EAAE,EAAEX,SAAS,CAAC,IAAD,CAAT,GACAU,SADA,GAEA3B,eAAe,CACba,EAAE,GAAGU,gBAAL,GAAwBC,eADX,EAEbZ,EAAE,GAAGW,gBAAL,GAAwBD,cAAxB,GAAyCE,eAF5B,EAGbL,YAHa,EAIbC,aAJa,EAKbf,EALa,EAMbC,EANa,EAObC,KAPa,CAdjB;AAuBFsB,IAAAA,EAAE,EAAEZ,SAAS,CAAC,IAAD,CAAT,GACAU,SADA,GAEA3B,eAAe,CACbW,EAAE,GAAGY,gBAAL,GAAwBF,cAAxB,GAAyCG,eAD5B,EAEbV,EAAE,GAAGS,gBAAL,GAAwBC,eAFX,EAGbL,YAHa,EAIbC,aAJa,EAKbf,EALa,EAMbC,EANa,EAObC,KAPa,CAzBjB;AAkCFuB,IAAAA,EAAE,EAAEb,SAAS,CAAC,IAAD,CAAT,GACAU,SADA,GAEA3B,eAAe,CACba,EAAE,GAAGU,gBAAL,GAAwBC,eADX,EAEbV,EAAE,GAAGS,gBAAL,GAAwBC,eAFX,EAGbL,YAHa,EAIbC,aAJa,EAKbf,EALa,EAMbC,EANa,EAObC,KAPa,CApCjB;AA6CFR,IAAAA,QAAQ,EAAEkB,SAAS,CAAC,UAAD,CAAT,GACNU,SADM,GAEN3B,eAAe,CACbW,EAAE,GAAGR,KAAK,GAAG,CAAb,GAAiBgB,YAAY,GAAG,CADnB,EAEbP,EAAE,GACAW,gBADF,GAEED,cAFF,GAGEE,eAHF,GAIE/B,oBAAoB,GAAGsB,IANZ,EAObI,YAPa,EAQbC,aARa,EASbf,EATa,EAUbC,EAVa,EAWbC,KAXa;AA/CjB,GAFJ,CAjB6D,CAiF7D;;AACA,QAAMwB,2BAA2B,GAAI,IAAIb,IAAL,GAAaH,IAAjD;;AACA,MAAIiB,IAAI,CAACC,GAAL,CAAS9B,KAAT,IAAkB4B,2BAAtB,EAAmD;AACjD,QAAI,CAACd,SAAS,CAAC,GAAD,CAAd,EAAqB;AACnBQ,MAAAA,QAAQ,CAAC,GAAD,CAAR,GAAgBzB,eAAe,CAC7BW,EAAE,GAAGR,KAAK,GAAG,CAAb,GAAiBgB,YAAY,GAAG,CADH,EAE7BP,EAAE,GAAGW,gBAAL,GAAwBD,cAAxB,GAAyCE,eAFZ,EAG7BL,YAH6B,EAI7BC,aAJ6B,EAK7Bf,EAL6B,EAM7BC,EAN6B,EAO7BC,KAP6B,CAA/B;AASD;;AACD,QAAI,CAACU,SAAS,CAAC,GAAD,CAAd,EAAqB;AACnBQ,MAAAA,QAAQ,CAAC,GAAD,CAAR,GAAgBzB,eAAe,CAC7BW,EAAE,GAAGR,KAAK,GAAG,CAAb,GAAiBgB,YAAY,GAAG,CADH,EAE7BL,EAAE,GAAGS,gBAAL,GAAwBC,eAFK,EAG7BL,YAH6B,EAI7BC,aAJ6B,EAK7Bf,EAL6B,EAM7BC,EAN6B,EAO7BC,KAP6B,CAA/B;AASD;AACF;;AACD,MAAIyB,IAAI,CAACC,GAAL,CAAS7B,MAAT,IAAmB2B,2BAAvB,EAAoD;AAClD,QAAI,CAACd,SAAS,CAAC,GAAD,CAAd,EAAqB;AACnBQ,MAAAA,QAAQ,CAAC,GAAD,CAAR,GAAgBzB,eAAe,CAC7BW,EAAE,GAAGY,gBAAL,GAAwBF,cAAxB,GAAyCG,eADZ,EAE7BZ,EAAE,GAAGR,MAAM,GAAG,CAAd,GAAkBgB,aAAa,GAAG,CAFL,EAG7BD,YAH6B,EAI7BC,aAJ6B,EAK7Bf,EAL6B,EAM7BC,EAN6B,EAO7BC,KAP6B,CAA/B;AASD;;AACD,QAAI,CAACU,SAAS,CAAC,GAAD,CAAd,EAAqB;AACnBQ,MAAAA,QAAQ,CAAC,GAAD,CAAR,GAAgBzB,eAAe,CAC7Ba,EAAE,GAAGU,gBAAL,GAAwBC,eADK,EAE7BZ,EAAE,GAAGR,MAAM,GAAG,CAAd,GAAkBgB,aAAa,GAAG,CAFL,EAG7BD,YAH6B,EAI7BC,aAJ6B,EAK7Bf,EAL6B,EAM7BC,EAN6B,EAO7BC,KAP6B,CAA/B;AASD;AACF;;AAED,SAAOkB,QAAP;AACD;AAED,OAAO,SAASS,iBAAT,CACLC,OADK,EAELpB,IAFK,EAGLC,WAAwB,GAAG,OAHtB,EAIL;AACA,QAAMS,QAAQ,GAAGf,2BAA2B,CAC1CvB,wBAAwB,CAACgD,OAAD,CADkB,EAE1CA,OAAO,CAAC5B,KAFkC,EAG1CQ,IAH0C,EAI1CC,WAJ0C,CAA5C;;AAOA,MAAImB,OAAO,CAACC,IAAR,KAAiB,OAAjB,IAA4BD,OAAO,CAACC,IAAR,KAAiB,MAAjD,EAAyD;AACvD,QAAID,OAAO,CAACE,MAAR,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B;AACA,YAAM,GAAGC,EAAH,IAASJ,OAAO,CAACE,MAAvB;;AAEA,UAAIE,EAAE,CAAC,CAAD,CAAF,KAAU,CAAV,IAAeA,EAAE,CAAC,CAAD,CAAF,KAAU,CAA7B,EAAgC;AAC9B,eACE;AACEb,UAAAA,EAAE,EAAED,QAAQ,CAACC,EADf;AAEEI,UAAAA,EAAE,EAAEL,QAAQ,CAACK;AAFf,SADF;AAMD;;AAED,UAAIS,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,IAAaA,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAzB,EAA4B;AAC1B,eACE;AACEX,UAAAA,EAAE,EAAEH,QAAQ,CAACG,EADf;AAEEC,UAAAA,EAAE,EAAEJ,QAAQ,CAACI;AAFf,SADF;AAMD;;AAED,UAAIU,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,IAAaA,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAzB,EAA4B;AAC1B,eACE;AACEb,UAAAA,EAAE,EAAED,QAAQ,CAACC,EADf;AAEEI,UAAAA,EAAE,EAAEL,QAAQ,CAACK;AAFf,SADF;AAMD;;AAED,UAAIS,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,IAAaA,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAzB,EAA4B;AAC1B,eACE;AACEX,UAAAA,EAAE,EAAEH,QAAQ,CAACG,EADf;AAEEC,UAAAA,EAAE,EAAEJ,QAAQ,CAACI;AAFf,SADF;AAMD;;AAED,UAAIU,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,IAAaA,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAzB,EAA4B;AAC1B,eACE;AACEb,UAAAA,EAAE,EAAED,QAAQ,CAACC,EADf;AAEEI,UAAAA,EAAE,EAAEL,QAAQ,CAACK;AAFf,SADF;AAMD;AACF;AACF;;AAED,SAAOL,QAAP;AACD","sourcesContent":["import { ExcalidrawElement, PointerType } from \"./types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport { rotate } from \"../math\";\n\ntype Sides = \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\" | \"rotation\";\n\nconst handleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_HANDLER_GAP = 16;\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  rotation: true,\n};\n\nfunction generateHandler(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n): [number, number, number, number] {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n}\n\nexport function handlerRectanglesFromCoords(\n  [x1, y1, x2, y2]: [number, number, number, number],\n  angle: number,\n  zoom: number,\n  pointerType: PointerType = \"mouse\",\n  omitSides: { [T in Sides]?: boolean } = {},\n): Partial<{ [T in Sides]: [number, number, number, number] }> {\n  const size = handleSizes[pointerType];\n  const handlerWidth = size / zoom;\n  const handlerHeight = size / zoom;\n\n  const handlerMarginX = size / zoom;\n  const handlerMarginY = size / zoom;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  const dashedLineMargin = 4 / zoom;\n\n  const centeringOffset = (size - 8) / (2 * zoom);\n\n  const handlers: Partial<\n    { [T in Sides]: [number, number, number, number] }\n  > = {\n    nw: omitSides[\"nw\"]\n      ? undefined\n      : generateHandler(\n          x1 - dashedLineMargin - handlerMarginX + centeringOffset,\n          y1 - dashedLineMargin - handlerMarginY + centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides[\"ne\"]\n      ? undefined\n      : generateHandler(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handlerMarginY + centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides[\"sw\"]\n      ? undefined\n      : generateHandler(\n          x1 - dashedLineMargin - handlerMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides[\"se\"]\n      ? undefined\n      : generateHandler(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides[\"rotation\"]\n      ? undefined\n      : generateHandler(\n          x1 + width / 2 - handlerWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handlerMarginY +\n            centeringOffset -\n            ROTATION_HANDLER_GAP / zoom,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handlers (all cardinal directions)  above a certain size\n  const minimumSizeForEightHandlers = (5 * size) / zoom;\n  if (Math.abs(width) > minimumSizeForEightHandlers) {\n    if (!omitSides[\"n\"]) {\n      handlers[\"n\"] = generateHandler(\n        x1 + width / 2 - handlerWidth / 2,\n        y1 - dashedLineMargin - handlerMarginY + centeringOffset,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides[\"s\"]) {\n      handlers[\"s\"] = generateHandler(\n        x1 + width / 2 - handlerWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandlers) {\n    if (!omitSides[\"w\"]) {\n      handlers[\"w\"] = generateHandler(\n        x1 - dashedLineMargin - handlerMarginX + centeringOffset,\n        y1 + height / 2 - handlerHeight / 2,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides[\"e\"]) {\n      handlers[\"e\"] = generateHandler(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handlerHeight / 2,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return handlers;\n}\n\nexport function handlerRectangles(\n  element: ExcalidrawElement,\n  zoom: number,\n  pointerType: PointerType = \"mouse\",\n) {\n  const handlers = handlerRectanglesFromCoords(\n    getElementAbsoluteCoords(element),\n    element.angle,\n    zoom,\n    pointerType,\n  );\n\n  if (element.type === \"arrow\" || element.type === \"line\") {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n\n      if (p1[0] === 0 || p1[1] === 0) {\n        return (\n          {\n            nw: handlers.nw,\n            se: handlers.se,\n          } as typeof handlers\n        );\n      }\n\n      if (p1[0] > 0 && p1[1] < 0) {\n        return (\n          {\n            ne: handlers.ne,\n            sw: handlers.sw,\n          } as typeof handlers\n        );\n      }\n\n      if (p1[0] > 0 && p1[1] > 0) {\n        return (\n          {\n            nw: handlers.nw,\n            se: handlers.se,\n          } as typeof handlers\n        );\n      }\n\n      if (p1[0] < 0 && p1[1] > 0) {\n        return (\n          {\n            ne: handlers.ne,\n            sw: handlers.sw,\n          } as typeof handlers\n        );\n      }\n\n      if (p1[0] < 0 && p1[1] < 0) {\n        return (\n          {\n            nw: handlers.nw,\n            se: handlers.se,\n          } as typeof handlers\n        );\n      }\n    }\n  }\n\n  return handlers;\n}\n"]},"metadata":{},"sourceType":"module"}