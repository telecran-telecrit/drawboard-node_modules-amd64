{"ast":null,"code":"var _jsxFileName = \"/home/pro/Solutions/drawboard-light/src/components/App.tsx\";\nimport React from \"react\";\nimport socketIOClient from \"socket.io-client\";\nimport rough from \"roughjs/bin/rough\";\nimport { newElement, newTextElement, duplicateElement, isInvisiblySmallElement, isTextElement, textWysiwyg, getCommonBounds, getCursorForResizingElement, getPerfectElementSize, normalizeDimensions, getElementMap, getDrawingVersion, getSyncableElements, newLinearElement, resizeElements, getElementWithResizeHandler, canResizeMutlipleElements, getResizeHandlerFromCoords, isNonDeletedElement } from \"../element\";\nimport { deleteSelectedElements, getElementsWithinSelection, isOverScrollBars, getElementAtPosition, getElementContainingPosition, getNormalizedZoom, getSelectedElements, globalSceneState, isSomeElementSelected, calculateScrollCenter } from \"../scene\";\nimport { decryptAESGEM, encryptAESGEM, saveToLocalStorage, loadScene, loadFromBlob, SOCKET_SERVER, exportCanvas } from \"../data\";\nimport { renderScene } from \"../renderer\";\nimport { distance2d, isPathALoop } from \"../math\";\nimport { isWritableElement, isInputLike, isToolIcon, debounce, distance, resetCursor, viewportCoordsToSceneCoords, sceneCoordsToViewportCoords, setCursorForShape } from \"../utils\";\nimport { KEYS, isArrowKey } from \"../keys\";\nimport { findShapeByKey, shapesShortcutKeys } from \"../shapes\";\nimport { createHistory } from \"../history\";\nimport ContextMenu from \"./ContextMenu\";\nimport { ActionManager } from \"../actions/manager\";\nimport \"../actions\";\nimport { actions } from \"../actions/register\";\nimport { getDefaultAppState } from \"../appState\";\nimport { t } from \"../i18n\";\nimport { copyToAppClipboard, getClipboardContent, probablySupportsClipboardBlob, probablySupportsClipboardWriteText } from \"../clipboard\";\nimport { normalizeScroll } from \"../scene\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport { createUndoAction, createRedoAction } from \"../actions/actionHistory\";\nimport { CURSOR_TYPE, ELEMENT_SHIFT_TRANSLATE_AMOUNT, ELEMENT_TRANSLATE_AMOUNT, POINTER_BUTTON, DRAGGING_THRESHOLD, TEXT_TO_CENTER_SNAP_THRESHOLD, LINE_CONFIRM_THRESHOLD } from \"../constants\";\nimport { LayerUI } from \"./LayerUI\";\nimport { generateCollaborationLink, getCollaborationLinkData } from \"../data\";\nimport { mutateElement, newElementWith } from \"../element/mutateElement\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { isLinearElement } from \"../element/typeChecks\";\nimport { actionFinalize } from \"../actions\";\nimport { restoreUsernameFromLocalStorage, saveUsernameToLocalStorage } from \"../data/localStorage\";\n/**\n * @param func handler taking at most single parameter (event).\n */\n\nfunction withBatchedUpdates(func) {\n  return event => {\n    unstable_batchedUpdates(func, event);\n  };\n}\n\nconst {\n  history\n} = createHistory();\nlet didTapTwice = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace = false;\nlet isPanning = false;\nlet isDraggingScrollBar = false;\nlet currentScrollBars = {\n  horizontal: null,\n  vertical: null\n};\nlet lastPointerUp = null;\nconst gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null\n};\n\nclass Portal {\n  constructor() {\n    this.socket = null;\n    this.socketInitialized = false;\n    this.roomID = null;\n    this.roomKey = null;\n  }\n\n  open(socket, id, key) {\n    this.socket = socket;\n    this.roomID = id;\n    this.roomKey = key;\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n\n    this.socket.close();\n    this.socket = null;\n    this.roomID = null;\n    this.roomKey = null;\n  }\n\n  isOpen() {\n    return this.socketInitialized && this.socket && this.roomID && this.roomKey;\n  }\n\n  async _broadcastSocketData(data, volatile = false) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey);\n      this.socket.emit(volatile ? \"server-volatile-broadcast\" : \"server-broadcast\", this.roomID, encrypted.data, encrypted.iv);\n    }\n  }\n\n}\n\nexport class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvas = null;\n    this.rc = null;\n    this.portal = new Portal();\n    this.lastBroadcastedOrReceivedSceneVersion = -1;\n    this.removeSceneCallback = null;\n    this.actionManager = void 0;\n    this.canvasOnlyActions = [\"selectAll\"];\n    this.state = { ...getDefaultAppState(),\n      isLoading: true\n    };\n    this.syncActionResult = withBatchedUpdates(res => {\n      if (this.unmounted) {\n        return;\n      }\n\n      let editingElement = null;\n\n      if (res.elements) {\n        res.elements.forEach(element => {\n          var _this$state$editingEl;\n\n          if (((_this$state$editingEl = this.state.editingElement) === null || _this$state$editingEl === void 0 ? void 0 : _this$state$editingEl.id) === element.id && this.state.editingElement !== element && isNonDeletedElement(element)) {\n            editingElement = element;\n          }\n        });\n        globalSceneState.replaceAllElements(res.elements);\n\n        if (res.commitToHistory) {\n          history.resumeRecording();\n        }\n      }\n\n      if (res.appState || editingElement) {\n        if (res.commitToHistory) {\n          history.resumeRecording();\n        }\n\n        this.setState(state => ({ ...res.appState,\n          editingElement: editingElement || state.editingElement,\n          isCollaborating: state.isCollaborating,\n          collaborators: state.collaborators\n        }));\n      }\n    });\n    this.onBlur = withBatchedUpdates(() => {\n      isHoldingSpace = false;\n      this.saveDebounced();\n      this.saveDebounced.flush();\n    });\n\n    this.onUnload = () => {\n      this.destroySocketClient();\n      this.onBlur();\n    };\n\n    this.disableEvent = event => {\n      event.preventDefault();\n    };\n\n    this.initializeScene = async () => {\n      const searchParams = new URLSearchParams(window.location.search);\n      const id = searchParams.get(\"id\");\n      const jsonMatch = window.location.hash.match(/^#json=([0-9]+),([a-zA-Z0-9_-]+)$/);\n      const isCollaborationScene = getCollaborationLinkData(window.location.href);\n\n      if (!isCollaborationScene) {\n        let scene; // Backwards compatibility with legacy url format\n\n        if (id) {\n          scene = await loadScene(id);\n        } else if (jsonMatch) {\n          scene = await loadScene(jsonMatch[1], jsonMatch[2]);\n        } else {\n          scene = await loadScene(null);\n        }\n\n        if (scene) {\n          this.syncActionResult(scene);\n        }\n      } // rerender text elements on font load to fix #637\n\n\n      try {\n        var _document$fonts, _document$fonts$ready;\n\n        await Promise.race([(_document$fonts = document.fonts) === null || _document$fonts === void 0 ? void 0 : (_document$fonts$ready = _document$fonts.ready) === null || _document$fonts$ready === void 0 ? void 0 : _document$fonts$ready.then(() => {\n          globalSceneState.getElementsIncludingDeleted().forEach(element => {\n            if (isTextElement(element)) {\n              invalidateShapeForElement(element);\n            }\n          });\n        }), // if fonts don't load in 1s for whatever reason, don't block the UI\n        new Promise(resolve => setTimeout(resolve, 1000))]);\n      } catch (error) {\n        console.error(error);\n      }\n\n      if (this.state.isLoading) {\n        this.setState({\n          isLoading: false\n        });\n      } // run this last else the `isLoading` state\n\n\n      if (isCollaborationScene) {\n        this.initializeSocketClient({\n          showLoadingState: true\n        });\n      }\n    };\n\n    this.unmounted = false;\n    this.onResize = withBatchedUpdates(() => {\n      globalSceneState.getElementsIncludingDeleted().forEach(element => invalidateShapeForElement(element));\n      this.setState({});\n    });\n    this.beforeUnload = withBatchedUpdates(event => {\n      if (this.state.isCollaborating && globalSceneState.getElements().length > 0) {\n        event.preventDefault(); // NOTE: modern browsers no longer allow showing a custom message here\n\n        event.returnValue = \"\";\n      }\n    });\n    this.onCut = withBatchedUpdates(event => {\n      if (isWritableElement(event.target)) {\n        return;\n      }\n\n      this.copyAll();\n      const {\n        elements: nextElements,\n        appState\n      } = deleteSelectedElements(globalSceneState.getElementsIncludingDeleted(), this.state);\n      globalSceneState.replaceAllElements(nextElements);\n      history.resumeRecording();\n      this.setState({ ...appState\n      });\n      event.preventDefault();\n    });\n    this.onCopy = withBatchedUpdates(event => {\n      if (isWritableElement(event.target)) {\n        return;\n      }\n\n      this.copyAll();\n      event.preventDefault();\n    });\n\n    this.copyAll = () => {\n      copyToAppClipboard(globalSceneState.getElements(), this.state);\n    };\n\n    this.copyToClipboardAsPng = () => {\n      const elements = globalSceneState.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n      exportCanvas(\"clipboard\", selectedElements.length ? selectedElements : elements, this.state, this.canvas, this.state);\n    };\n\n    this.copyToClipboardAsSvg = () => {\n      const selectedElements = getSelectedElements(globalSceneState.getElements(), this.state);\n      exportCanvas(\"clipboard-svg\", selectedElements.length ? selectedElements : globalSceneState.getElements(), this.state, this.canvas, this.state);\n    };\n\n    this.onTapStart = event => {\n      if (!didTapTwice) {\n        didTapTwice = true;\n        clearTimeout(tappedTwiceTimer);\n        tappedTwiceTimer = window.setTimeout(() => didTapTwice = false, 300);\n        return;\n      } // insert text only if we tapped twice with a single finger\n      // event.touches.length === 1 will also prevent inserting text when user's zooming\n\n\n      if (didTapTwice && event.touches.length === 1) {\n        const [touch] = event.touches; // @ts-ignore\n\n        this.handleCanvasDoubleClick({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n        didTapTwice = false;\n        clearTimeout(tappedTwiceTimer);\n      }\n\n      event.preventDefault();\n    };\n\n    this.pasteFromClipboard = withBatchedUpdates(async event => {\n      // #686\n      const target = document.activeElement;\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n\n      if ( // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n      //  thus these checks don't make sense\n      event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement(target))) {\n        return;\n      }\n\n      const data = await getClipboardContent(event);\n\n      if (data.elements) {\n        this.addElementsFromPaste(data.elements);\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n\n      this.selectShapeTool(\"selection\");\n      event === null || event === void 0 ? void 0 : event.preventDefault();\n    });\n\n    this.addElementsFromPaste = clipboardElements => {\n      const [minX, minY, maxX, maxY] = getCommonBounds(clipboardElements);\n      const elementsCenterX = distance(minX, maxX) / 2;\n      const elementsCenterY = distance(minY, maxY) / 2;\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords({\n        clientX: cursorX,\n        clientY: cursorY\n      }, this.state, this.canvas, window.devicePixelRatio);\n      const dx = x - elementsCenterX;\n      const dy = y - elementsCenterY;\n      const newElements = clipboardElements.map(element => duplicateElement(element, {\n        x: element.x + dx - minX,\n        y: element.y + dy - minY\n      }));\n      globalSceneState.replaceAllElements([...globalSceneState.getElementsIncludingDeleted(), ...newElements]);\n      history.resumeRecording();\n      this.setState({\n        selectedElementIds: newElements.reduce((map, element) => {\n          map[element.id] = true;\n          return map;\n        }, {})\n      });\n    };\n\n    this.setAppState = obj => {\n      this.setState(obj);\n    };\n\n    this.removePointer = event => {\n      gesture.pointers.delete(event.pointerId);\n    };\n\n    this.openPortal = async () => {\n      window.history.pushState({}, \"Excalidraw\", (await generateCollaborationLink()));\n      this.initializeSocketClient({\n        showLoadingState: false\n      });\n    };\n\n    this.closePortal = () => {\n      window.history.pushState({}, \"Excalidraw\", window.location.origin);\n      this.destroySocketClient();\n    };\n\n    this.toggleLock = () => {\n      this.setState(prevState => ({\n        elementLocked: !prevState.elementLocked,\n        elementType: prevState.elementLocked ? \"selection\" : prevState.elementType\n      }));\n    };\n\n    this.destroySocketClient = () => {\n      this.setState({\n        isCollaborating: false,\n        collaborators: new Map()\n      });\n      this.portal.close();\n    };\n\n    this.initializeSocketClient = opts => {\n      if (this.portal.socket) {\n        return;\n      }\n\n      const roomMatch = getCollaborationLinkData(window.location.href);\n\n      if (roomMatch) {\n        const initialize = () => {\n          this.portal.socketInitialized = true;\n          clearTimeout(initializationTimer);\n\n          if (this.state.isLoading && !this.unmounted) {\n            this.setState({\n              isLoading: false\n            });\n          }\n        }; // fallback in case you're not alone in the room but still don't receive\n        //  initial SCENE_UPDATE message\n\n\n        const initializationTimer = setTimeout(initialize, 5000);\n\n        const updateScene = (decryptedData, {\n          scrollToContent = false\n        } = {}) => {\n          const {\n            elements: remoteElements\n          } = decryptedData.payload;\n\n          if (scrollToContent) {\n            this.setState({ ...this.state,\n              ...calculateScrollCenter(remoteElements.filter(element => {\n                return !element.isDeleted;\n              }))\n            });\n          } // Perform reconciliation - in collaboration, if we encounter\n          // elements with more staler versions than ours, ignore them\n          // and keep ours.\n\n\n          if (globalSceneState.getElementsIncludingDeleted() == null || globalSceneState.getElementsIncludingDeleted().length === 0) {\n            globalSceneState.replaceAllElements(remoteElements);\n          } else {\n            // create a map of ids so we don't have to iterate\n            // over the array more than once.\n            const localElementMap = getElementMap(globalSceneState.getElementsIncludingDeleted()); // Reconcile\n\n            const newElements = remoteElements.reduce((elements, element) => {\n              var _this$state$editingEl2, _this$state$resizingE, _this$state$draggingE;\n\n              // if the remote element references one that's currently\n              //  edited on local, skip it (it'll be added in the next\n              //  step)\n              if (element.id === ((_this$state$editingEl2 = this.state.editingElement) === null || _this$state$editingEl2 === void 0 ? void 0 : _this$state$editingEl2.id) || element.id === ((_this$state$resizingE = this.state.resizingElement) === null || _this$state$resizingE === void 0 ? void 0 : _this$state$resizingE.id) || element.id === ((_this$state$draggingE = this.state.draggingElement) === null || _this$state$draggingE === void 0 ? void 0 : _this$state$draggingE.id)) {\n                return elements;\n              }\n\n              if (localElementMap.hasOwnProperty(element.id) && localElementMap[element.id].version > element.version) {\n                elements.push(localElementMap[element.id]);\n                delete localElementMap[element.id];\n              } else if (localElementMap.hasOwnProperty(element.id) && localElementMap[element.id].version === element.version && localElementMap[element.id].versionNonce !== element.versionNonce) {\n                // resolve conflicting edits deterministically by taking the one with the lowest versionNonce\n                if (localElementMap[element.id].versionNonce < element.versionNonce) {\n                  elements.push(localElementMap[element.id]);\n                } else {\n                  // it should be highly unlikely that the two versionNonces are the same. if we are\n                  // really worried about this, we can replace the versionNonce with the socket id.\n                  elements.push(element);\n                }\n\n                delete localElementMap[element.id];\n              } else {\n                elements.push(element);\n                delete localElementMap[element.id];\n              }\n\n              return elements;\n            }, []) // add local elements that weren't deleted or on remote\n            .concat(...Object.values(localElementMap)); // Avoid broadcasting to the rest of the collaborators the scene\n            // we just received!\n            // Note: this needs to be set before replaceAllElements as it\n            // syncronously calls render.\n\n            this.lastBroadcastedOrReceivedSceneVersion = getDrawingVersion(newElements);\n            globalSceneState.replaceAllElements(newElements);\n          } // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n          // when we receive any messages from another peer. This UX can be pretty rough -- if you\n          // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n          // right now we think this is the right tradeoff.\n\n\n          history.clear();\n\n          if (this.portal.socketInitialized === false) {\n            initialize();\n          }\n        };\n\n        this.portal.open(socketIOClient(SOCKET_SERVER), roomMatch[1], roomMatch[2]);\n        this.portal.socket.on(\"init-room\", () => {\n          if (this.portal.socket) {\n            const username = restoreUsernameFromLocalStorage();\n            this.portal.socket.emit(\"join-room\", this.portal.roomID);\n\n            if (username !== null) {\n              this.setState({\n                username\n              });\n            }\n          }\n        });\n        this.portal.socket.on(\"client-broadcast\", async (encryptedData, iv) => {\n          if (!this.portal.roomKey) {\n            return;\n          }\n\n          const decryptedData = await decryptAESGEM(encryptedData, this.portal.roomKey, iv);\n\n          switch (decryptedData.type) {\n            case \"INVALID_RESPONSE\":\n              return;\n\n            case \"SCENE_INIT\":\n              {\n                if (!this.portal.socketInitialized) {\n                  updateScene(decryptedData, {\n                    scrollToContent: true\n                  });\n                }\n\n                break;\n              }\n\n            case \"SCENE_UPDATE\":\n              updateScene(decryptedData);\n              break;\n\n            case \"MOUSE_LOCATION\":\n              {\n                const {\n                  socketID,\n                  pointerCoords,\n                  button,\n                  username,\n                  selectedElementIds\n                } = decryptedData.payload;\n                this.setState(state => {\n                  if (!state.collaborators.has(socketID)) {\n                    state.collaborators.set(socketID, {});\n                  }\n\n                  const user = state.collaborators.get(socketID);\n                  user.pointer = pointerCoords;\n                  user.button = button;\n                  user.selectedElementIds = selectedElementIds;\n                  user.username = username;\n                  state.collaborators.set(socketID, user);\n                  return state;\n                });\n                break;\n              }\n          }\n        });\n        this.portal.socket.on(\"first-in-room\", () => {\n          if (this.portal.socket) {\n            this.portal.socket.off(\"first-in-room\");\n          }\n\n          initialize();\n        });\n        this.portal.socket.on(\"room-user-change\", clients => {\n          this.setState(state => {\n            const collaborators = new Map();\n\n            for (const socketID of clients) {\n              if (state.collaborators.has(socketID)) {\n                collaborators.set(socketID, state.collaborators.get(socketID));\n              } else {\n                collaborators.set(socketID, {});\n              }\n            }\n\n            return { ...state,\n              collaborators\n            };\n          });\n        });\n        this.portal.socket.on(\"new-user\", async _socketID => {\n          this.broadcastScene(\"SCENE_INIT\");\n        });\n        this.setState({\n          isCollaborating: true,\n          isLoading: opts.showLoadingState ? true : this.state.isLoading\n        });\n      }\n    };\n\n    this.broadcastMouseLocation = payload => {\n      var _this$portal$socket;\n\n      if ((_this$portal$socket = this.portal.socket) === null || _this$portal$socket === void 0 ? void 0 : _this$portal$socket.id) {\n        const data = {\n          type: \"MOUSE_LOCATION\",\n          payload: {\n            socketID: this.portal.socket.id,\n            pointerCoords: payload.pointerCoords,\n            button: payload.button || \"up\",\n            selectedElementIds: this.state.selectedElementIds,\n            username: this.state.username\n          }\n        };\n        return this.portal._broadcastSocketData(data, true // volatile\n        );\n      }\n    };\n\n    this.broadcastScene = sceneType => {\n      const data = {\n        type: sceneType,\n        payload: {\n          elements: getSyncableElements(globalSceneState.getElementsIncludingDeleted())\n        }\n      };\n      this.lastBroadcastedOrReceivedSceneVersion = Math.max(this.lastBroadcastedOrReceivedSceneVersion, getDrawingVersion(globalSceneState.getElementsIncludingDeleted()));\n      return this.portal._broadcastSocketData(data);\n    };\n\n    this.onSceneUpdated = () => {\n      this.setState({});\n    };\n\n    this.updateCurrentCursorPosition = withBatchedUpdates(event => {\n      cursorX = event.x;\n      cursorY = event.y;\n    });\n    this.onKeyDown = withBatchedUpdates(event => {\n      if (isWritableElement(event.target) && event.key !== KEYS.ESCAPE || // case: using arrows to move between buttons\n      isArrowKey(event.key) && isInputLike(event.target)) {\n        return;\n      }\n\n      if (event.key === KEYS.QUESTION_MARK) {\n        this.setState({\n          showShortcutsDialog: true\n        });\n      }\n\n      if (event.code === \"KeyC\" && event.altKey && event.shiftKey) {\n        this.copyToClipboardAsPng();\n        event.preventDefault();\n        return;\n      }\n\n      if (this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n\n      const shape = findShapeByKey(event.key);\n\n      if (isArrowKey(event.key)) {\n        const step = event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT;\n        globalSceneState.replaceAllElements(globalSceneState.getElementsIncludingDeleted().map(el => {\n          if (this.state.selectedElementIds[el.id]) {\n            const update = {};\n\n            if (event.key === KEYS.ARROW_LEFT) {\n              update.x = el.x - step;\n            } else if (event.key === KEYS.ARROW_RIGHT) {\n              update.x = el.x + step;\n            } else if (event.key === KEYS.ARROW_UP) {\n              update.y = el.y - step;\n            } else if (event.key === KEYS.ARROW_DOWN) {\n              update.y = el.y + step;\n            }\n\n            return newElementWith(el, update);\n          }\n\n          return el;\n        }));\n        event.preventDefault();\n      } else if (event.key === KEYS.ENTER) {\n        const selectedElements = getSelectedElements(globalSceneState.getElements(), this.state);\n\n        if (selectedElements.length === 1 && !isLinearElement(selectedElements[0])) {\n          const selectedElement = selectedElements[0];\n          const x = selectedElement.x + selectedElement.width / 2;\n          const y = selectedElement.y + selectedElement.height / 2;\n          this.startTextEditing({\n            x: x,\n            y: y\n          });\n          event.preventDefault();\n          return;\n        }\n      } else if (!event.ctrlKey && !event.altKey && !event.metaKey && this.state.draggingElement === null) {\n        if (shapesShortcutKeys.includes(event.key.toLowerCase())) {\n          this.selectShapeTool(shape);\n        } else if (event.key === \"q\") {\n          this.toggleLock();\n        }\n      }\n\n      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n      }\n    });\n    this.onKeyUp = withBatchedUpdates(event => {\n      if (event.key === KEYS.SPACE) {\n        if (this.state.elementType === \"selection\") {\n          resetCursor();\n        } else {\n          setCursorForShape(this.state.elementType);\n          this.setState({\n            selectedElementIds: {}\n          });\n        }\n\n        isHoldingSpace = false;\n      }\n    });\n    this.onGestureStart = withBatchedUpdates(event => {\n      event.preventDefault();\n      gesture.initialScale = this.state.zoom;\n    });\n    this.onGestureChange = withBatchedUpdates(event => {\n      event.preventDefault();\n      this.setState({\n        zoom: getNormalizedZoom(gesture.initialScale * event.scale)\n      });\n    });\n    this.onGestureEnd = withBatchedUpdates(event => {\n      event.preventDefault();\n      gesture.initialScale = null;\n    });\n\n    this.setElements = elements => {\n      globalSceneState.replaceAllElements(elements);\n    };\n\n    this.startTextEditing = ({\n      x,\n      y,\n      clientX,\n      clientY,\n      centerIfPossible = true\n    }) => {\n      const elementAtPosition = getElementAtPosition(globalSceneState.getElements(), this.state, x, y, this.state.zoom);\n      const element = elementAtPosition && isTextElement(elementAtPosition) ? elementAtPosition : newTextElement({\n        x: x,\n        y: y,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n        text: \"\",\n        font: this.state.currentItemFont,\n        textAlign: this.state.currentItemTextAlign\n      });\n      this.setState({\n        editingElement: element\n      });\n      let textX = clientX || x;\n      let textY = clientY || y;\n      let isExistingTextElement = false;\n\n      if (elementAtPosition && isTextElement(elementAtPosition)) {\n        isExistingTextElement = true;\n        const centerElementX = elementAtPosition.x + elementAtPosition.width / 2;\n        const centerElementY = elementAtPosition.y + elementAtPosition.height / 2;\n        const {\n          x: centerElementXInViewport,\n          y: centerElementYInViewport\n        } = sceneCoordsToViewportCoords({\n          sceneX: centerElementX,\n          sceneY: centerElementY\n        }, this.state, this.canvas, window.devicePixelRatio);\n        textX = centerElementXInViewport;\n        textY = centerElementYInViewport; // x and y will change after calling newTextElement function\n\n        mutateElement(element, {\n          x: centerElementX,\n          y: centerElementY\n        });\n      } else {\n        globalSceneState.replaceAllElements([...globalSceneState.getElementsIncludingDeleted(), element]);\n\n        if (centerIfPossible) {\n          const snappedToCenterPosition = this.getTextWysiwygSnappedToCenterPosition(x, y, this.state, this.canvas, window.devicePixelRatio);\n\n          if (snappedToCenterPosition) {\n            mutateElement(element, {\n              x: snappedToCenterPosition.elementCenterX,\n              y: snappedToCenterPosition.elementCenterY\n            });\n            textX = snappedToCenterPosition.wysiwygX;\n            textY = snappedToCenterPosition.wysiwygY;\n          }\n        }\n      }\n\n      this.setState({\n        editingElement: element\n      });\n      this.handleTextWysiwyg(element, {\n        x: textX,\n        y: textY,\n        isExistingElement: isExistingTextElement\n      });\n    };\n\n    this.handleCanvasDoubleClick = event => {\n      // case: double-clicking with arrow/line tool selected would both create\n      //  text and enter multiElement mode\n      if (this.state.multiElement) {\n        return;\n      }\n\n      resetCursor();\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords(event, this.state, this.canvas, window.devicePixelRatio);\n      this.startTextEditing({\n        x: x,\n        y: y,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        centerIfPossible: !event.altKey\n      });\n    };\n\n    this.handleCanvasPointerMove = event => {\n      this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n      if (gesture.pointers.has(event.pointerId)) {\n        gesture.pointers.set(event.pointerId, {\n          x: event.clientX,\n          y: event.clientY\n        });\n      }\n\n      if (gesture.pointers.size === 2) {\n        const center = getCenter(gesture.pointers);\n        const deltaX = center.x - gesture.lastCenter.x;\n        const deltaY = center.y - gesture.lastCenter.y;\n        gesture.lastCenter = center;\n        const distance = getDistance(Array.from(gesture.pointers.values()));\n        const scaleFactor = distance / gesture.initialDistance;\n        this.setState({\n          scrollX: normalizeScroll(this.state.scrollX + deltaX / this.state.zoom),\n          scrollY: normalizeScroll(this.state.scrollY + deltaY / this.state.zoom),\n          zoom: getNormalizedZoom(gesture.initialScale * scaleFactor),\n          shouldCacheIgnoreZoom: true\n        });\n        this.resetShouldCacheIgnoreZoomDebounced();\n      } else {\n        gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n      }\n\n      if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n        return;\n      }\n\n      const {\n        isOverHorizontalScrollBar,\n        isOverVerticalScrollBar\n      } = isOverScrollBars(currentScrollBars, event.clientX, event.clientY);\n      const isOverScrollBar = isOverVerticalScrollBar || isOverHorizontalScrollBar;\n\n      if (!this.state.draggingElement && !this.state.multiElement) {\n        if (isOverScrollBar) {\n          resetCursor();\n        } else {\n          setCursorForShape(this.state.elementType);\n        }\n      }\n\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords(event, this.state, this.canvas, window.devicePixelRatio);\n\n      if (this.state.multiElement) {\n        const {\n          multiElement\n        } = this.state;\n        const {\n          x: rx,\n          y: ry\n        } = multiElement;\n        const {\n          points,\n          lastCommittedPoint\n        } = multiElement;\n        const lastPoint = points[points.length - 1];\n        setCursorForShape(this.state.elementType);\n\n        if (lastPoint === lastCommittedPoint) {\n          // if we haven't yet created a temp point and we're beyond commit-zone\n          //  threshold, add a point\n          if (distance2d(x - rx, y - ry, lastPoint[0], lastPoint[1]) >= LINE_CONFIRM_THRESHOLD) {\n            mutateElement(multiElement, {\n              points: [...points, [x - rx, y - ry]]\n            });\n          } else {\n            document.documentElement.style.cursor = CURSOR_TYPE.POINTER; // in this branch, we're inside the commit zone, and no uncommitted\n            //  point exists. Thus do nothing (don't add/remove points).\n          }\n        } else {\n          // cursor moved inside commit zone, and there's uncommitted point,\n          //  thus remove it\n          if (points.length > 2 && lastCommittedPoint && distance2d(x - rx, y - ry, lastCommittedPoint[0], lastCommittedPoint[1]) < LINE_CONFIRM_THRESHOLD) {\n            document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n            mutateElement(multiElement, {\n              points: points.slice(0, -1)\n            });\n          } else {\n            if (isPathALoop(points)) {\n              document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n            } // update last uncommitted point\n\n\n            mutateElement(multiElement, {\n              points: [...points.slice(0, -1), [x - rx, y - ry]]\n            });\n          }\n        }\n\n        return;\n      }\n\n      const hasDeselectedButton = Boolean(event.buttons);\n\n      if (hasDeselectedButton || this.state.elementType !== \"selection\" && this.state.elementType !== \"text\") {\n        return;\n      }\n\n      const elements = globalSceneState.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n\n      if (selectedElements.length === 1 && !isOverScrollBar) {\n        const elementWithResizeHandler = getElementWithResizeHandler(elements, this.state, {\n          x,\n          y\n        }, this.state.zoom, event.pointerType);\n\n        if (elementWithResizeHandler && elementWithResizeHandler.resizeHandle) {\n          document.documentElement.style.cursor = getCursorForResizingElement(elementWithResizeHandler);\n          return;\n        }\n      } else if (selectedElements.length > 1 && !isOverScrollBar) {\n        if (canResizeMutlipleElements(selectedElements)) {\n          const resizeHandle = getResizeHandlerFromCoords(getCommonBounds(selectedElements), {\n            x,\n            y\n          }, this.state.zoom, event.pointerType);\n\n          if (resizeHandle) {\n            document.documentElement.style.cursor = getCursorForResizingElement({\n              resizeHandle\n            });\n            return;\n          }\n        }\n      }\n\n      const hitElement = getElementAtPosition(elements, this.state, x, y, this.state.zoom);\n\n      if (this.state.elementType === \"text\") {\n        document.documentElement.style.cursor = isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR;\n      } else {\n        document.documentElement.style.cursor = hitElement && !isOverScrollBar ? \"move\" : \"\";\n      }\n    };\n\n    this.handleCanvasPointerDown = event => {\n      if (this.state.wysiwygElement && this.state.wysiwygElement.submit) {\n        this.state.wysiwygElement.submit();\n      }\n\n      if (lastPointerUp !== null) {\n        // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n        // this can happen when a contextual menu or alert is triggered. In order to avoid\n        // being in a weird state, we clean up on the next pointerdown\n        lastPointerUp(event);\n      }\n\n      if (isPanning) {\n        return;\n      }\n\n      this.setState({\n        lastPointerDownWith: event.pointerType,\n        cursorButton: \"down\"\n      });\n      this.savePointer(event.clientX, event.clientY, \"down\"); // pan canvas on wheel button drag or space+drag\n\n      if (gesture.pointers.size === 0 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace)) {\n        isPanning = true;\n        document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n        let {\n          clientX: lastX,\n          clientY: lastY\n        } = event;\n        const onPointerMove = withBatchedUpdates(event => {\n          const deltaX = lastX - event.clientX;\n          const deltaY = lastY - event.clientY;\n          lastX = event.clientX;\n          lastY = event.clientY;\n          this.setState({\n            scrollX: normalizeScroll(this.state.scrollX - deltaX / this.state.zoom),\n            scrollY: normalizeScroll(this.state.scrollY - deltaY / this.state.zoom)\n          });\n        });\n        const teardown = withBatchedUpdates(lastPointerUp = () => {\n          lastPointerUp = null;\n          isPanning = false;\n\n          if (!isHoldingSpace) {\n            setCursorForShape(this.state.elementType);\n          }\n\n          this.setState({\n            cursorButton: \"up\"\n          });\n          this.savePointer(event.clientX, event.clientY, \"up\");\n          window.removeEventListener(\"pointermove\", onPointerMove);\n          window.removeEventListener(\"pointerup\", teardown);\n          window.removeEventListener(\"blur\", teardown);\n        });\n        window.addEventListener(\"blur\", teardown);\n        window.addEventListener(\"pointermove\", onPointerMove, {\n          passive: true\n        });\n        window.addEventListener(\"pointerup\", teardown);\n        return;\n      } // only handle left mouse button or touch\n\n\n      if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH) {\n        return;\n      }\n\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY\n      });\n\n      if (gesture.pointers.size === 2) {\n        gesture.lastCenter = getCenter(gesture.pointers);\n        gesture.initialScale = this.state.zoom;\n        gesture.initialDistance = getDistance(Array.from(gesture.pointers.values()));\n      } // fixes pointermove causing selection of UI texts #32\n\n\n      event.preventDefault(); // Preventing the event above disables default behavior\n      //  of defocusing potentially focused element, which is what we\n      //  want when clicking inside the canvas.\n\n      if (document.activeElement instanceof HTMLElement) {\n        document.activeElement.blur();\n      } // don't select while panning\n\n\n      if (gesture.pointers.size > 1) {\n        return;\n      } // Handle scrollbars dragging\n\n\n      const {\n        isOverHorizontalScrollBar,\n        isOverVerticalScrollBar\n      } = isOverScrollBars(currentScrollBars, event.clientX, event.clientY);\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords(event, this.state, this.canvas, window.devicePixelRatio);\n      let lastX = x;\n      let lastY = y;\n\n      if ((isOverHorizontalScrollBar || isOverVerticalScrollBar) && !this.state.multiElement) {\n        isDraggingScrollBar = true;\n        lastX = event.clientX;\n        lastY = event.clientY;\n        const onPointerMove = withBatchedUpdates(event => {\n          const target = event.target;\n\n          if (!(target instanceof HTMLElement)) {\n            return;\n          }\n\n          if (isOverHorizontalScrollBar) {\n            const x = event.clientX;\n            const dx = x - lastX;\n            this.setState({\n              scrollX: normalizeScroll(this.state.scrollX - dx / this.state.zoom)\n            });\n            lastX = x;\n            return;\n          }\n\n          if (isOverVerticalScrollBar) {\n            const y = event.clientY;\n            const dy = y - lastY;\n            this.setState({\n              scrollY: normalizeScroll(this.state.scrollY - dy / this.state.zoom)\n            });\n            lastY = y;\n          }\n        });\n        const onPointerUp = withBatchedUpdates(() => {\n          isDraggingScrollBar = false;\n          setCursorForShape(this.state.elementType);\n          lastPointerUp = null;\n          this.setState({\n            cursorButton: \"up\"\n          });\n          this.savePointer(event.clientX, event.clientY, \"up\");\n          window.removeEventListener(\"pointermove\", onPointerMove);\n          window.removeEventListener(\"pointerup\", onPointerUp);\n        });\n        lastPointerUp = onPointerUp;\n        window.addEventListener(\"pointermove\", onPointerMove);\n        window.addEventListener(\"pointerup\", onPointerUp);\n        return;\n      }\n\n      const originX = x;\n      const originY = y;\n      let resizeHandle = false;\n\n      const setResizeHandle = nextResizeHandle => {\n        resizeHandle = nextResizeHandle;\n      };\n\n      let isResizingElements = false;\n      let draggingOccurred = false;\n      let hitElement = null;\n      let hitElementWasAddedToSelection = false;\n\n      if (this.state.elementType === \"selection\") {\n        const elements = globalSceneState.getElements();\n        const selectedElements = getSelectedElements(elements, this.state);\n\n        if (selectedElements.length === 1) {\n          const elementWithResizeHandler = getElementWithResizeHandler(elements, this.state, {\n            x,\n            y\n          }, this.state.zoom, event.pointerType);\n\n          if (elementWithResizeHandler) {\n            this.setState({\n              resizingElement: elementWithResizeHandler ? elementWithResizeHandler.element : null\n            });\n            resizeHandle = elementWithResizeHandler.resizeHandle;\n            document.documentElement.style.cursor = getCursorForResizingElement(elementWithResizeHandler);\n            isResizingElements = true;\n          }\n        } else if (selectedElements.length > 1) {\n          if (canResizeMutlipleElements(selectedElements)) {\n            resizeHandle = getResizeHandlerFromCoords(getCommonBounds(selectedElements), {\n              x,\n              y\n            }, this.state.zoom, event.pointerType);\n\n            if (resizeHandle) {\n              document.documentElement.style.cursor = getCursorForResizingElement({\n                resizeHandle\n              });\n              isResizingElements = true;\n            }\n          }\n        }\n\n        if (!isResizingElements) {\n          hitElement = getElementAtPosition(elements, this.state, x, y, this.state.zoom); // clear selection if shift is not clicked\n\n          if (!(hitElement && this.state.selectedElementIds[hitElement.id]) && !event.shiftKey) {\n            this.setState({\n              selectedElementIds: {}\n            });\n          } // If we click on something\n\n\n          if (hitElement) {\n            // deselect if item is selected\n            // if shift is not clicked, this will always return true\n            // otherwise, it will trigger selection based on current\n            // state of the box\n            if (!this.state.selectedElementIds[hitElement.id]) {\n              this.setState(prevState => ({\n                selectedElementIds: { ...prevState.selectedElementIds,\n                  [hitElement.id]: true\n                }\n              }));\n              globalSceneState.replaceAllElements(globalSceneState.getElementsIncludingDeleted());\n              hitElementWasAddedToSelection = true;\n            }\n          }\n        }\n      } else {\n        this.setState({\n          selectedElementIds: {}\n        });\n      }\n\n      if (this.state.elementType === \"text\") {\n        var _this$state$editingEl3;\n\n        // if we're currently still editing text, clicking outside\n        //  should only finalize it, not create another (irrespective\n        //  of state.elementLocked)\n        if (((_this$state$editingEl3 = this.state.editingElement) === null || _this$state$editingEl3 === void 0 ? void 0 : _this$state$editingEl3.type) === \"text\") {\n          return;\n        }\n\n        const {\n          x,\n          y\n        } = viewportCoordsToSceneCoords(event, this.state, this.canvas, window.devicePixelRatio);\n        this.startTextEditing({\n          x: x,\n          y: y,\n          clientX: event.clientX,\n          clientY: event.clientY,\n          centerIfPossible: !event.altKey\n        });\n        resetCursor();\n\n        if (!this.state.elementLocked) {\n          this.setState({\n            elementType: \"selection\"\n          });\n        }\n\n        return;\n      } else if (this.state.elementType === \"arrow\" || this.state.elementType === \"line\") {\n        if (this.state.multiElement) {\n          const {\n            multiElement\n          } = this.state; // finalize if completing a loop\n\n          if (multiElement.type === \"line\" && isPathALoop(multiElement.points)) {\n            mutateElement(multiElement, {\n              lastCommittedPoint: multiElement.points[multiElement.points.length - 1]\n            });\n            this.actionManager.executeAction(actionFinalize);\n            return;\n          }\n\n          const {\n            x: rx,\n            y: ry,\n            lastCommittedPoint\n          } = multiElement; // clicking inside commit zone → finalize arrow\n\n          if (multiElement.points.length > 1 && lastCommittedPoint && distance2d(x - rx, y - ry, lastCommittedPoint[0], lastCommittedPoint[1]) < LINE_CONFIRM_THRESHOLD) {\n            this.actionManager.executeAction(actionFinalize);\n            return;\n          }\n\n          this.setState(prevState => ({\n            selectedElementIds: { ...prevState.selectedElementIds,\n              [multiElement.id]: true\n            }\n          })); // clicking outside commit zone → update reference for last committed\n          //  point\n\n          mutateElement(multiElement, {\n            lastCommittedPoint: multiElement.points[multiElement.points.length - 1]\n          });\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n        } else {\n          const element = newLinearElement({\n            type: this.state.elementType,\n            x: x,\n            y: y,\n            strokeColor: this.state.currentItemStrokeColor,\n            backgroundColor: this.state.currentItemBackgroundColor,\n            fillStyle: this.state.currentItemFillStyle,\n            strokeWidth: this.state.currentItemStrokeWidth,\n            roughness: this.state.currentItemRoughness,\n            opacity: this.state.currentItemOpacity\n          });\n          this.setState(prevState => ({\n            selectedElementIds: { ...prevState.selectedElementIds,\n              [element.id]: false\n            }\n          }));\n          mutateElement(element, {\n            points: [...element.points, [0, 0]]\n          });\n          globalSceneState.replaceAllElements([...globalSceneState.getElementsIncludingDeleted(), element]);\n          this.setState({\n            draggingElement: element,\n            editingElement: element\n          });\n        }\n      } else {\n        const element = newElement({\n          type: this.state.elementType,\n          x: x,\n          y: y,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity\n        });\n\n        if (element.type === \"selection\") {\n          this.setState({\n            selectionElement: element,\n            draggingElement: element\n          });\n        } else {\n          globalSceneState.replaceAllElements([...globalSceneState.getElementsIncludingDeleted(), element]);\n          this.setState({\n            multiElement: null,\n            draggingElement: element,\n            editingElement: element\n          });\n        }\n      }\n\n      let resizeArrowFn = null;\n\n      const setResizeArrrowFn = fn => {\n        resizeArrowFn = fn;\n      };\n\n      let selectedElementWasDuplicated = false;\n      const onPointerMove = withBatchedUpdates(event => {\n        const target = event.target;\n\n        if (!(target instanceof HTMLElement)) {\n          return;\n        }\n\n        if (isOverHorizontalScrollBar) {\n          const x = event.clientX;\n          const dx = x - lastX;\n          this.setState({\n            scrollX: normalizeScroll(this.state.scrollX - dx / this.state.zoom)\n          });\n          lastX = x;\n          return;\n        }\n\n        if (isOverVerticalScrollBar) {\n          const y = event.clientY;\n          const dy = y - lastY;\n          this.setState({\n            scrollY: normalizeScroll(this.state.scrollY - dy / this.state.zoom)\n          });\n          lastY = y;\n          return;\n        }\n\n        const {\n          x,\n          y\n        } = viewportCoordsToSceneCoords(event, this.state, this.canvas, window.devicePixelRatio); // for arrows, don't start dragging until a given threshold\n        //  to ensure we don't create a 2-point arrow by mistake when\n        //  user clicks mouse in a way that it moves a tiny bit (thus\n        //  triggering pointermove)\n\n        if (!draggingOccurred && (this.state.elementType === \"arrow\" || this.state.elementType === \"line\")) {\n          if (distance2d(x, y, originX, originY) < DRAGGING_THRESHOLD) {\n            return;\n          }\n        }\n\n        const resized = isResizingElements && resizeElements(resizeHandle, setResizeHandle, this.state, this.setAppState, resizeArrowFn, setResizeArrrowFn, event, x, y, lastX, lastY);\n\n        if (resized) {\n          lastX = x;\n          lastY = y;\n          return;\n        }\n\n        if (hitElement && this.state.selectedElementIds[hitElement.id]) {\n          // Marking that click was used for dragging to check\n          // if elements should be deselected on pointerup\n          draggingOccurred = true;\n          const selectedElements = getSelectedElements(globalSceneState.getElements(), this.state);\n\n          if (selectedElements.length > 0) {\n            const {\n              x,\n              y\n            } = viewportCoordsToSceneCoords(event, this.state, this.canvas, window.devicePixelRatio);\n            selectedElements.forEach(element => {\n              mutateElement(element, {\n                x: element.x + x - lastX,\n                y: element.y + y - lastY\n              });\n            });\n            lastX = x;\n            lastY = y; // We duplicate the selected element if alt is pressed on pointer move\n\n            if (event.altKey && !selectedElementWasDuplicated) {\n              // Move the currently selected elements to the top of the z index stack, and\n              // put the duplicates where the selected elements used to be.\n              // (the origin point where the dragging started)\n              selectedElementWasDuplicated = true;\n              const nextElements = [];\n              const elementsToAppend = [];\n\n              for (const element of globalSceneState.getElementsIncludingDeleted()) {\n                if (this.state.selectedElementIds[element.id] || // case: the state.selectedElementIds might not have been\n                //  updated yet by the time this mousemove event is fired\n                element.id === hitElement.id && hitElementWasAddedToSelection) {\n                  const duplicatedElement = duplicateElement(element);\n                  mutateElement(duplicatedElement, {\n                    x: duplicatedElement.x + (originX - lastX),\n                    y: duplicatedElement.y + (originY - lastY)\n                  });\n                  nextElements.push(duplicatedElement);\n                  elementsToAppend.push(element);\n                } else {\n                  nextElements.push(element);\n                }\n              }\n\n              globalSceneState.replaceAllElements([...nextElements, ...elementsToAppend]);\n            }\n\n            return;\n          }\n        } // It is very important to read this.state within each move event,\n        // otherwise we would read a stale one!\n\n\n        const draggingElement = this.state.draggingElement;\n\n        if (!draggingElement) {\n          return;\n        }\n\n        let width = distance(originX, x);\n        let height = distance(originY, y);\n\n        if (isLinearElement(draggingElement)) {\n          draggingOccurred = true;\n          const points = draggingElement.points;\n          let dx = x - draggingElement.x;\n          let dy = y - draggingElement.y;\n\n          if (event.shiftKey && points.length === 2) {\n            ({\n              width: dx,\n              height: dy\n            } = getPerfectElementSize(this.state.elementType, dx, dy));\n          }\n\n          if (points.length === 1) {\n            mutateElement(draggingElement, {\n              points: [...points, [dx, dy]]\n            });\n          } else if (points.length > 1) {\n            mutateElement(draggingElement, {\n              points: [...points.slice(0, -1), [dx, dy]]\n            });\n          }\n        } else {\n          if (event.shiftKey) {\n            ({\n              width,\n              height\n            } = getPerfectElementSize(this.state.elementType, width, y < originY ? -height : height));\n\n            if (height < 0) {\n              height = -height;\n            }\n          }\n\n          mutateElement(draggingElement, {\n            x: x < originX ? originX - width : originX,\n            y: y < originY ? originY - height : originY,\n            width: width,\n            height: height\n          });\n        }\n\n        if (this.state.elementType === \"selection\") {\n          const elements = globalSceneState.getElements();\n\n          if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n            this.setState({\n              selectedElementIds: {}\n            });\n          }\n\n          const elementsWithinSelection = getElementsWithinSelection(elements, draggingElement);\n          this.setState(prevState => ({\n            selectedElementIds: { ...prevState.selectedElementIds,\n              ...elementsWithinSelection.reduce((map, element) => {\n                map[element.id] = true;\n                return map;\n              }, {})\n            }\n          }));\n        }\n      });\n      const onPointerUp = withBatchedUpdates(childEvent => {\n        const {\n          draggingElement,\n          resizingElement,\n          multiElement,\n          elementType,\n          elementLocked\n        } = this.state;\n        this.setState({\n          isResizing: false,\n          isRotating: false,\n          resizingElement: null,\n          selectionElement: null,\n          cursorButton: \"up\",\n          editingElement: multiElement ? this.state.editingElement : null\n        });\n        this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n        resizeArrowFn = null;\n        lastPointerUp = null;\n        window.removeEventListener(\"pointermove\", onPointerMove);\n        window.removeEventListener(\"pointerup\", onPointerUp);\n\n        if (isLinearElement(draggingElement)) {\n          if (draggingElement.points.length > 1) {\n            history.resumeRecording();\n          }\n\n          if (!draggingOccurred && draggingElement && !multiElement) {\n            const {\n              x,\n              y\n            } = viewportCoordsToSceneCoords(childEvent, this.state, this.canvas, window.devicePixelRatio);\n            mutateElement(draggingElement, {\n              points: [...draggingElement.points, [x - draggingElement.x, y - draggingElement.y]]\n            });\n            this.setState({\n              multiElement: draggingElement,\n              editingElement: this.state.draggingElement\n            });\n          } else if (draggingOccurred && !multiElement) {\n            if (!elementLocked) {\n              resetCursor();\n              this.setState(prevState => ({\n                draggingElement: null,\n                elementType: \"selection\",\n                selectedElementIds: { ...prevState.selectedElementIds,\n                  [this.state.draggingElement.id]: true\n                }\n              }));\n            } else {\n              this.setState(prevState => ({\n                draggingElement: null,\n                selectedElementIds: { ...prevState.selectedElementIds,\n                  [this.state.draggingElement.id]: true\n                }\n              }));\n            }\n          }\n\n          return;\n        }\n\n        if (elementType !== \"selection\" && draggingElement && isInvisiblySmallElement(draggingElement)) {\n          // remove invisible element which was added in onPointerDown\n          globalSceneState.replaceAllElements(globalSceneState.getElementsIncludingDeleted().slice(0, -1));\n          this.setState({\n            draggingElement: null\n          });\n          return;\n        }\n\n        normalizeDimensions(draggingElement);\n\n        if (resizingElement) {\n          history.resumeRecording();\n        }\n\n        if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n          globalSceneState.replaceAllElements(globalSceneState.getElementsIncludingDeleted().filter(el => el.id !== resizingElement.id));\n        } // If click occurred on already selected element\n        // it is needed to remove selection from other elements\n        // or if SHIFT or META key pressed remove selection\n        // from hitted element\n        //\n        // If click occurred and elements were dragged or some element\n        // was added to selection (on pointerdown phase) we need to keep\n        // selection unchanged\n\n\n        if (hitElement && !draggingOccurred && !hitElementWasAddedToSelection) {\n          if (childEvent.shiftKey) {\n            this.setState(prevState => ({\n              selectedElementIds: { ...prevState.selectedElementIds,\n                [hitElement.id]: false\n              }\n            }));\n          } else {\n            this.setState(_prevState => ({\n              selectedElementIds: {\n                [hitElement.id]: true\n              }\n            }));\n          }\n        }\n\n        if (draggingElement === null) {\n          // if no element is clicked, clear the selection and redraw\n          this.setState({\n            selectedElementIds: {}\n          });\n          return;\n        }\n\n        if (!elementLocked) {\n          this.setState(prevState => ({\n            selectedElementIds: { ...prevState.selectedElementIds,\n              [draggingElement.id]: true\n            }\n          }));\n        }\n\n        if (elementType !== \"selection\" || isSomeElementSelected(globalSceneState.getElements(), this.state)) {\n          history.resumeRecording();\n        }\n\n        if (!elementLocked) {\n          resetCursor();\n          this.setState({\n            draggingElement: null,\n            elementType: \"selection\"\n          });\n        } else {\n          this.setState({\n            draggingElement: null\n          });\n        }\n      });\n      lastPointerUp = onPointerUp;\n      window.addEventListener(\"pointermove\", onPointerMove);\n      window.addEventListener(\"pointerup\", onPointerUp);\n    };\n\n    this.handleCanvasRef = canvas => {\n      // canvas is null when unmounting\n      if (canvas !== null) {\n        this.canvas = canvas;\n        this.rc = rough.canvas(this.canvas);\n        this.canvas.addEventListener(\"wheel\", this.handleWheel, {\n          passive: false\n        });\n        this.canvas.addEventListener(\"touchstart\", this.onTapStart);\n      } else {\n        var _this$canvas, _this$canvas2;\n\n        (_this$canvas = this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.removeEventListener(\"wheel\", this.handleWheel);\n        (_this$canvas2 = this.canvas) === null || _this$canvas2 === void 0 ? void 0 : _this$canvas2.removeEventListener(\"touchstart\", this.onTapStart);\n      }\n    };\n\n    this.handleCanvasOnDrop = event => {\n      var _event$dataTransfer;\n\n      const file = (_event$dataTransfer = event.dataTransfer) === null || _event$dataTransfer === void 0 ? void 0 : _event$dataTransfer.files[0];\n\n      if ((file === null || file === void 0 ? void 0 : file.type) === \"application/json\" || (file === null || file === void 0 ? void 0 : file.name.endsWith(\".excalidraw\"))) {\n        this.setState({\n          isLoading: true\n        });\n        loadFromBlob(file).then(({\n          elements,\n          appState\n        }) => this.syncActionResult({\n          elements,\n          appState: { ...(appState || this.state),\n            isLoading: false\n          },\n          commitToHistory: false\n        })).catch(error => {\n          this.setState({\n            isLoading: false,\n            errorMessage: error.message\n          });\n        });\n      } else {\n        this.setState({\n          isLoading: false,\n          errorMessage: t(\"alerts.couldNotLoadInvalidFile\")\n        });\n      }\n    };\n\n    this.handleCanvasContextMenu = event => {\n      event.preventDefault();\n      const {\n        x,\n        y\n      } = viewportCoordsToSceneCoords(event, this.state, this.canvas, window.devicePixelRatio);\n      const elements = globalSceneState.getElements();\n      const element = getElementAtPosition(elements, this.state, x, y, this.state.zoom);\n\n      if (!element) {\n        ContextMenu.push({\n          options: [navigator.clipboard && {\n            label: t(\"labels.paste\"),\n            action: () => this.pasteFromClipboard(null)\n          }, probablySupportsClipboardBlob && elements.length > 0 && {\n            label: t(\"labels.copyAsPng\"),\n            action: this.copyToClipboardAsPng\n          }, probablySupportsClipboardWriteText && elements.length > 0 && {\n            label: t(\"labels.copyAsSvg\"),\n            action: this.copyToClipboardAsSvg\n          }, ...this.actionManager.getContextMenuItems(action => this.canvasOnlyActions.includes(action.name))],\n          top: event.clientY,\n          left: event.clientX\n        });\n        return;\n      }\n\n      if (!this.state.selectedElementIds[element.id]) {\n        this.setState({\n          selectedElementIds: {\n            [element.id]: true\n          }\n        });\n      }\n\n      ContextMenu.push({\n        options: [navigator.clipboard && {\n          label: t(\"labels.copy\"),\n          action: this.copyAll\n        }, navigator.clipboard && {\n          label: t(\"labels.paste\"),\n          action: () => this.pasteFromClipboard(null)\n        }, probablySupportsClipboardBlob && {\n          label: t(\"labels.copyAsPng\"),\n          action: this.copyToClipboardAsPng\n        }, probablySupportsClipboardWriteText && {\n          label: t(\"labels.copyAsSvg\"),\n          action: this.copyToClipboardAsSvg\n        }, ...this.actionManager.getContextMenuItems(action => !this.canvasOnlyActions.includes(action.name))],\n        top: event.clientY,\n        left: event.clientX\n      });\n    };\n\n    this.handleWheel = withBatchedUpdates(event => {\n      event.preventDefault();\n      const {\n        deltaX,\n        deltaY\n      } = event; // note that event.ctrlKey is necessary to handle pinch zooming\n\n      if (event.metaKey || event.ctrlKey) {\n        const sign = Math.sign(deltaY);\n        const MAX_STEP = 10;\n        let delta = Math.abs(deltaY);\n\n        if (delta > MAX_STEP) {\n          delta = MAX_STEP;\n        }\n\n        delta *= sign;\n        this.setState(({\n          zoom\n        }) => ({\n          zoom: getNormalizedZoom(zoom - delta / 100)\n        }));\n        return;\n      }\n\n      this.setState(({\n        zoom,\n        scrollX,\n        scrollY\n      }) => ({\n        scrollX: normalizeScroll(scrollX - deltaX / zoom),\n        scrollY: normalizeScroll(scrollY - deltaY / zoom)\n      }));\n    });\n\n    this.savePointer = (x, y, button) => {\n      if (!x || !y) {\n        return;\n      }\n\n      const pointerCoords = viewportCoordsToSceneCoords({\n        clientX: x,\n        clientY: y\n      }, this.state, this.canvas, window.devicePixelRatio);\n\n      if (isNaN(pointerCoords.x) || isNaN(pointerCoords.y)) {\n        // sometimes the pointer goes off screen\n        return;\n      }\n\n      this.portal.socket && this.broadcastMouseLocation({\n        pointerCoords,\n        button\n      });\n    };\n\n    this.resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n      this.setState({\n        shouldCacheIgnoreZoom: false\n      });\n    }, 300);\n    this.saveDebounced = debounce(() => {\n      saveToLocalStorage(globalSceneState.getElementsIncludingDeleted(), this.state);\n    }, 300);\n    this.actionManager = new ActionManager(this.syncActionResult, () => this.state, () => globalSceneState.getElementsIncludingDeleted());\n    this.actionManager.registerAll(actions);\n    this.actionManager.registerAction(createUndoAction(history));\n    this.actionManager.registerAction(createRedoAction(history));\n  }\n\n  render() {\n    const canvasDOMWidth = window.innerWidth;\n    const canvasDOMHeight = window.innerHeight;\n    const canvasScale = window.devicePixelRatio;\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: \"container\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 237,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(LayerUI, {\n      canvas: this.canvas,\n      appState: this.state,\n      setAppState: this.setAppState,\n      actionManager: this.actionManager,\n      elements: globalSceneState.getElements(),\n      onRoomCreate: this.openPortal,\n      onRoomDestroy: this.closePortal,\n      onUsernameChange: username => {\n        saveUsernameToLocalStorage(username);\n        this.setState({\n          username\n        });\n      },\n      onLockToggle: this.toggleLock,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 238,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"main\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 254,\n        columnNumber: 9\n      }\n    }, /*#__PURE__*/React.createElement(\"canvas\", {\n      id: \"canvas\",\n      style: {\n        width: canvasDOMWidth,\n        height: canvasDOMHeight\n      },\n      width: canvasWidth,\n      height: canvasHeight,\n      ref: this.handleCanvasRef,\n      onContextMenu: this.handleCanvasContextMenu,\n      onPointerDown: this.handleCanvasPointerDown,\n      onDoubleClick: this.handleCanvasDoubleClick,\n      onPointerMove: this.handleCanvasPointerMove,\n      onPointerUp: this.removePointer,\n      onPointerCancel: this.removePointer,\n      onDrop: this.handleCanvasOnDrop,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 255,\n        columnNumber: 11\n      }\n    }, t(\"labels.drawingCanvas\"))));\n  }\n\n  async componentDidMount() {\n    if (process.env.NODE_ENV === \"test\" || process.env.NODE_ENV === \"development\") {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          }\n        },\n        setState: {\n          configurable: true,\n          value: (...args) => {\n            return this.setState(...args);\n          }\n        },\n        app: {\n          configurable: true,\n          value: this\n        }\n      });\n    }\n\n    this.removeSceneCallback = globalSceneState.addCallback(this.onSceneUpdated);\n    document.addEventListener(\"copy\", this.onCopy);\n    document.addEventListener(\"paste\", this.pasteFromClipboard);\n    document.addEventListener(\"cut\", this.onCut);\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    document.addEventListener(\"keyup\", this.onKeyUp, {\n      passive: true\n    });\n    document.addEventListener(\"mousemove\", this.updateCurrentCursorPosition);\n    window.addEventListener(\"resize\", this.onResize, false);\n    window.addEventListener(\"unload\", this.onUnload, false);\n    window.addEventListener(\"blur\", this.onBlur, false);\n    window.addEventListener(\"dragover\", this.disableEvent, false);\n    window.addEventListener(\"drop\", this.disableEvent, false); // Safari-only desktop pinch zoom\n\n    document.addEventListener(\"gesturestart\", this.onGestureStart, false);\n    document.addEventListener(\"gesturechange\", this.onGestureChange, false);\n    document.addEventListener(\"gestureend\", this.onGestureEnd, false);\n    window.addEventListener(\"beforeunload\", this.beforeUnload);\n    this.initializeScene();\n  }\n\n  componentWillUnmount() {\n    this.unmounted = true;\n    this.removeSceneCallback();\n    document.removeEventListener(\"copy\", this.onCopy);\n    document.removeEventListener(\"paste\", this.pasteFromClipboard);\n    document.removeEventListener(\"cut\", this.onCut);\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    document.removeEventListener(\"mousemove\", this.updateCurrentCursorPosition, false);\n    document.removeEventListener(\"keyup\", this.onKeyUp);\n    window.removeEventListener(\"resize\", this.onResize, false);\n    window.removeEventListener(\"unload\", this.onUnload, false);\n    window.removeEventListener(\"blur\", this.onBlur, false);\n    window.removeEventListener(\"dragover\", this.disableEvent, false);\n    window.removeEventListener(\"drop\", this.disableEvent, false);\n    document.removeEventListener(\"gesturestart\", this.onGestureStart, false);\n    document.removeEventListener(\"gesturechange\", this.onGestureChange, false);\n    document.removeEventListener(\"gestureend\", this.onGestureEnd, false);\n    window.removeEventListener(\"beforeunload\", this.beforeUnload);\n  }\n\n  componentDidUpdate() {\n    if (this.state.isCollaborating && !this.portal.socket) {\n      this.initializeSocketClient({\n        showLoadingState: true\n      });\n    }\n\n    const cursorButton = {};\n    const pointerViewportCoords = {};\n    const remoteSelectedElementIds = {};\n    const pointerUsernames = {};\n    this.state.collaborators.forEach((user, socketID) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n\n          remoteSelectedElementIds[id].push(socketID);\n        }\n      }\n\n      if (!user.pointer) {\n        return;\n      }\n\n      if (user.username) {\n        pointerUsernames[socketID] = user.username;\n      }\n\n      pointerViewportCoords[socketID] = sceneCoordsToViewportCoords({\n        sceneX: user.pointer.x,\n        sceneY: user.pointer.y\n      }, this.state, this.canvas, window.devicePixelRatio);\n      cursorButton[socketID] = user.button;\n    });\n    const elements = globalSceneState.getElements();\n    const {\n      atLeastOneVisibleElement,\n      scrollBars\n    } = renderScene(elements.filter(element => {\n      // don't render text element that's being currently edited (it's\n      //  rendered on remote only)\n      return !this.state.editingElement || this.state.editingElement.type !== \"text\" || element.id !== this.state.editingElement.id;\n    }), this.state, this.state.selectionElement, window.devicePixelRatio, this.rc, this.canvas, {\n      scrollX: this.state.scrollX,\n      scrollY: this.state.scrollY,\n      viewBackgroundColor: this.state.viewBackgroundColor,\n      zoom: this.state.zoom,\n      remotePointerViewportCoords: pointerViewportCoords,\n      remotePointerButton: cursorButton,\n      remoteSelectedElementIds: remoteSelectedElementIds,\n      remotePointerUsernames: pointerUsernames,\n      shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom\n    }, {\n      renderOptimizations: true\n    });\n\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n\n    const scrolledOutside = !atLeastOneVisibleElement && elements.length > 0;\n\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({\n        scrolledOutside: scrolledOutside\n      });\n    }\n\n    this.saveDebounced();\n\n    if (getDrawingVersion(globalSceneState.getElementsIncludingDeleted()) > this.lastBroadcastedOrReceivedSceneVersion) {\n      this.broadcastScene(\"SCENE_UPDATE\");\n    }\n\n    history.record(this.state, globalSceneState.getElementsIncludingDeleted());\n  } // Copy/paste\n\n\n  addTextFromPaste(text) {\n    const {\n      x,\n      y\n    } = viewportCoordsToSceneCoords({\n      clientX: cursorX,\n      clientY: cursorY\n    }, this.state, this.canvas, window.devicePixelRatio);\n    const element = newTextElement({\n      x: x,\n      y: y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      text: text,\n      font: this.state.currentItemFont,\n      textAlign: this.state.currentItemTextAlign\n    });\n    globalSceneState.replaceAllElements([...globalSceneState.getElementsIncludingDeleted(), element]);\n    this.setState({\n      selectedElementIds: {\n        [element.id]: true\n      }\n    });\n    history.resumeRecording();\n  } // Collaboration\n\n\n  selectShapeTool(elementType) {\n    if (!isHoldingSpace) {\n      setCursorForShape(elementType);\n    }\n\n    if (isToolIcon(document.activeElement)) {\n      document.activeElement.blur();\n    }\n\n    if (elementType !== \"selection\") {\n      this.setState({\n        elementType,\n        selectedElementIds: {}\n      });\n    } else {\n      this.setState({\n        elementType\n      });\n    }\n  }\n\n  handleTextWysiwyg(element, {\n    x,\n    y,\n    isExistingElement = false\n  }) {\n    const resetSelection = () => {\n      this.setState({\n        draggingElement: null,\n        editingElement: null\n      });\n    };\n\n    const deleteElement = () => {\n      globalSceneState.replaceAllElements([...globalSceneState.getElementsIncludingDeleted().map(_element => {\n        if (_element.id === element.id) {\n          return newElementWith(_element, {\n            isDeleted: true\n          });\n        }\n\n        return _element;\n      })]);\n    };\n\n    const updateElement = text => {\n      globalSceneState.replaceAllElements([...globalSceneState.getElementsIncludingDeleted().map(_element => {\n        if (_element.id === element.id) {\n          return newTextElement({ ..._element,\n            x: element.x,\n            y: element.y,\n            text\n          });\n        }\n\n        return _element;\n      })]);\n    };\n\n    const wysiwygElement = textWysiwyg({\n      x,\n      y,\n      initText: element.text,\n      strokeColor: element.strokeColor,\n      opacity: element.opacity,\n      font: element.font,\n      angle: element.angle,\n      textAlign: element.textAlign,\n      zoom: this.state.zoom,\n      onChange: withBatchedUpdates(text => {\n        if (text) {\n          updateElement(text);\n        } else {\n          deleteElement();\n        }\n      }),\n      onSubmit: withBatchedUpdates(text => {\n        updateElement(text);\n        this.setState(prevState => ({\n          wysiwygElement: null,\n          selectedElementIds: { ...prevState.selectedElementIds,\n            [element.id]: true\n          }\n        }));\n\n        if (this.state.elementLocked) {\n          setCursorForShape(this.state.elementType);\n        }\n\n        history.resumeRecording();\n        resetSelection();\n      }),\n      onCancel: withBatchedUpdates(() => {\n        deleteElement();\n\n        if (isExistingElement) {\n          history.resumeRecording();\n        }\n\n        resetSelection();\n      })\n    }); // deselect all other elements when inserting text\n\n    this.setState({\n      selectedElementIds: {},\n      wysiwygElement\n    }); // do an initial update to re-initialize element position since we were\n    //  modifying element's x/y for sake of editor (case: syncing to remote)\n\n    updateElement(element.text);\n  }\n\n  getTextWysiwygSnappedToCenterPosition(x, y, state, canvas, scale) {\n    const elementClickedInside = getElementContainingPosition(globalSceneState.getElementsIncludingDeleted(), x, y);\n\n    if (elementClickedInside) {\n      const elementCenterX = elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY = elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(x - elementCenterX, y - elementCenterY);\n      const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n\n      if (isSnappedToCenter) {\n        const {\n          x: wysiwygX,\n          y: wysiwygY\n        } = sceneCoordsToViewportCoords({\n          sceneX: elementCenterX,\n          sceneY: elementCenterY\n        }, state, canvas, scale);\n        return {\n          wysiwygX,\n          wysiwygY,\n          elementCenterX,\n          elementCenterY\n        };\n      }\n    }\n  }\n\n} // -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\nif (process.env.NODE_ENV === \"test\" || process.env.NODE_ENV === \"development\") {\n  window.h = {};\n  Object.defineProperties(window.h, {\n    elements: {\n      get() {\n        return globalSceneState.getElementsIncludingDeleted();\n      },\n\n      set(elements) {\n        return globalSceneState.replaceAllElements(elements);\n      }\n\n    },\n    history: {\n      get() {\n        return history;\n      }\n\n    }\n  });\n} // -----------------------------------------------------------------------------","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/components/App.tsx"],"names":["React","socketIOClient","rough","newElement","newTextElement","duplicateElement","isInvisiblySmallElement","isTextElement","textWysiwyg","getCommonBounds","getCursorForResizingElement","getPerfectElementSize","normalizeDimensions","getElementMap","getDrawingVersion","getSyncableElements","newLinearElement","resizeElements","getElementWithResizeHandler","canResizeMutlipleElements","getResizeHandlerFromCoords","isNonDeletedElement","deleteSelectedElements","getElementsWithinSelection","isOverScrollBars","getElementAtPosition","getElementContainingPosition","getNormalizedZoom","getSelectedElements","globalSceneState","isSomeElementSelected","calculateScrollCenter","decryptAESGEM","encryptAESGEM","saveToLocalStorage","loadScene","loadFromBlob","SOCKET_SERVER","exportCanvas","renderScene","distance2d","isPathALoop","isWritableElement","isInputLike","isToolIcon","debounce","distance","resetCursor","viewportCoordsToSceneCoords","sceneCoordsToViewportCoords","setCursorForShape","KEYS","isArrowKey","findShapeByKey","shapesShortcutKeys","createHistory","ContextMenu","ActionManager","actions","getDefaultAppState","t","copyToAppClipboard","getClipboardContent","probablySupportsClipboardBlob","probablySupportsClipboardWriteText","normalizeScroll","getCenter","getDistance","createUndoAction","createRedoAction","CURSOR_TYPE","ELEMENT_SHIFT_TRANSLATE_AMOUNT","ELEMENT_TRANSLATE_AMOUNT","POINTER_BUTTON","DRAGGING_THRESHOLD","TEXT_TO_CENTER_SNAP_THRESHOLD","LINE_CONFIRM_THRESHOLD","LayerUI","generateCollaborationLink","getCollaborationLinkData","mutateElement","newElementWith","invalidateShapeForElement","unstable_batchedUpdates","isLinearElement","actionFinalize","restoreUsernameFromLocalStorage","saveUsernameToLocalStorage","withBatchedUpdates","func","event","history","didTapTwice","tappedTwiceTimer","cursorX","cursorY","isHoldingSpace","isPanning","isDraggingScrollBar","currentScrollBars","horizontal","vertical","lastPointerUp","gesture","pointers","Map","lastCenter","initialDistance","initialScale","Portal","socket","socketInitialized","roomID","roomKey","open","id","key","close","isOpen","_broadcastSocketData","data","volatile","json","JSON","stringify","encoded","TextEncoder","encode","encrypted","emit","iv","App","Component","constructor","props","canvas","rc","portal","lastBroadcastedOrReceivedSceneVersion","removeSceneCallback","actionManager","canvasOnlyActions","state","isLoading","syncActionResult","res","unmounted","editingElement","elements","forEach","element","replaceAllElements","commitToHistory","resumeRecording","appState","setState","isCollaborating","collaborators","onBlur","saveDebounced","flush","onUnload","destroySocketClient","disableEvent","preventDefault","initializeScene","searchParams","URLSearchParams","window","location","search","get","jsonMatch","hash","match","isCollaborationScene","href","scene","Promise","race","document","fonts","ready","then","getElementsIncludingDeleted","resolve","setTimeout","error","console","initializeSocketClient","showLoadingState","onResize","beforeUnload","getElements","length","returnValue","onCut","target","copyAll","nextElements","onCopy","copyToClipboardAsPng","selectedElements","copyToClipboardAsSvg","onTapStart","clearTimeout","touches","touch","handleCanvasDoubleClick","clientX","clientY","pasteFromClipboard","activeElement","elementUnderCursor","elementFromPoint","HTMLCanvasElement","addElementsFromPaste","text","addTextFromPaste","selectShapeTool","clipboardElements","minX","minY","maxX","maxY","elementsCenterX","elementsCenterY","x","y","devicePixelRatio","dx","dy","newElements","map","selectedElementIds","reduce","setAppState","obj","removePointer","delete","pointerId","openPortal","pushState","closePortal","origin","toggleLock","prevState","elementLocked","elementType","opts","roomMatch","initialize","initializationTimer","updateScene","decryptedData","scrollToContent","remoteElements","payload","filter","isDeleted","localElementMap","resizingElement","draggingElement","hasOwnProperty","version","push","versionNonce","concat","Object","values","clear","on","username","encryptedData","type","socketID","pointerCoords","button","has","set","user","pointer","off","clients","_socketID","broadcastScene","broadcastMouseLocation","sceneType","Math","max","onSceneUpdated","updateCurrentCursorPosition","onKeyDown","ESCAPE","QUESTION_MARK","showShortcutsDialog","code","altKey","shiftKey","handleKeyDown","shape","step","el","update","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","ENTER","selectedElement","width","height","startTextEditing","ctrlKey","metaKey","includes","toLowerCase","SPACE","size","documentElement","style","cursor","GRABBING","onKeyUp","onGestureStart","zoom","onGestureChange","scale","onGestureEnd","setElements","centerIfPossible","elementAtPosition","strokeColor","currentItemStrokeColor","backgroundColor","currentItemBackgroundColor","fillStyle","currentItemFillStyle","strokeWidth","currentItemStrokeWidth","roughness","currentItemRoughness","opacity","currentItemOpacity","font","currentItemFont","textAlign","currentItemTextAlign","textX","textY","isExistingTextElement","centerElementX","centerElementY","centerElementXInViewport","centerElementYInViewport","sceneX","sceneY","snappedToCenterPosition","getTextWysiwygSnappedToCenterPosition","elementCenterX","elementCenterY","wysiwygX","wysiwygY","handleTextWysiwyg","isExistingElement","multiElement","handleCanvasPointerMove","savePointer","cursorButton","center","deltaX","deltaY","Array","from","scaleFactor","scrollX","scrollY","shouldCacheIgnoreZoom","resetShouldCacheIgnoreZoomDebounced","isOverHorizontalScrollBar","isOverVerticalScrollBar","isOverScrollBar","rx","ry","points","lastCommittedPoint","lastPoint","POINTER","slice","hasDeselectedButton","Boolean","buttons","elementWithResizeHandler","pointerType","resizeHandle","hitElement","TEXT","CROSSHAIR","handleCanvasPointerDown","wysiwygElement","submit","lastPointerDownWith","WHEEL","MAIN","lastX","lastY","onPointerMove","teardown","removeEventListener","addEventListener","passive","TOUCH","HTMLElement","blur","onPointerUp","originX","originY","setResizeHandle","nextResizeHandle","isResizingElements","draggingOccurred","hitElementWasAddedToSelection","executeAction","selectionElement","resizeArrowFn","setResizeArrrowFn","fn","selectedElementWasDuplicated","resized","elementsToAppend","duplicatedElement","elementsWithinSelection","childEvent","isResizing","isRotating","_prevState","handleCanvasRef","handleWheel","handleCanvasOnDrop","file","dataTransfer","files","name","endsWith","catch","errorMessage","message","handleCanvasContextMenu","options","navigator","clipboard","label","action","getContextMenuItems","top","left","sign","MAX_STEP","delta","abs","isNaN","registerAll","registerAction","render","canvasDOMWidth","innerWidth","canvasDOMHeight","innerHeight","canvasScale","canvasWidth","canvasHeight","componentDidMount","process","env","NODE_ENV","bind","defineProperties","h","configurable","value","args","app","addCallback","componentWillUnmount","componentDidUpdate","pointerViewportCoords","remoteSelectedElementIds","pointerUsernames","keys","atLeastOneVisibleElement","scrollBars","viewBackgroundColor","remotePointerViewportCoords","remotePointerButton","remotePointerUsernames","renderOptimizations","scrolledOutside","record","resetSelection","deleteElement","_element","updateElement","initText","angle","onChange","onSubmit","onCancel","elementClickedInside","distanceToCenter","hypot","isSnappedToCenter"],"mappings":"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","sourcesContent":["import React from \"react\";\n\nimport socketIOClient from \"socket.io-client\";\nimport rough from \"roughjs/bin/rough\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { FlooredNumber } from \"../types\";\n\nimport {\n  newElement,\n  newTextElement,\n  duplicateElement,\n  resizeTest,\n  isInvisiblySmallElement,\n  isTextElement,\n  textWysiwyg,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getPerfectElementSize,\n  normalizeDimensions,\n  getElementMap,\n  getDrawingVersion,\n  getSyncableElements,\n  newLinearElement,\n  resizeElements,\n  getElementWithResizeHandler,\n  canResizeMutlipleElements,\n  getResizeHandlerFromCoords,\n  isNonDeletedElement,\n} from \"../element\";\nimport {\n  deleteSelectedElements,\n  getElementsWithinSelection,\n  isOverScrollBars,\n  getElementAtPosition,\n  getElementContainingPosition,\n  getNormalizedZoom,\n  getSelectedElements,\n  globalSceneState,\n  isSomeElementSelected,\n  calculateScrollCenter,\n} from \"../scene\";\nimport {\n  decryptAESGEM,\n  encryptAESGEM,\n  saveToLocalStorage,\n  loadScene,\n  loadFromBlob,\n  SOCKET_SERVER,\n  SocketUpdateDataSource,\n  exportCanvas,\n} from \"../data\";\n\nimport { renderScene } from \"../renderer\";\nimport { AppState, GestureEvent, Gesture } from \"../types\";\nimport {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ResizeArrowFnType,\n} from \"../element/types\";\n\nimport { distance2d, isPathALoop } from \"../math\";\n\nimport {\n  isWritableElement,\n  isInputLike,\n  isToolIcon,\n  debounce,\n  distance,\n  resetCursor,\n  viewportCoordsToSceneCoords,\n  sceneCoordsToViewportCoords,\n  setCursorForShape,\n} from \"../utils\";\nimport { KEYS, isArrowKey } from \"../keys\";\n\nimport { findShapeByKey, shapesShortcutKeys } from \"../shapes\";\nimport { createHistory, SceneHistory } from \"../history\";\n\nimport ContextMenu from \"./ContextMenu\";\n\nimport { ActionManager } from \"../actions/manager\";\nimport \"../actions\";\nimport { actions } from \"../actions/register\";\n\nimport { ActionResult } from \"../actions/types\";\nimport { getDefaultAppState } from \"../appState\";\nimport { t } from \"../i18n\";\n\nimport {\n  copyToAppClipboard,\n  getClipboardContent,\n  probablySupportsClipboardBlob,\n  probablySupportsClipboardWriteText,\n} from \"../clipboard\";\nimport { normalizeScroll } from \"../scene\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport { createUndoAction, createRedoAction } from \"../actions/actionHistory\";\nimport {\n  CURSOR_TYPE,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  POINTER_BUTTON,\n  DRAGGING_THRESHOLD,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n  LINE_CONFIRM_THRESHOLD,\n} from \"../constants\";\nimport { LayerUI } from \"./LayerUI\";\nimport { ScrollBars, SceneState } from \"../scene/types\";\nimport { generateCollaborationLink, getCollaborationLinkData } from \"../data\";\nimport { mutateElement, newElementWith } from \"../element/mutateElement\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { SceneStateCallbackRemover } from \"../scene/globalScene\";\nimport { isLinearElement } from \"../element/typeChecks\";\nimport { actionFinalize } from \"../actions\";\nimport {\n  restoreUsernameFromLocalStorage,\n  saveUsernameToLocalStorage,\n} from \"../data/localStorage\";\n\n/**\n * @param func handler taking at most single parameter (event).\n */\nfunction withBatchedUpdates<\n  TFunction extends ((event: any) => void) | (() => void)\n>(func: Parameters<TFunction>[\"length\"] extends 0 | 1 ? TFunction : never) {\n  return (\n    ((event) => {\n      unstable_batchedUpdates(func as TFunction, event);\n    }) as TFunction\n  );\n}\n\nconst { history } = createHistory();\n\nlet didTapTwice: boolean = false;\nlet tappedTwiceTimer = 0;\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nclass Portal {\n  socket: SocketIOClient.Socket | null = null;\n  socketInitialized: boolean = false; // we don't want the socket to emit any updates until it is fully initalized\n  roomID: string | null = null;\n  roomKey: string | null = null;\n\n  open(socket: SocketIOClient.Socket, id: string, key: string) {\n    this.socket = socket;\n    this.roomID = id;\n    this.roomKey = key;\n  }\n\n  close() {\n    if (!this.socket) {\n      return;\n    }\n    this.socket.close();\n    this.socket = null;\n    this.roomID = null;\n    this.roomKey = null;\n  }\n\n  isOpen() {\n    return this.socketInitialized && this.socket && this.roomID && this.roomKey;\n  }\n\n  async _broadcastSocketData(\n    data: SocketUpdateDataSource[keyof SocketUpdateDataSource] & {\n      _brand: \"socketUpdateData\";\n    },\n    volatile: boolean = false,\n  ) {\n    if (this.isOpen()) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey!);\n      this.socket!.emit(\n        volatile ? \"server-volatile-broadcast\" : \"server-broadcast\",\n        this.roomID,\n        encrypted.data,\n        encrypted.iv,\n      );\n    }\n  }\n}\n\nexport class App extends React.Component<any, AppState> {\n  canvas: HTMLCanvasElement | null = null;\n  rc: RoughCanvas | null = null;\n  portal: Portal = new Portal();\n  lastBroadcastedOrReceivedSceneVersion: number = -1;\n  removeSceneCallback: SceneStateCallbackRemover | null = null;\n\n  actionManager: ActionManager;\n  canvasOnlyActions = [\"selectAll\"];\n\n  public state: AppState = {\n    ...getDefaultAppState(),\n    isLoading: true,\n  };\n\n  constructor(props: any) {\n    super(props);\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => globalSceneState.getElementsIncludingDeleted(),\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(history));\n    this.actionManager.registerAction(createRedoAction(history));\n  }\n\n  public render() {\n    const canvasDOMWidth = window.innerWidth;\n    const canvasDOMHeight = window.innerHeight;\n\n    const canvasScale = window.devicePixelRatio;\n\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n\n    return (\n      <div className=\"container\">\n        <LayerUI\n          canvas={this.canvas}\n          appState={this.state}\n          setAppState={this.setAppState}\n          actionManager={this.actionManager}\n          elements={globalSceneState.getElements()}\n          onRoomCreate={this.openPortal}\n          onRoomDestroy={this.closePortal}\n          onUsernameChange={(username) => {\n            saveUsernameToLocalStorage(username);\n            this.setState({\n              username,\n            });\n          }}\n          onLockToggle={this.toggleLock}\n        />\n        <main>\n          <canvas\n            id=\"canvas\"\n            style={{\n              width: canvasDOMWidth,\n              height: canvasDOMHeight,\n            }}\n            width={canvasWidth}\n            height={canvasHeight}\n            ref={this.handleCanvasRef}\n            onContextMenu={this.handleCanvasContextMenu}\n            onPointerDown={this.handleCanvasPointerDown}\n            onDoubleClick={this.handleCanvasDoubleClick}\n            onPointerMove={this.handleCanvasPointerMove}\n            onPointerUp={this.removePointer}\n            onPointerCancel={this.removePointer}\n            onDrop={this.handleCanvasOnDrop}\n          >\n            {t(\"labels.drawingCanvas\")}\n          </canvas>\n        </main>\n      </div>\n    );\n  }\n\n  private syncActionResult = withBatchedUpdates((res: ActionResult) => {\n    if (this.unmounted) {\n      return;\n    }\n\n    let editingElement: AppState[\"editingElement\"] | null = null;\n    if (res.elements) {\n      res.elements.forEach((element) => {\n        if (\n          this.state.editingElement?.id === element.id &&\n          this.state.editingElement !== element &&\n          isNonDeletedElement(element)\n        ) {\n          editingElement = element;\n        }\n      });\n      globalSceneState.replaceAllElements(res.elements);\n      if (res.commitToHistory) {\n        history.resumeRecording();\n      }\n    }\n\n    if (res.appState || editingElement) {\n      if (res.commitToHistory) {\n        history.resumeRecording();\n      }\n      this.setState((state) => ({\n        ...res.appState,\n        editingElement: editingElement || state.editingElement,\n        isCollaborating: state.isCollaborating,\n        collaborators: state.collaborators,\n      }));\n    }\n  });\n\n  // Lifecycle\n\n  private onBlur = withBatchedUpdates(() => {\n    isHoldingSpace = false;\n    this.saveDebounced();\n    this.saveDebounced.flush();\n  });\n\n  private onUnload = () => {\n    this.destroySocketClient();\n    this.onBlur();\n  };\n\n  private disableEvent: EventHandlerNonNull = (event) => {\n    event.preventDefault();\n  };\n\n  private initializeScene = async () => {\n    const searchParams = new URLSearchParams(window.location.search);\n    const id = searchParams.get(\"id\");\n    const jsonMatch = window.location.hash.match(\n      /^#json=([0-9]+),([a-zA-Z0-9_-]+)$/,\n    );\n\n    const isCollaborationScene = getCollaborationLinkData(window.location.href);\n\n    if (!isCollaborationScene) {\n      let scene: ResolutionType<typeof loadScene> | undefined;\n      // Backwards compatibility with legacy url format\n      if (id) {\n        scene = await loadScene(id);\n      } else if (jsonMatch) {\n        scene = await loadScene(jsonMatch[1], jsonMatch[2]);\n      } else {\n        scene = await loadScene(null);\n      }\n      if (scene) {\n        this.syncActionResult(scene);\n      }\n    }\n\n    // rerender text elements on font load to fix #637\n    try {\n      await Promise.race([\n        document.fonts?.ready?.then(() => {\n          globalSceneState.getElementsIncludingDeleted().forEach((element) => {\n            if (isTextElement(element)) {\n              invalidateShapeForElement(element);\n            }\n          });\n        }),\n        // if fonts don't load in 1s for whatever reason, don't block the UI\n        new Promise((resolve) => setTimeout(resolve, 1000)),\n      ]);\n    } catch (error) {\n      console.error(error);\n    }\n\n    if (this.state.isLoading) {\n      this.setState({ isLoading: false });\n    }\n\n    // run this last else the `isLoading` state\n    if (isCollaborationScene) {\n      this.initializeSocketClient({ showLoadingState: true });\n    }\n  };\n\n  private unmounted = false;\n\n  public async componentDidMount() {\n    if (\n      process.env.NODE_ENV === \"test\" ||\n      process.env.NODE_ENV === \"development\"\n    ) {\n      const setState = this.setState.bind(this);\n      Object.defineProperties(window.h, {\n        state: {\n          configurable: true,\n          get: () => {\n            return this.state;\n          },\n        },\n        setState: {\n          configurable: true,\n          value: (...args: Parameters<typeof setState>) => {\n            return this.setState(...args);\n          },\n        },\n        app: {\n          configurable: true,\n          value: this,\n        },\n      });\n    }\n\n    this.removeSceneCallback = globalSceneState.addCallback(\n      this.onSceneUpdated,\n    );\n\n    document.addEventListener(\"copy\", this.onCopy);\n    document.addEventListener(\"paste\", this.pasteFromClipboard);\n    document.addEventListener(\"cut\", this.onCut);\n\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    document.addEventListener(\"keyup\", this.onKeyUp, { passive: true });\n    document.addEventListener(\"mousemove\", this.updateCurrentCursorPosition);\n    window.addEventListener(\"resize\", this.onResize, false);\n    window.addEventListener(\"unload\", this.onUnload, false);\n    window.addEventListener(\"blur\", this.onBlur, false);\n    window.addEventListener(\"dragover\", this.disableEvent, false);\n    window.addEventListener(\"drop\", this.disableEvent, false);\n\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      \"gesturestart\",\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      \"gesturechange\",\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\"gestureend\", this.onGestureEnd as any, false);\n    window.addEventListener(\"beforeunload\", this.beforeUnload);\n\n    this.initializeScene();\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n    this.removeSceneCallback!();\n\n    document.removeEventListener(\"copy\", this.onCopy);\n    document.removeEventListener(\"paste\", this.pasteFromClipboard);\n    document.removeEventListener(\"cut\", this.onCut);\n\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    document.removeEventListener(\n      \"mousemove\",\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(\"keyup\", this.onKeyUp);\n    window.removeEventListener(\"resize\", this.onResize, false);\n    window.removeEventListener(\"unload\", this.onUnload, false);\n    window.removeEventListener(\"blur\", this.onBlur, false);\n    window.removeEventListener(\"dragover\", this.disableEvent, false);\n    window.removeEventListener(\"drop\", this.disableEvent, false);\n\n    document.removeEventListener(\n      \"gesturestart\",\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      \"gesturechange\",\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\"gestureend\", this.onGestureEnd as any, false);\n    window.removeEventListener(\"beforeunload\", this.beforeUnload);\n  }\n  private onResize = withBatchedUpdates(() => {\n    globalSceneState\n      .getElementsIncludingDeleted()\n      .forEach((element) => invalidateShapeForElement(element));\n    this.setState({});\n  });\n\n  private beforeUnload = withBatchedUpdates((event: BeforeUnloadEvent) => {\n    if (\n      this.state.isCollaborating &&\n      globalSceneState.getElements().length > 0\n    ) {\n      event.preventDefault();\n      // NOTE: modern browsers no longer allow showing a custom message here\n      event.returnValue = \"\";\n    }\n  });\n\n  componentDidUpdate() {\n    if (this.state.isCollaborating && !this.portal.socket) {\n      this.initializeSocketClient({ showLoadingState: true });\n    }\n\n    const cursorButton: {\n      [id: string]: string | undefined;\n    } = {};\n    const pointerViewportCoords: SceneState[\"remotePointerViewportCoords\"] = {};\n    const remoteSelectedElementIds: SceneState[\"remoteSelectedElementIds\"] = {};\n    const pointerUsernames: { [id: string]: string } = {};\n    this.state.collaborators.forEach((user, socketID) => {\n      if (user.selectedElementIds) {\n        for (const id of Object.keys(user.selectedElementIds)) {\n          if (!(id in remoteSelectedElementIds)) {\n            remoteSelectedElementIds[id] = [];\n          }\n          remoteSelectedElementIds[id].push(socketID);\n        }\n      }\n      if (!user.pointer) {\n        return;\n      }\n      if (user.username) {\n        pointerUsernames[socketID] = user.username;\n      }\n      pointerViewportCoords[socketID] = sceneCoordsToViewportCoords(\n        {\n          sceneX: user.pointer.x,\n          sceneY: user.pointer.y,\n        },\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n      cursorButton[socketID] = user.button;\n    });\n    const elements = globalSceneState.getElements();\n    const { atLeastOneVisibleElement, scrollBars } = renderScene(\n      elements.filter((element) => {\n        // don't render text element that's being currently edited (it's\n        //  rendered on remote only)\n        return (\n          !this.state.editingElement ||\n          this.state.editingElement.type !== \"text\" ||\n          element.id !== this.state.editingElement.id\n        );\n      }),\n      this.state,\n      this.state.selectionElement,\n      window.devicePixelRatio,\n      this.rc!,\n      this.canvas!,\n      {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords,\n        remotePointerButton: cursorButton,\n        remoteSelectedElementIds: remoteSelectedElementIds,\n        remotePointerUsernames: pointerUsernames,\n        shouldCacheIgnoreZoom: this.state.shouldCacheIgnoreZoom,\n      },\n      {\n        renderOptimizations: true,\n      },\n    );\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside = !atLeastOneVisibleElement && elements.length > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside: scrolledOutside });\n    }\n    this.saveDebounced();\n\n    if (\n      getDrawingVersion(globalSceneState.getElementsIncludingDeleted()) >\n      this.lastBroadcastedOrReceivedSceneVersion\n    ) {\n      this.broadcastScene(\"SCENE_UPDATE\");\n    }\n\n    history.record(this.state, globalSceneState.getElementsIncludingDeleted());\n  }\n\n  // Copy/paste\n\n  private onCut = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    const { elements: nextElements, appState } = deleteSelectedElements(\n      globalSceneState.getElementsIncludingDeleted(),\n      this.state,\n    );\n    globalSceneState.replaceAllElements(nextElements);\n    history.resumeRecording();\n    this.setState({ ...appState });\n    event.preventDefault();\n  });\n\n  private onCopy = withBatchedUpdates((event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    this.copyAll();\n    event.preventDefault();\n  });\n\n  private copyAll = () => {\n    copyToAppClipboard(globalSceneState.getElements(), this.state);\n  };\n\n  private copyToClipboardAsPng = () => {\n    const elements = globalSceneState.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    exportCanvas(\n      \"clipboard\",\n      selectedElements.length ? selectedElements : elements,\n      this.state,\n      this.canvas!,\n      this.state,\n    );\n  };\n\n  private copyToClipboardAsSvg = () => {\n    const selectedElements = getSelectedElements(\n      globalSceneState.getElements(),\n      this.state,\n    );\n    exportCanvas(\n      \"clipboard-svg\",\n      selectedElements.length\n        ? selectedElements\n        : globalSceneState.getElements(),\n      this.state,\n      this.canvas!,\n      this.state,\n    );\n  };\n\n  private onTapStart = (event: TouchEvent) => {\n    if (!didTapTwice) {\n      didTapTwice = true;\n      clearTimeout(tappedTwiceTimer);\n      tappedTwiceTimer = window.setTimeout(() => (didTapTwice = false), 300);\n      return;\n    }\n    // insert text only if we tapped twice with a single finger\n    // event.touches.length === 1 will also prevent inserting text when user's zooming\n    if (didTapTwice && event.touches.length === 1) {\n      const [touch] = event.touches;\n      // @ts-ignore\n      this.handleCanvasDoubleClick({\n        clientX: touch.clientX,\n        clientY: touch.clientY,\n      });\n      didTapTwice = false;\n      clearTimeout(tappedTwiceTimer);\n    }\n    event.preventDefault();\n  };\n\n  private pasteFromClipboard = withBatchedUpdates(\n    async (event: ClipboardEvent | null) => {\n      // #686\n      const target = document.activeElement;\n      const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n      if (\n        // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n        //  thus these checks don't make sense\n        event &&\n        (!(elementUnderCursor instanceof HTMLCanvasElement) ||\n          isWritableElement(target))\n      ) {\n        return;\n      }\n      const data = await getClipboardContent(event);\n      if (data.elements) {\n        this.addElementsFromPaste(data.elements);\n      } else if (data.text) {\n        this.addTextFromPaste(data.text);\n      }\n      this.selectShapeTool(\"selection\");\n      event?.preventDefault();\n    },\n  );\n\n  private addElementsFromPaste = (\n    clipboardElements: readonly ExcalidrawElement[],\n  ) => {\n    const [minX, minY, maxX, maxY] = getCommonBounds(clipboardElements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n      this.canvas,\n      window.devicePixelRatio,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n\n    const newElements = clipboardElements.map((element) =>\n      duplicateElement(element, {\n        x: element.x + dx - minX,\n        y: element.y + dy - minY,\n      }),\n    );\n\n    globalSceneState.replaceAllElements([\n      ...globalSceneState.getElementsIncludingDeleted(),\n      ...newElements,\n    ]);\n    history.resumeRecording();\n    this.setState({\n      selectedElementIds: newElements.reduce((map, element) => {\n        map[element.id] = true;\n        return map;\n      }, {} as any),\n    });\n  };\n\n  private addTextFromPaste(text: any) {\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n      this.canvas,\n      window.devicePixelRatio,\n    );\n\n    const element = newTextElement({\n      x: x,\n      y: y,\n      strokeColor: this.state.currentItemStrokeColor,\n      backgroundColor: this.state.currentItemBackgroundColor,\n      fillStyle: this.state.currentItemFillStyle,\n      strokeWidth: this.state.currentItemStrokeWidth,\n      roughness: this.state.currentItemRoughness,\n      opacity: this.state.currentItemOpacity,\n      text: text,\n      font: this.state.currentItemFont,\n      textAlign: this.state.currentItemTextAlign,\n    });\n\n    globalSceneState.replaceAllElements([\n      ...globalSceneState.getElementsIncludingDeleted(),\n      element,\n    ]);\n    this.setState({ selectedElementIds: { [element.id]: true } });\n    history.resumeRecording();\n  }\n\n  // Collaboration\n\n  setAppState = (obj: any) => {\n    this.setState(obj);\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement>) => {\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  openPortal = async () => {\n    window.history.pushState(\n      {},\n      \"Excalidraw\",\n      await generateCollaborationLink(),\n    );\n    this.initializeSocketClient({ showLoadingState: false });\n  };\n\n  closePortal = () => {\n    window.history.pushState({}, \"Excalidraw\", window.location.origin);\n    this.destroySocketClient();\n  };\n\n  toggleLock = () => {\n    this.setState((prevState) => ({\n      elementLocked: !prevState.elementLocked,\n      elementType: prevState.elementLocked\n        ? \"selection\"\n        : prevState.elementType,\n    }));\n  };\n\n  private destroySocketClient = () => {\n    this.setState({\n      isCollaborating: false,\n      collaborators: new Map(),\n    });\n    this.portal.close();\n  };\n\n  private initializeSocketClient = (opts: { showLoadingState: boolean }) => {\n    if (this.portal.socket) {\n      return;\n    }\n    const roomMatch = getCollaborationLinkData(window.location.href);\n    if (roomMatch) {\n      const initialize = () => {\n        this.portal.socketInitialized = true;\n        clearTimeout(initializationTimer);\n        if (this.state.isLoading && !this.unmounted) {\n          this.setState({ isLoading: false });\n        }\n      };\n      // fallback in case you're not alone in the room but still don't receive\n      //  initial SCENE_UPDATE message\n      const initializationTimer = setTimeout(initialize, 5000);\n\n      const updateScene = (\n        decryptedData: SocketUpdateDataSource[\"SCENE_INIT\" | \"SCENE_UPDATE\"],\n        { scrollToContent = false }: { scrollToContent?: boolean } = {},\n      ) => {\n        const { elements: remoteElements } = decryptedData.payload;\n\n        if (scrollToContent) {\n          this.setState({\n            ...this.state,\n            ...calculateScrollCenter(\n              remoteElements.filter((element) => {\n                return !element.isDeleted;\n              }),\n            ),\n          });\n        }\n\n        // Perform reconciliation - in collaboration, if we encounter\n        // elements with more staler versions than ours, ignore them\n        // and keep ours.\n        if (\n          globalSceneState.getElementsIncludingDeleted() == null ||\n          globalSceneState.getElementsIncludingDeleted().length === 0\n        ) {\n          globalSceneState.replaceAllElements(remoteElements);\n        } else {\n          // create a map of ids so we don't have to iterate\n          // over the array more than once.\n          const localElementMap = getElementMap(\n            globalSceneState.getElementsIncludingDeleted(),\n          );\n\n          // Reconcile\n          const newElements = remoteElements\n            .reduce((elements, element) => {\n              // if the remote element references one that's currently\n              //  edited on local, skip it (it'll be added in the next\n              //  step)\n              if (\n                element.id === this.state.editingElement?.id ||\n                element.id === this.state.resizingElement?.id ||\n                element.id === this.state.draggingElement?.id\n              ) {\n                return elements;\n              }\n\n              if (\n                localElementMap.hasOwnProperty(element.id) &&\n                localElementMap[element.id].version > element.version\n              ) {\n                elements.push(localElementMap[element.id]);\n                delete localElementMap[element.id];\n              } else if (\n                localElementMap.hasOwnProperty(element.id) &&\n                localElementMap[element.id].version === element.version &&\n                localElementMap[element.id].versionNonce !==\n                  element.versionNonce\n              ) {\n                // resolve conflicting edits deterministically by taking the one with the lowest versionNonce\n                if (\n                  localElementMap[element.id].versionNonce <\n                  element.versionNonce\n                ) {\n                  elements.push(localElementMap[element.id]);\n                } else {\n                  // it should be highly unlikely that the two versionNonces are the same. if we are\n                  // really worried about this, we can replace the versionNonce with the socket id.\n                  elements.push(element);\n                }\n                delete localElementMap[element.id];\n              } else {\n                elements.push(element);\n                delete localElementMap[element.id];\n              }\n\n              return elements;\n            }, [] as Mutable<typeof remoteElements>)\n            // add local elements that weren't deleted or on remote\n            .concat(...Object.values(localElementMap));\n\n          // Avoid broadcasting to the rest of the collaborators the scene\n          // we just received!\n          // Note: this needs to be set before replaceAllElements as it\n          // syncronously calls render.\n          this.lastBroadcastedOrReceivedSceneVersion = getDrawingVersion(\n            newElements,\n          );\n\n          globalSceneState.replaceAllElements(newElements);\n        }\n\n        // We haven't yet implemented multiplayer undo functionality, so we clear the undo stack\n        // when we receive any messages from another peer. This UX can be pretty rough -- if you\n        // undo, a user makes a change, and then try to redo, your element(s) will be lost. However,\n        // right now we think this is the right tradeoff.\n        history.clear();\n        if (this.portal.socketInitialized === false) {\n          initialize();\n        }\n      };\n\n      this.portal.open(\n        socketIOClient(SOCKET_SERVER),\n        roomMatch[1],\n        roomMatch[2],\n      );\n\n      this.portal.socket!.on(\"init-room\", () => {\n        if (this.portal.socket) {\n          const username = restoreUsernameFromLocalStorage();\n\n          this.portal.socket.emit(\"join-room\", this.portal.roomID);\n\n          if (username !== null) {\n            this.setState({\n              username,\n            });\n          }\n        }\n      });\n      this.portal.socket!.on(\n        \"client-broadcast\",\n        async (encryptedData: ArrayBuffer, iv: Uint8Array) => {\n          if (!this.portal.roomKey) {\n            return;\n          }\n          const decryptedData = await decryptAESGEM(\n            encryptedData,\n            this.portal.roomKey,\n            iv,\n          );\n\n          switch (decryptedData.type) {\n            case \"INVALID_RESPONSE\":\n              return;\n            case \"SCENE_INIT\": {\n              if (!this.portal.socketInitialized) {\n                updateScene(decryptedData, { scrollToContent: true });\n              }\n              break;\n            }\n            case \"SCENE_UPDATE\":\n              updateScene(decryptedData);\n              break;\n            case \"MOUSE_LOCATION\": {\n              const {\n                socketID,\n                pointerCoords,\n                button,\n                username,\n                selectedElementIds,\n              } = decryptedData.payload;\n              this.setState((state) => {\n                if (!state.collaborators.has(socketID)) {\n                  state.collaborators.set(socketID, {});\n                }\n                const user = state.collaborators.get(socketID)!;\n                user.pointer = pointerCoords;\n                user.button = button;\n                user.selectedElementIds = selectedElementIds;\n                user.username = username;\n                state.collaborators.set(socketID, user);\n                return state;\n              });\n              break;\n            }\n          }\n        },\n      );\n      this.portal.socket!.on(\"first-in-room\", () => {\n        if (this.portal.socket) {\n          this.portal.socket.off(\"first-in-room\");\n        }\n        initialize();\n      });\n      this.portal.socket!.on(\"room-user-change\", (clients: string[]) => {\n        this.setState((state) => {\n          const collaborators: typeof state.collaborators = new Map();\n          for (const socketID of clients) {\n            if (state.collaborators.has(socketID)) {\n              collaborators.set(socketID, state.collaborators.get(socketID)!);\n            } else {\n              collaborators.set(socketID, {});\n            }\n          }\n          return {\n            ...state,\n            collaborators,\n          };\n        });\n      });\n      this.portal.socket!.on(\"new-user\", async (_socketID: string) => {\n        this.broadcastScene(\"SCENE_INIT\");\n      });\n\n      this.setState({\n        isCollaborating: true,\n        isLoading: opts.showLoadingState ? true : this.state.isLoading,\n      });\n    }\n  };\n\n  private broadcastMouseLocation = (payload: {\n    pointerCoords: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"pointerCoords\"];\n    button: SocketUpdateDataSource[\"MOUSE_LOCATION\"][\"payload\"][\"button\"];\n  }) => {\n    if (this.portal.socket?.id) {\n      const data: SocketUpdateDataSource[\"MOUSE_LOCATION\"] = {\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketID: this.portal.socket.id,\n          pointerCoords: payload.pointerCoords,\n          button: payload.button || \"up\",\n          selectedElementIds: this.state.selectedElementIds,\n          username: this.state.username,\n        },\n      };\n      return this.portal._broadcastSocketData(\n        data as typeof data & { _brand: \"socketUpdateData\" },\n        true, // volatile\n      );\n    }\n  };\n\n  private broadcastScene = (sceneType: \"SCENE_INIT\" | \"SCENE_UPDATE\") => {\n    const data: SocketUpdateDataSource[typeof sceneType] = {\n      type: sceneType,\n      payload: {\n        elements: getSyncableElements(\n          globalSceneState.getElementsIncludingDeleted(),\n        ),\n      },\n    };\n    this.lastBroadcastedOrReceivedSceneVersion = Math.max(\n      this.lastBroadcastedOrReceivedSceneVersion,\n      getDrawingVersion(globalSceneState.getElementsIncludingDeleted()),\n    );\n    return this.portal._broadcastSocketData(\n      data as typeof data & { _brand: \"socketUpdateData\" },\n    );\n  };\n\n  private onSceneUpdated = () => {\n    this.setState({});\n  };\n\n  private updateCurrentCursorPosition = withBatchedUpdates(\n    (event: MouseEvent) => {\n      cursorX = event.x;\n      cursorY = event.y;\n    },\n  );\n\n  // Input handling\n\n  private onKeyDown = withBatchedUpdates((event: KeyboardEvent) => {\n    if (\n      (isWritableElement(event.target) && event.key !== KEYS.ESCAPE) ||\n      // case: using arrows to move between buttons\n      (isArrowKey(event.key) && isInputLike(event.target))\n    ) {\n      return;\n    }\n\n    if (event.key === KEYS.QUESTION_MARK) {\n      this.setState({\n        showShortcutsDialog: true,\n      });\n    }\n\n    if (event.code === \"KeyC\" && event.altKey && event.shiftKey) {\n      this.copyToClipboardAsPng();\n      event.preventDefault();\n      return;\n    }\n\n    if (this.actionManager.handleKeyDown(event)) {\n      return;\n    }\n\n    const shape = findShapeByKey(event.key);\n\n    if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      globalSceneState.replaceAllElements(\n        globalSceneState.getElementsIncludingDeleted().map((el) => {\n          if (this.state.selectedElementIds[el.id]) {\n            const update: { x?: number; y?: number } = {};\n            if (event.key === KEYS.ARROW_LEFT) {\n              update.x = el.x - step;\n            } else if (event.key === KEYS.ARROW_RIGHT) {\n              update.x = el.x + step;\n            } else if (event.key === KEYS.ARROW_UP) {\n              update.y = el.y - step;\n            } else if (event.key === KEYS.ARROW_DOWN) {\n              update.y = el.y + step;\n            }\n            return newElementWith(el, update);\n          }\n          return el;\n        }),\n      );\n      event.preventDefault();\n    } else if (event.key === KEYS.ENTER) {\n      const selectedElements = getSelectedElements(\n        globalSceneState.getElements(),\n        this.state,\n      );\n\n      if (\n        selectedElements.length === 1 &&\n        !isLinearElement(selectedElements[0])\n      ) {\n        const selectedElement = selectedElements[0];\n        const x = selectedElement.x + selectedElement.width / 2;\n        const y = selectedElement.y + selectedElement.height / 2;\n\n        this.startTextEditing({\n          x: x,\n          y: y,\n        });\n        event.preventDefault();\n        return;\n      }\n    } else if (\n      !event.ctrlKey &&\n      !event.altKey &&\n      !event.metaKey &&\n      this.state.draggingElement === null\n    ) {\n      if (shapesShortcutKeys.includes(event.key.toLowerCase())) {\n        this.selectShapeTool(shape);\n      } else if (event.key === \"q\") {\n        this.toggleLock();\n      }\n    }\n    if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n      isHoldingSpace = true;\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    }\n  });\n\n  private onKeyUp = withBatchedUpdates((event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.elementType === \"selection\") {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n        this.setState({ selectedElementIds: {} });\n      }\n      isHoldingSpace = false;\n    }\n  });\n\n  private selectShapeTool(elementType: AppState[\"elementType\"]) {\n    if (!isHoldingSpace) {\n      setCursorForShape(elementType);\n    }\n    if (isToolIcon(document.activeElement)) {\n      document.activeElement.blur();\n    }\n    if (elementType !== \"selection\") {\n      this.setState({ elementType, selectedElementIds: {} });\n    } else {\n      this.setState({ elementType });\n    }\n  }\n\n  private onGestureStart = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    gesture.initialScale = this.state.zoom;\n  });\n\n  private onGestureChange = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n\n    this.setState({\n      zoom: getNormalizedZoom(gesture.initialScale! * event.scale),\n    });\n  });\n\n  private onGestureEnd = withBatchedUpdates((event: GestureEvent) => {\n    event.preventDefault();\n    gesture.initialScale = null;\n  });\n\n  private setElements = (elements: readonly ExcalidrawElement[]) => {\n    globalSceneState.replaceAllElements(elements);\n  };\n\n  private handleTextWysiwyg(\n    element: ExcalidrawTextElement,\n    {\n      x,\n      y,\n      isExistingElement = false,\n    }: { x: number; y: number; isExistingElement?: boolean },\n  ) {\n    const resetSelection = () => {\n      this.setState({\n        draggingElement: null,\n        editingElement: null,\n      });\n    };\n\n    const deleteElement = () => {\n      globalSceneState.replaceAllElements([\n        ...globalSceneState.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id) {\n            return newElementWith(_element, { isDeleted: true });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    const updateElement = (text: string) => {\n      globalSceneState.replaceAllElements([\n        ...globalSceneState.getElementsIncludingDeleted().map((_element) => {\n          if (_element.id === element.id) {\n            return newTextElement({\n              ...(_element as ExcalidrawTextElement),\n              x: element.x,\n              y: element.y,\n              text,\n            });\n          }\n          return _element;\n        }),\n      ]);\n    };\n\n    const wysiwygElement = textWysiwyg({\n      x,\n      y,\n      initText: element.text,\n      strokeColor: element.strokeColor,\n      opacity: element.opacity,\n      font: element.font,\n      angle: element.angle,\n      textAlign: element.textAlign,\n      zoom: this.state.zoom,\n      onChange: withBatchedUpdates((text) => {\n        if (text) {\n          updateElement(text);\n        } else {\n          deleteElement();\n        }\n      }),\n      onSubmit: withBatchedUpdates((text) => {\n        updateElement(text);\n        this.setState((prevState) => ({\n          wysiwygElement: null,\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [element.id]: true,\n          },\n        }));\n        if (this.state.elementLocked) {\n          setCursorForShape(this.state.elementType);\n        }\n        history.resumeRecording();\n        resetSelection();\n      }),\n      onCancel: withBatchedUpdates(() => {\n        deleteElement();\n        if (isExistingElement) {\n          history.resumeRecording();\n        }\n        resetSelection();\n      }),\n    });\n    // deselect all other elements when inserting text\n    this.setState({ selectedElementIds: {}, wysiwygElement });\n\n    // do an initial update to re-initialize element position since we were\n    //  modifying element's x/y for sake of editor (case: syncing to remote)\n    updateElement(element.text);\n  }\n\n  private startTextEditing = ({\n    x,\n    y,\n    clientX,\n    clientY,\n    centerIfPossible = true,\n  }: {\n    x: number;\n    y: number;\n    clientX?: number;\n    clientY?: number;\n    centerIfPossible?: boolean;\n  }) => {\n    const elementAtPosition = getElementAtPosition(\n      globalSceneState.getElements(),\n      this.state,\n      x,\n      y,\n      this.state.zoom,\n    );\n\n    const element =\n      elementAtPosition && isTextElement(elementAtPosition)\n        ? elementAtPosition\n        : newTextElement({\n            x: x,\n            y: y,\n            strokeColor: this.state.currentItemStrokeColor,\n            backgroundColor: this.state.currentItemBackgroundColor,\n            fillStyle: this.state.currentItemFillStyle,\n            strokeWidth: this.state.currentItemStrokeWidth,\n            roughness: this.state.currentItemRoughness,\n            opacity: this.state.currentItemOpacity,\n            text: \"\",\n            font: this.state.currentItemFont,\n            textAlign: this.state.currentItemTextAlign,\n          });\n\n    this.setState({ editingElement: element });\n\n    let textX = clientX || x;\n    let textY = clientY || y;\n\n    let isExistingTextElement = false;\n\n    if (elementAtPosition && isTextElement(elementAtPosition)) {\n      isExistingTextElement = true;\n      const centerElementX = elementAtPosition.x + elementAtPosition.width / 2;\n      const centerElementY = elementAtPosition.y + elementAtPosition.height / 2;\n\n      const {\n        x: centerElementXInViewport,\n        y: centerElementYInViewport,\n      } = sceneCoordsToViewportCoords(\n        { sceneX: centerElementX, sceneY: centerElementY },\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n      textX = centerElementXInViewport;\n      textY = centerElementYInViewport;\n\n      // x and y will change after calling newTextElement function\n      mutateElement(element, {\n        x: centerElementX,\n        y: centerElementY,\n      });\n    } else {\n      globalSceneState.replaceAllElements([\n        ...globalSceneState.getElementsIncludingDeleted(),\n        element,\n      ]);\n\n      if (centerIfPossible) {\n        const snappedToCenterPosition = this.getTextWysiwygSnappedToCenterPosition(\n          x,\n          y,\n          this.state,\n          this.canvas,\n          window.devicePixelRatio,\n        );\n\n        if (snappedToCenterPosition) {\n          mutateElement(element, {\n            x: snappedToCenterPosition.elementCenterX,\n            y: snappedToCenterPosition.elementCenterY,\n          });\n          textX = snappedToCenterPosition.wysiwygX;\n          textY = snappedToCenterPosition.wysiwygY;\n        }\n      }\n    }\n\n    this.setState({\n      editingElement: element,\n    });\n\n    this.handleTextWysiwyg(element, {\n      x: textX,\n      y: textY,\n      isExistingElement: isExistingTextElement,\n    });\n  };\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    // case: double-clicking with arrow/line tool selected would both create\n    //  text and enter multiElement mode\n    if (this.state.multiElement) {\n      return;\n    }\n\n    resetCursor();\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n      window.devicePixelRatio,\n    );\n\n    this.startTextEditing({\n      x: x,\n      y: y,\n      clientX: event.clientX,\n      clientY: event.clientY,\n      centerIfPossible: !event.altKey,\n    });\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);\n\n    if (gesture.pointers.has(event.pointerId)) {\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY,\n      });\n    }\n\n    if (gesture.pointers.size === 2) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter!.x;\n      const deltaY = center.y - gesture.lastCenter!.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance!;\n\n      this.setState({\n        scrollX: normalizeScroll(this.state.scrollX + deltaX / this.state.zoom),\n        scrollY: normalizeScroll(this.state.scrollY + deltaY / this.state.zoom),\n        zoom: getNormalizedZoom(gesture.initialScale! * scaleFactor),\n        shouldCacheIgnoreZoom: true,\n      });\n      this.resetShouldCacheIgnoreZoomDebounced();\n    } else {\n      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n    }\n\n    if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n      return;\n    }\n    const {\n      isOverHorizontalScrollBar,\n      isOverVerticalScrollBar,\n    } = isOverScrollBars(currentScrollBars, event.clientX, event.clientY);\n    const isOverScrollBar =\n      isOverVerticalScrollBar || isOverHorizontalScrollBar;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n      }\n    }\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n      window.devicePixelRatio,\n    );\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const { x: rx, y: ry } = multiElement;\n\n      const { points, lastCommittedPoint } = multiElement;\n      const lastPoint = points[points.length - 1];\n\n      setCursorForShape(this.state.elementType);\n\n      if (lastPoint === lastCommittedPoint) {\n        // if we haven't yet created a temp point and we're beyond commit-zone\n        //  threshold, add a point\n        if (\n          distance2d(x - rx, y - ry, lastPoint[0], lastPoint[1]) >=\n          LINE_CONFIRM_THRESHOLD\n        ) {\n          mutateElement(multiElement, {\n            points: [...points, [x - rx, y - ry]],\n          });\n        } else {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          // in this branch, we're inside the commit zone, and no uncommitted\n          //  point exists. Thus do nothing (don't add/remove points).\n        }\n      } else {\n        // cursor moved inside commit zone, and there's uncommitted point,\n        //  thus remove it\n        if (\n          points.length > 2 &&\n          lastCommittedPoint &&\n          distance2d(\n            x - rx,\n            y - ry,\n            lastCommittedPoint[0],\n            lastCommittedPoint[1],\n          ) < LINE_CONFIRM_THRESHOLD\n        ) {\n          document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          mutateElement(multiElement, {\n            points: points.slice(0, -1),\n          });\n        } else {\n          if (isPathALoop(points)) {\n            document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n          }\n          // update last uncommitted point\n          mutateElement(multiElement, {\n            points: [...points.slice(0, -1), [x - rx, y - ry]],\n          });\n        }\n      }\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (\n      hasDeselectedButton ||\n      (this.state.elementType !== \"selection\" &&\n        this.state.elementType !== \"text\")\n    ) {\n      return;\n    }\n\n    const elements = globalSceneState.getElements();\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    if (selectedElements.length === 1 && !isOverScrollBar) {\n      const elementWithResizeHandler = getElementWithResizeHandler(\n        elements,\n        this.state,\n        { x, y },\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (elementWithResizeHandler && elementWithResizeHandler.resizeHandle) {\n        document.documentElement.style.cursor = getCursorForResizingElement(\n          elementWithResizeHandler,\n        );\n        return;\n      }\n    } else if (selectedElements.length > 1 && !isOverScrollBar) {\n      if (canResizeMutlipleElements(selectedElements)) {\n        const resizeHandle = getResizeHandlerFromCoords(\n          getCommonBounds(selectedElements),\n          { x, y },\n          this.state.zoom,\n          event.pointerType,\n        );\n        if (resizeHandle) {\n          document.documentElement.style.cursor = getCursorForResizingElement({\n            resizeHandle,\n          });\n          return;\n        }\n      }\n    }\n    const hitElement = getElementAtPosition(\n      elements,\n      this.state,\n      x,\n      y,\n      this.state.zoom,\n    );\n    if (this.state.elementType === \"text\") {\n      document.documentElement.style.cursor = isTextElement(hitElement)\n        ? CURSOR_TYPE.TEXT\n        : CURSOR_TYPE.CROSSHAIR;\n    } else {\n      document.documentElement.style.cursor =\n        hitElement && !isOverScrollBar ? \"move\" : \"\";\n    }\n  };\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    if (this.state.wysiwygElement && this.state.wysiwygElement.submit) {\n      this.state.wysiwygElement.submit();\n    }\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n\n    if (isPanning) {\n      return;\n    }\n\n    this.setState({\n      lastPointerDownWith: event.pointerType,\n      cursorButton: \"down\",\n    });\n    this.savePointer(event.clientX, event.clientY, \"down\");\n\n    // pan canvas on wheel button drag or space+drag\n    if (\n      gesture.pointers.size === 0 &&\n      (event.button === POINTER_BUTTON.WHEEL ||\n        (event.button === POINTER_BUTTON.MAIN && isHoldingSpace))\n    ) {\n      isPanning = true;\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n      let { clientX: lastX, clientY: lastY } = event;\n      const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n        const deltaX = lastX - event.clientX;\n        const deltaY = lastY - event.clientY;\n        lastX = event.clientX;\n        lastY = event.clientY;\n\n        this.setState({\n          scrollX: normalizeScroll(\n            this.state.scrollX - deltaX / this.state.zoom,\n          ),\n          scrollY: normalizeScroll(\n            this.state.scrollY - deltaY / this.state.zoom,\n          ),\n        });\n      });\n      const teardown = withBatchedUpdates(\n        (lastPointerUp = () => {\n          lastPointerUp = null;\n          isPanning = false;\n          if (!isHoldingSpace) {\n            setCursorForShape(this.state.elementType);\n          }\n          this.setState({\n            cursorButton: \"up\",\n          });\n          this.savePointer(event.clientX, event.clientY, \"up\");\n          window.removeEventListener(\"pointermove\", onPointerMove);\n          window.removeEventListener(\"pointerup\", teardown);\n          window.removeEventListener(\"blur\", teardown);\n        }),\n      );\n      window.addEventListener(\"blur\", teardown);\n      window.addEventListener(\"pointermove\", onPointerMove, {\n        passive: true,\n      });\n      window.addEventListener(\"pointerup\", teardown);\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n\n    // fixes pointermove causing selection of UI texts #32\n    event.preventDefault();\n    // Preventing the event above disables default behavior\n    //  of defocusing potentially focused element, which is what we\n    //  want when clicking inside the canvas.\n    if (document.activeElement instanceof HTMLElement) {\n      document.activeElement.blur();\n    }\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // Handle scrollbars dragging\n    const {\n      isOverHorizontalScrollBar,\n      isOverVerticalScrollBar,\n    } = isOverScrollBars(currentScrollBars, event.clientX, event.clientY);\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n      window.devicePixelRatio,\n    );\n    let lastX = x;\n    let lastY = y;\n\n    if (\n      (isOverHorizontalScrollBar || isOverVerticalScrollBar) &&\n      !this.state.multiElement\n    ) {\n      isDraggingScrollBar = true;\n      lastX = event.clientX;\n      lastY = event.clientY;\n      const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n        const target = event.target;\n        if (!(target instanceof HTMLElement)) {\n          return;\n        }\n\n        if (isOverHorizontalScrollBar) {\n          const x = event.clientX;\n          const dx = x - lastX;\n          this.setState({\n            scrollX: normalizeScroll(this.state.scrollX - dx / this.state.zoom),\n          });\n          lastX = x;\n          return;\n        }\n\n        if (isOverVerticalScrollBar) {\n          const y = event.clientY;\n          const dy = y - lastY;\n          this.setState({\n            scrollY: normalizeScroll(this.state.scrollY - dy / this.state.zoom),\n          });\n          lastY = y;\n        }\n      });\n\n      const onPointerUp = withBatchedUpdates(() => {\n        isDraggingScrollBar = false;\n        setCursorForShape(this.state.elementType);\n        lastPointerUp = null;\n        this.setState({\n          cursorButton: \"up\",\n        });\n        this.savePointer(event.clientX, event.clientY, \"up\");\n        window.removeEventListener(\"pointermove\", onPointerMove);\n        window.removeEventListener(\"pointerup\", onPointerUp);\n      });\n\n      lastPointerUp = onPointerUp;\n\n      window.addEventListener(\"pointermove\", onPointerMove);\n      window.addEventListener(\"pointerup\", onPointerUp);\n      return;\n    }\n\n    const originX = x;\n    const originY = y;\n\n    type ResizeTestType = ReturnType<typeof resizeTest>;\n    let resizeHandle: ResizeTestType = false;\n    const setResizeHandle = (nextResizeHandle: ResizeTestType) => {\n      resizeHandle = nextResizeHandle;\n    };\n    let isResizingElements = false;\n    let draggingOccurred = false;\n    let hitElement: ExcalidrawElement | null = null;\n    let hitElementWasAddedToSelection = false;\n    if (this.state.elementType === \"selection\") {\n      const elements = globalSceneState.getElements();\n      const selectedElements = getSelectedElements(elements, this.state);\n      if (selectedElements.length === 1) {\n        const elementWithResizeHandler = getElementWithResizeHandler(\n          elements,\n          this.state,\n          { x, y },\n          this.state.zoom,\n          event.pointerType,\n        );\n        if (elementWithResizeHandler) {\n          this.setState({\n            resizingElement: elementWithResizeHandler\n              ? elementWithResizeHandler.element\n              : null,\n          });\n          resizeHandle = elementWithResizeHandler.resizeHandle;\n          document.documentElement.style.cursor = getCursorForResizingElement(\n            elementWithResizeHandler,\n          );\n          isResizingElements = true;\n        }\n      } else if (selectedElements.length > 1) {\n        if (canResizeMutlipleElements(selectedElements)) {\n          resizeHandle = getResizeHandlerFromCoords(\n            getCommonBounds(selectedElements),\n            { x, y },\n            this.state.zoom,\n            event.pointerType,\n          );\n          if (resizeHandle) {\n            document.documentElement.style.cursor = getCursorForResizingElement(\n              {\n                resizeHandle,\n              },\n            );\n            isResizingElements = true;\n          }\n        }\n      }\n      if (!isResizingElements) {\n        hitElement = getElementAtPosition(\n          elements,\n          this.state,\n          x,\n          y,\n          this.state.zoom,\n        );\n        // clear selection if shift is not clicked\n        if (\n          !(hitElement && this.state.selectedElementIds[hitElement.id]) &&\n          !event.shiftKey\n        ) {\n          this.setState({ selectedElementIds: {} });\n        }\n\n        // If we click on something\n        if (hitElement) {\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            this.setState((prevState) => ({\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [hitElement!.id]: true,\n              },\n            }));\n            globalSceneState.replaceAllElements(\n              globalSceneState.getElementsIncludingDeleted(),\n            );\n            hitElementWasAddedToSelection = true;\n          }\n        }\n      }\n    } else {\n      this.setState({ selectedElementIds: {} });\n    }\n\n    if (this.state.elementType === \"text\") {\n      // if we're currently still editing text, clicking outside\n      //  should only finalize it, not create another (irrespective\n      //  of state.elementLocked)\n      if (this.state.editingElement?.type === \"text\") {\n        return;\n      }\n\n      const { x, y } = viewportCoordsToSceneCoords(\n        event,\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n      this.startTextEditing({\n        x: x,\n        y: y,\n        clientX: event.clientX,\n        clientY: event.clientY,\n        centerIfPossible: !event.altKey,\n      });\n\n      resetCursor();\n      if (!this.state.elementLocked) {\n        this.setState({\n          elementType: \"selection\",\n        });\n      }\n      return;\n    } else if (\n      this.state.elementType === \"arrow\" ||\n      this.state.elementType === \"line\"\n    ) {\n      if (this.state.multiElement) {\n        const { multiElement } = this.state;\n\n        // finalize if completing a loop\n        if (multiElement.type === \"line\" && isPathALoop(multiElement.points)) {\n          mutateElement(multiElement, {\n            lastCommittedPoint:\n              multiElement.points[multiElement.points.length - 1],\n          });\n          this.actionManager.executeAction(actionFinalize);\n          return;\n        }\n\n        const { x: rx, y: ry, lastCommittedPoint } = multiElement;\n\n        // clicking inside commit zone → finalize arrow\n        if (\n          multiElement.points.length > 1 &&\n          lastCommittedPoint &&\n          distance2d(\n            x - rx,\n            y - ry,\n            lastCommittedPoint[0],\n            lastCommittedPoint[1],\n          ) < LINE_CONFIRM_THRESHOLD\n        ) {\n          this.actionManager.executeAction(actionFinalize);\n          return;\n        }\n\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [multiElement.id]: true,\n          },\n        }));\n        // clicking outside commit zone → update reference for last committed\n        //  point\n        mutateElement(multiElement, {\n          lastCommittedPoint:\n            multiElement.points[multiElement.points.length - 1],\n        });\n        document.documentElement.style.cursor = CURSOR_TYPE.POINTER;\n      } else {\n        const element = newLinearElement({\n          type: this.state.elementType,\n          x: x,\n          y: y,\n          strokeColor: this.state.currentItemStrokeColor,\n          backgroundColor: this.state.currentItemBackgroundColor,\n          fillStyle: this.state.currentItemFillStyle,\n          strokeWidth: this.state.currentItemStrokeWidth,\n          roughness: this.state.currentItemRoughness,\n          opacity: this.state.currentItemOpacity,\n        });\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [element.id]: false,\n          },\n        }));\n        mutateElement(element, {\n          points: [...element.points, [0, 0]],\n        });\n        globalSceneState.replaceAllElements([\n          ...globalSceneState.getElementsIncludingDeleted(),\n          element,\n        ]);\n        this.setState({\n          draggingElement: element,\n          editingElement: element,\n        });\n      }\n    } else {\n      const element = newElement({\n        type: this.state.elementType,\n        x: x,\n        y: y,\n        strokeColor: this.state.currentItemStrokeColor,\n        backgroundColor: this.state.currentItemBackgroundColor,\n        fillStyle: this.state.currentItemFillStyle,\n        strokeWidth: this.state.currentItemStrokeWidth,\n        roughness: this.state.currentItemRoughness,\n        opacity: this.state.currentItemOpacity,\n      });\n\n      if (element.type === \"selection\") {\n        this.setState({\n          selectionElement: element,\n          draggingElement: element,\n        });\n      } else {\n        globalSceneState.replaceAllElements([\n          ...globalSceneState.getElementsIncludingDeleted(),\n          element,\n        ]);\n        this.setState({\n          multiElement: null,\n          draggingElement: element,\n          editingElement: element,\n        });\n      }\n    }\n\n    let resizeArrowFn: ResizeArrowFnType | null = null;\n    const setResizeArrrowFn = (fn: ResizeArrowFnType) => {\n      resizeArrowFn = fn;\n    };\n\n    let selectedElementWasDuplicated = false;\n\n    const onPointerMove = withBatchedUpdates((event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (isOverHorizontalScrollBar) {\n        const x = event.clientX;\n        const dx = x - lastX;\n        this.setState({\n          scrollX: normalizeScroll(this.state.scrollX - dx / this.state.zoom),\n        });\n        lastX = x;\n        return;\n      }\n\n      if (isOverVerticalScrollBar) {\n        const y = event.clientY;\n        const dy = y - lastY;\n        this.setState({\n          scrollY: normalizeScroll(this.state.scrollY - dy / this.state.zoom),\n        });\n        lastY = y;\n        return;\n      }\n\n      const { x, y } = viewportCoordsToSceneCoords(\n        event,\n        this.state,\n        this.canvas,\n        window.devicePixelRatio,\n      );\n\n      // for arrows, don't start dragging until a given threshold\n      //  to ensure we don't create a 2-point arrow by mistake when\n      //  user clicks mouse in a way that it moves a tiny bit (thus\n      //  triggering pointermove)\n      if (\n        !draggingOccurred &&\n        (this.state.elementType === \"arrow\" ||\n          this.state.elementType === \"line\")\n      ) {\n        if (distance2d(x, y, originX, originY) < DRAGGING_THRESHOLD) {\n          return;\n        }\n      }\n\n      const resized =\n        isResizingElements &&\n        resizeElements(\n          resizeHandle,\n          setResizeHandle,\n          this.state,\n          this.setAppState,\n          resizeArrowFn,\n          setResizeArrrowFn,\n          event,\n          x,\n          y,\n          lastX,\n          lastY,\n        );\n      if (resized) {\n        lastX = x;\n        lastY = y;\n        return;\n      }\n\n      if (hitElement && this.state.selectedElementIds[hitElement.id]) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        draggingOccurred = true;\n        const selectedElements = getSelectedElements(\n          globalSceneState.getElements(),\n          this.state,\n        );\n        if (selectedElements.length > 0) {\n          const { x, y } = viewportCoordsToSceneCoords(\n            event,\n            this.state,\n            this.canvas,\n            window.devicePixelRatio,\n          );\n\n          selectedElements.forEach((element) => {\n            mutateElement(element, {\n              x: element.x + x - lastX,\n              y: element.y + y - lastY,\n            });\n          });\n          lastX = x;\n          lastY = y;\n\n          // We duplicate the selected element if alt is pressed on pointer move\n          if (event.altKey && !selectedElementWasDuplicated) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            // (the origin point where the dragging started)\n\n            selectedElementWasDuplicated = true;\n\n            const nextElements = [];\n            const elementsToAppend = [];\n            for (const element of globalSceneState.getElementsIncludingDeleted()) {\n              if (\n                this.state.selectedElementIds[element.id] ||\n                // case: the state.selectedElementIds might not have been\n                //  updated yet by the time this mousemove event is fired\n                (element.id === hitElement.id && hitElementWasAddedToSelection)\n              ) {\n                const duplicatedElement = duplicateElement(element);\n                mutateElement(duplicatedElement, {\n                  x: duplicatedElement.x + (originX - lastX),\n                  y: duplicatedElement.y + (originY - lastY),\n                });\n                nextElements.push(duplicatedElement);\n                elementsToAppend.push(element);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            globalSceneState.replaceAllElements([\n              ...nextElements,\n              ...elementsToAppend,\n            ]);\n          }\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      let width = distance(originX, x);\n      let height = distance(originY, y);\n\n      if (isLinearElement(draggingElement)) {\n        draggingOccurred = true;\n        const points = draggingElement.points;\n        let dx = x - draggingElement.x;\n        let dy = y - draggingElement.y;\n\n        if (event.shiftKey && points.length === 2) {\n          ({ width: dx, height: dy } = getPerfectElementSize(\n            this.state.elementType,\n            dx,\n            dy,\n          ));\n        }\n\n        if (points.length === 1) {\n          mutateElement(draggingElement, { points: [...points, [dx, dy]] });\n        } else if (points.length > 1) {\n          mutateElement(draggingElement, {\n            points: [...points.slice(0, -1), [dx, dy]],\n          });\n        }\n      } else {\n        if (event.shiftKey) {\n          ({ width, height } = getPerfectElementSize(\n            this.state.elementType,\n            width,\n            y < originY ? -height : height,\n          ));\n\n          if (height < 0) {\n            height = -height;\n          }\n        }\n\n        mutateElement(draggingElement, {\n          x: x < originX ? originX - width : originX,\n          y: y < originY ? originY - height : originY,\n          width: width,\n          height: height,\n        });\n      }\n\n      if (this.state.elementType === \"selection\") {\n        const elements = globalSceneState.getElements();\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          this.setState({ selectedElementIds: {} });\n        }\n        const elementsWithinSelection = getElementsWithinSelection(\n          elements,\n          draggingElement,\n        );\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            ...elementsWithinSelection.reduce((map, element) => {\n              map[element.id] = true;\n              return map;\n            }, {} as any),\n          },\n        }));\n      }\n    });\n\n    const onPointerUp = withBatchedUpdates((childEvent: PointerEvent) => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n      } = this.state;\n\n      this.setState({\n        isResizing: false,\n        isRotating: false,\n        resizingElement: null,\n        selectionElement: null,\n        cursorButton: \"up\",\n        editingElement: multiElement ? this.state.editingElement : null,\n      });\n\n      this.savePointer(childEvent.clientX, childEvent.clientY, \"up\");\n\n      resizeArrowFn = null;\n      lastPointerUp = null;\n\n      window.removeEventListener(\"pointermove\", onPointerMove);\n      window.removeEventListener(\"pointerup\", onPointerUp);\n\n      if (isLinearElement(draggingElement)) {\n        if (draggingElement!.points.length > 1) {\n          history.resumeRecording();\n        }\n        if (!draggingOccurred && draggingElement && !multiElement) {\n          const { x, y } = viewportCoordsToSceneCoords(\n            childEvent,\n            this.state,\n            this.canvas,\n            window.devicePixelRatio,\n          );\n          mutateElement(draggingElement, {\n            points: [\n              ...draggingElement.points,\n              [x - draggingElement.x, y - draggingElement.y],\n            ],\n          });\n          this.setState({\n            multiElement: draggingElement,\n            editingElement: this.state.draggingElement,\n          });\n        } else if (draggingOccurred && !multiElement) {\n          if (!elementLocked) {\n            resetCursor();\n            this.setState((prevState) => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          } else {\n            this.setState((prevState) => ({\n              draggingElement: null,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        elementType !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        globalSceneState.replaceAllElements(\n          globalSceneState.getElementsIncludingDeleted().slice(0, -1),\n        );\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      normalizeDimensions(draggingElement);\n\n      if (resizingElement) {\n        history.resumeRecording();\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        globalSceneState.replaceAllElements(\n          globalSceneState\n            .getElementsIncludingDeleted()\n            .filter((el) => el.id !== resizingElement.id),\n        );\n      }\n\n      // If click occurred on already selected element\n      // it is needed to remove selection from other elements\n      // or if SHIFT or META key pressed remove selection\n      // from hitted element\n      //\n      // If click occurred and elements were dragged or some element\n      // was added to selection (on pointerdown phase) we need to keep\n      // selection unchanged\n      if (hitElement && !draggingOccurred && !hitElementWasAddedToSelection) {\n        if (childEvent.shiftKey) {\n          this.setState((prevState) => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [hitElement!.id]: false,\n            },\n          }));\n        } else {\n          this.setState((_prevState) => ({\n            selectedElementIds: { [hitElement!.id]: true },\n          }));\n        }\n      }\n\n      if (draggingElement === null) {\n        // if no element is clicked, clear the selection and redraw\n        this.setState({ selectedElementIds: {} });\n        return;\n      }\n\n      if (!elementLocked) {\n        this.setState((prevState) => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true,\n          },\n        }));\n      }\n\n      if (\n        elementType !== \"selection\" ||\n        isSomeElementSelected(globalSceneState.getElements(), this.state)\n      ) {\n        history.resumeRecording();\n      }\n\n      if (!elementLocked) {\n        resetCursor();\n        this.setState({\n          draggingElement: null,\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n        });\n      }\n    });\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(\"pointermove\", onPointerMove);\n    window.addEventListener(\"pointerup\", onPointerUp);\n  };\n\n  private handleCanvasRef = (canvas: HTMLCanvasElement) => {\n    // canvas is null when unmounting\n    if (canvas !== null) {\n      this.canvas = canvas;\n      this.rc = rough.canvas(this.canvas);\n\n      this.canvas.addEventListener(\"wheel\", this.handleWheel, {\n        passive: false,\n      });\n      this.canvas.addEventListener(\"touchstart\", this.onTapStart);\n    } else {\n      this.canvas?.removeEventListener(\"wheel\", this.handleWheel);\n      this.canvas?.removeEventListener(\"touchstart\", this.onTapStart);\n    }\n  };\n\n  private handleCanvasOnDrop = (event: React.DragEvent<HTMLCanvasElement>) => {\n    const file = event.dataTransfer?.files[0];\n    if (\n      file?.type === \"application/json\" ||\n      file?.name.endsWith(\".excalidraw\")\n    ) {\n      this.setState({ isLoading: true });\n      loadFromBlob(file)\n        .then(({ elements, appState }) =>\n          this.syncActionResult({\n            elements,\n            appState: {\n              ...(appState || this.state),\n              isLoading: false,\n            },\n            commitToHistory: false,\n          }),\n        )\n        .catch((error) => {\n          this.setState({ isLoading: false, errorMessage: error.message });\n        });\n    } else {\n      this.setState({\n        isLoading: false,\n        errorMessage: t(\"alerts.couldNotLoadInvalidFile\"),\n      });\n    }\n  };\n\n  private handleCanvasContextMenu = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    event.preventDefault();\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n      window.devicePixelRatio,\n    );\n\n    const elements = globalSceneState.getElements();\n    const element = getElementAtPosition(\n      elements,\n      this.state,\n      x,\n      y,\n      this.state.zoom,\n    );\n    if (!element) {\n      ContextMenu.push({\n        options: [\n          navigator.clipboard && {\n            label: t(\"labels.paste\"),\n            action: () => this.pasteFromClipboard(null),\n          },\n          probablySupportsClipboardBlob &&\n            elements.length > 0 && {\n              label: t(\"labels.copyAsPng\"),\n              action: this.copyToClipboardAsPng,\n            },\n          probablySupportsClipboardWriteText &&\n            elements.length > 0 && {\n              label: t(\"labels.copyAsSvg\"),\n              action: this.copyToClipboardAsSvg,\n            },\n          ...this.actionManager.getContextMenuItems((action) =>\n            this.canvasOnlyActions.includes(action.name),\n          ),\n        ],\n        top: event.clientY,\n        left: event.clientX,\n      });\n      return;\n    }\n\n    if (!this.state.selectedElementIds[element.id]) {\n      this.setState({ selectedElementIds: { [element.id]: true } });\n    }\n\n    ContextMenu.push({\n      options: [\n        navigator.clipboard && {\n          label: t(\"labels.copy\"),\n          action: this.copyAll,\n        },\n        navigator.clipboard && {\n          label: t(\"labels.paste\"),\n          action: () => this.pasteFromClipboard(null),\n        },\n        probablySupportsClipboardBlob && {\n          label: t(\"labels.copyAsPng\"),\n          action: this.copyToClipboardAsPng,\n        },\n        probablySupportsClipboardWriteText && {\n          label: t(\"labels.copyAsSvg\"),\n          action: this.copyToClipboardAsSvg,\n        },\n        ...this.actionManager.getContextMenuItems(\n          (action) => !this.canvasOnlyActions.includes(action.name),\n        ),\n      ],\n      top: event.clientY,\n      left: event.clientX,\n    });\n  };\n\n  private handleWheel = withBatchedUpdates((event: WheelEvent) => {\n    event.preventDefault();\n    const { deltaX, deltaY } = event;\n\n    // note that event.ctrlKey is necessary to handle pinch zooming\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY);\n      const MAX_STEP = 10;\n      let delta = Math.abs(deltaY);\n      if (delta > MAX_STEP) {\n        delta = MAX_STEP;\n      }\n      delta *= sign;\n      this.setState(({ zoom }) => ({\n        zoom: getNormalizedZoom(zoom - delta / 100),\n      }));\n      return;\n    }\n\n    this.setState(({ zoom, scrollX, scrollY }) => ({\n      scrollX: normalizeScroll(scrollX - deltaX / zoom),\n      scrollY: normalizeScroll(scrollY - deltaY / zoom),\n    }));\n  });\n\n  private getTextWysiwygSnappedToCenterPosition(\n    x: number,\n    y: number,\n    state: {\n      scrollX: FlooredNumber;\n      scrollY: FlooredNumber;\n      zoom: number;\n    },\n    canvas: HTMLCanvasElement | null,\n    scale: number,\n  ) {\n    const elementClickedInside = getElementContainingPosition(\n      globalSceneState.getElementsIncludingDeleted(),\n      x,\n      y,\n    );\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const { x: wysiwygX, y: wysiwygY } = sceneCoordsToViewportCoords(\n          { sceneX: elementCenterX, sceneY: elementCenterY },\n          state,\n          canvas,\n          scale,\n        );\n        return { wysiwygX, wysiwygY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (x: number, y: number, button: \"up\" | \"down\") => {\n    if (!x || !y) {\n      return;\n    }\n    const pointerCoords = viewportCoordsToSceneCoords(\n      { clientX: x, clientY: y },\n      this.state,\n      this.canvas,\n      window.devicePixelRatio,\n    );\n\n    if (isNaN(pointerCoords.x) || isNaN(pointerCoords.y)) {\n      // sometimes the pointer goes off screen\n      return;\n    }\n    this.portal.socket &&\n      this.broadcastMouseLocation({\n        pointerCoords,\n        button,\n      });\n  };\n\n  private resetShouldCacheIgnoreZoomDebounced = debounce(() => {\n    this.setState({ shouldCacheIgnoreZoom: false });\n  }, 300);\n\n  private saveDebounced = debounce(() => {\n    saveToLocalStorage(\n      globalSceneState.getElementsIncludingDeleted(),\n      this.state,\n    );\n  }, 300);\n}\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    h: {\n      elements: readonly ExcalidrawElement[];\n      state: AppState;\n      setState: React.Component<any, AppState>[\"setState\"];\n      history: SceneHistory;\n      app: InstanceType<typeof App>;\n    };\n  }\n}\n\nif (process.env.NODE_ENV === \"test\" || process.env.NODE_ENV === \"development\") {\n  window.h = {} as Window[\"h\"];\n\n  Object.defineProperties(window.h, {\n    elements: {\n      get() {\n        return globalSceneState.getElementsIncludingDeleted();\n      },\n      set(elements: ExcalidrawElement[]) {\n        return globalSceneState.replaceAllElements(elements);\n      },\n    },\n    history: {\n      get() {\n        return history;\n      },\n    },\n  });\n}\n\n// -----------------------------------------------------------------------------\n"]},"metadata":{},"sourceType":"module"}