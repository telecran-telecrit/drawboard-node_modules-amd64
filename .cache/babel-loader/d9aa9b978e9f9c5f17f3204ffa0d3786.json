{"ast":null,"code":"import { distanceBetweenPointAndSegment, isPathALoop, rotate, isPointInPolygon } from \"../math\";\nimport { getPointsOnBezierCurves } from \"roughjs/bin/geometry\";\nimport { getDiamondPoints, getElementAbsoluteCoords, getCurvePathOps } from \"./bounds\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\n\nfunction isElementDraggableFromInside(element, appState) {\n  const dragFromInside = element.backgroundColor !== \"transparent\" || appState.selectedElementIds[element.id];\n\n  if (element.type === \"line\") {\n    return dragFromInside && isPathALoop(element.points);\n  }\n\n  return dragFromInside;\n}\n\nexport function hitTest(element, appState, x, y, zoom) {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10 / zoom;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2; // reverse rotate the pointer\n\n  [x, y] = rotate(x, y, cx, cy, -element.angle);\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n    let tx = 0.707;\n    let ty = 0.707;\n    const a = Math.abs(element.width) / 2;\n    const b = Math.abs(element.height) / 2;\n    [0, 1, 2, 3].forEach(x => {\n      const xx = a * tx;\n      const yy = b * ty;\n      const ex = (a * a - b * b) * tx ** 3 / a;\n      const ey = (b * b - a * a) * ty ** 3 / b;\n      const rx = xx - ex;\n      const ry = yy - ey;\n      const qx = px - ex;\n      const qy = py - ey;\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n      tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));\n      ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    if (isElementDraggableFromInside(element, appState)) {\n      return a * tx - (px - lineThreshold) >= 0 && b * ty - (py - lineThreshold) >= 0;\n    }\n\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    if (isElementDraggableFromInside(element, appState)) {\n      return x > x1 - lineThreshold && x < x2 + lineThreshold && y > y1 - lineThreshold && y < y2 + lineThreshold;\n    } // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n\n\n    return distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n    distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n    distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n    distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    ;\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n    let [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);\n\n    if (isElementDraggableFromInside(element, appState)) {\n      // TODO: remove this when we normalize coordinates globally\n      if (topY > bottomY) {\n        [bottomY, topY] = [topY, bottomY];\n      }\n\n      if (rightX < leftX) {\n        [leftX, rightX] = [rightX, leftX];\n      }\n\n      topY -= lineThreshold;\n      bottomY += lineThreshold;\n      leftX -= lineThreshold;\n      rightX += lineThreshold; // all deltas should be < 0. Delta > 0 indicates it's on the outside side\n      //  of the line.\n      //\n      //          (topX, topY)\n      //     D  /             \\ A\n      //      /               \\\n      //  (leftX, leftY)  (rightX, rightY)\n      //    C \\               / B\n      //      \\              /\n      //      (bottomX, bottomY)\n      //\n      // https://stackoverflow.com/a/2752753/927631\n\n      return (// delta from line D\n        (leftX - topX) * (y - leftY) - (leftX - x) * (topY - leftY) <= 0 && // delta from line A\n        (topX - rightX) * (y - rightY) - (x - rightX) * (topY - rightY) <= 0 && // delta from line B\n        (rightX - bottomX) * (y - bottomY) - (x - bottomX) * (rightY - bottomY) <= 0 && // delta from line C\n        (bottomX - leftX) * (y - leftY) - (x - leftX) * (bottomY - leftY) <= 0\n      );\n    }\n\n    return distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) < lineThreshold || distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) < lineThreshold || distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) < lineThreshold || distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) < lineThreshold;\n  } else if (isLinearElement(element)) {\n    if (!getShapeForElement(element)) {\n      return false;\n    }\n\n    const shape = getShapeForElement(element);\n\n    if (x < x1 - lineThreshold || y < y1 - lineThreshold || x > x2 + lineThreshold || y > y2 + lineThreshold) {\n      return false;\n    }\n\n    const relX = x - element.x;\n    const relY = y - element.y;\n\n    if (isElementDraggableFromInside(element, appState)) {\n      const hit = shape.some(subshape => hitTestCurveInside(subshape, relX, relY, lineThreshold));\n\n      if (hit) {\n        return true;\n      }\n    } // hit thest all \"subshapes\" of the linear element\n\n\n    return shape.some(subshape => hitTestRoughShape(subshape, relX, relY, lineThreshold));\n  } else if (element.type === \"text\") {\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  }\n\n  throw new Error(`Unimplemented type ${element.type}`);\n}\n\nconst pointInBezierEquation = (p0, p1, p2, p3, [mx, my], lineThreshold) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t, idx) => Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3); // go through t in increments of 0.01\n\n\n  let t = 0;\n\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (drawable, x, y, lineThreshold) => {\n  const ops = getCurvePathOps(drawable);\n  const points = [];\n\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      if (points.length) {\n        break;\n      }\n\n      points.push([operation.data[0], operation.data[1]]);\n    } else if (operation.op === \"bcurveTo\") {\n      points.push([operation.data[0], operation.data[1]]);\n      points.push([operation.data[2], operation.data[3]]);\n      points.push([operation.data[4], operation.data[5]]);\n    }\n  }\n\n  if (points.length >= 4) {\n    const polygonPoints = getPointsOnBezierCurves(points, 50);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n\n  return false;\n};\n\nconst hitTestRoughShape = (drawable, x, y, lineThreshold) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable); // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n\n  let currentP = [0, 0];\n  return ops.some(({\n    op,\n    data\n  }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data; // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]];\n      const p2 = [data[2], data[3]];\n      const p3 = [data[4], data[5]];\n      const p0 = currentP;\n      currentP = p3; // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n\n      const retVal = pointInBezierEquation(p0, p1, p2, p3, [x, y], lineThreshold); // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n\n      return retVal;\n    } else if (op === \"lineTo\") {// TODO: Implement this\n    } else if (op === \"qcurveTo\") {// TODO: Implement this\n    }\n\n    return false;\n  });\n};","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/collision.ts"],"names":["distanceBetweenPointAndSegment","isPathALoop","rotate","isPointInPolygon","getPointsOnBezierCurves","getDiamondPoints","getElementAbsoluteCoords","getCurvePathOps","getShapeForElement","isLinearElement","isElementDraggableFromInside","element","appState","dragFromInside","backgroundColor","selectedElementIds","id","type","points","hitTest","x","y","zoom","lineThreshold","x1","y1","x2","y2","cx","cy","angle","px","Math","abs","width","py","height","tx","ty","a","b","forEach","xx","yy","ex","ey","rx","ry","qx","qy","r","hypot","q","min","max","t","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","shape","relX","relY","hit","some","subshape","hitTestCurveInside","hitTestRoughShape","console","warn","Error","pointInBezierEquation","p0","p1","p2","p3","mx","my","equation","idx","pow","diff","sqrt","drawable","ops","operation","op","length","push","data","polygonPoints","currentP","retVal"],"mappings":"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","sourcesContent":["import {\n  distanceBetweenPointAndSegment,\n  isPathALoop,\n  rotate,\n  isPointInPolygon,\n} from \"../math\";\nimport { getPointsOnBezierCurves } from \"roughjs/bin/geometry\";\n\nimport { NonDeletedExcalidrawElement } from \"./types\";\n\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getCurvePathOps,\n} from \"./bounds\";\nimport { Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\n\nfunction isElementDraggableFromInside(\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n): boolean {\n  const dragFromInside =\n    element.backgroundColor !== \"transparent\" ||\n    appState.selectedElementIds[element.id];\n  if (element.type === \"line\") {\n    return dragFromInside && isPathALoop(element.points);\n  }\n  return dragFromInside;\n}\n\nexport function hitTest(\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: number,\n): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10 / zoom;\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // reverse rotate the pointer\n  [x, y] = rotate(x, y, cx, cy, -element.angle);\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = Math.abs(element.width) / 2;\n    const b = Math.abs(element.height) / 2;\n\n    [0, 1, 2, 3].forEach((x) => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    if (isElementDraggableFromInside(element, appState)) {\n      return (\n        a * tx - (px - lineThreshold) >= 0 && b * ty - (py - lineThreshold) >= 0\n      );\n    }\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    if (isElementDraggableFromInside(element, appState)) {\n      return (\n        x > x1 - lineThreshold &&\n        x < x2 + lineThreshold &&\n        y > y1 - lineThreshold &&\n        y < y2 + lineThreshold\n      );\n    }\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n    let [\n      topX,\n      topY,\n      rightX,\n      rightY,\n      bottomX,\n      bottomY,\n      leftX,\n      leftY,\n    ] = getDiamondPoints(element);\n\n    if (isElementDraggableFromInside(element, appState)) {\n      // TODO: remove this when we normalize coordinates globally\n      if (topY > bottomY) {\n        [bottomY, topY] = [topY, bottomY];\n      }\n      if (rightX < leftX) {\n        [leftX, rightX] = [rightX, leftX];\n      }\n\n      topY -= lineThreshold;\n      bottomY += lineThreshold;\n      leftX -= lineThreshold;\n      rightX += lineThreshold;\n\n      // all deltas should be < 0. Delta > 0 indicates it's on the outside side\n      //  of the line.\n      //\n      //          (topX, topY)\n      //     D  /             \\ A\n      //      /               \\\n      //  (leftX, leftY)  (rightX, rightY)\n      //    C \\               / B\n      //      \\              /\n      //      (bottomX, bottomY)\n      //\n      // https://stackoverflow.com/a/2752753/927631\n      return (\n        // delta from line D\n        (leftX - topX) * (y - leftY) - (leftX - x) * (topY - leftY) <= 0 &&\n        // delta from line A\n        (topX - rightX) * (y - rightY) - (x - rightX) * (topY - rightY) <= 0 &&\n        // delta from line B\n        (rightX - bottomX) * (y - bottomY) -\n          (x - bottomX) * (rightY - bottomY) <=\n          0 &&\n        // delta from line C\n        (bottomX - leftX) * (y - leftY) - (x - leftX) * (bottomY - leftY) <= 0\n      );\n    }\n\n    return (\n      distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) <\n        lineThreshold\n    );\n  } else if (isLinearElement(element)) {\n    if (!getShapeForElement(element)) {\n      return false;\n    }\n    const shape = getShapeForElement(element) as Drawable[];\n\n    if (\n      x < x1 - lineThreshold ||\n      y < y1 - lineThreshold ||\n      x > x2 + lineThreshold ||\n      y > y2 + lineThreshold\n    ) {\n      return false;\n    }\n\n    const relX = x - element.x;\n    const relY = y - element.y;\n\n    if (isElementDraggableFromInside(element, appState)) {\n      const hit = shape.some((subshape) =>\n        hitTestCurveInside(subshape, relX, relY, lineThreshold),\n      );\n      if (hit) {\n        return true;\n      }\n    }\n\n    // hit thest all \"subshapes\" of the linear element\n    return shape.some((subshape) =>\n      hitTestRoughShape(subshape, relX, relY, lineThreshold),\n    );\n  } else if (element.type === \"text\") {\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  }\n  throw new Error(`Unimplemented type ${element.type}`);\n}\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Point[] = [];\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      if (points.length) {\n        break;\n      }\n      points.push([operation.data[0], operation.data[1]]);\n    } else if (operation.op === \"bcurveTo\") {\n      points.push([operation.data[0], operation.data[1]]);\n      points.push([operation.data[2], operation.data[3]]);\n      points.push([operation.data[4], operation.data[5]]);\n    }\n  }\n  if (points.length >= 4) {\n    const polygonPoints = getPointsOnBezierCurves(points as any, 50);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = (data as unknown) as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n"]},"metadata":{},"sourceType":"module"}