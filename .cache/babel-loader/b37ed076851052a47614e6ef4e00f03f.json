{"ast":null,"code":"import { SVGNS } from './core';\nimport { getPointsOnBezierCurves } from './geometry.js';\nimport { line, solidFillPolygon, patternFillPolygon, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath, curveAsBezierPoints } from './renderer.js';\nimport { randomSeed } from './math';\nconst hasSelf = typeof self !== 'undefined';\nconst NOS = 'none';\nexport class RoughGenerator {\n  constructor(config, surface) {\n    this.defaultOptions = {\n      maxRandomnessOffset: 2,\n      roughness: 1,\n      bowing: 1,\n      stroke: '#000',\n      strokeWidth: 1,\n      curveTightness: 0,\n      curveFitting: 0.95,\n      curveStepCount: 9,\n      fillStyle: 'hachure',\n      fillWeight: -1,\n      hachureAngle: -41,\n      hachureGap: -1,\n      dashOffset: -1,\n      dashGap: -1,\n      zigzagOffset: -1,\n      seed: 0,\n      roughnessGain: 1\n    };\n    this.config = config || {};\n    this.surface = surface;\n\n    if (this.config.options) {\n      this.defaultOptions = this._options(this.config.options);\n    }\n  }\n\n  static newSeed() {\n    return randomSeed();\n  }\n\n  _options(options) {\n    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n  }\n\n  _drawable(shape, sets, options) {\n    return {\n      shape,\n      sets: sets || [],\n      options: options || this.defaultOptions\n    };\n  }\n\n  line(x1, y1, x2, y2, options) {\n    const o = this._options(options);\n\n    return this._drawable('line', [line(x1, y1, x2, y2, o)], o);\n  }\n\n  rectangle(x, y, width, height, options) {\n    const o = this._options(options);\n\n    const paths = [];\n    const outline = rectangle(x, y, width, height, o);\n\n    if (o.fill) {\n      const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon(points, o));\n      } else {\n        paths.push(patternFillPolygon(points, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._drawable('rectangle', paths, o);\n  }\n\n  ellipse(x, y, width, height, options) {\n    const o = this._options(options);\n\n    const paths = [];\n    const ellipseParams = generateEllipseParams(width, height, o);\n    const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillPolygon(ellipseResponse.estimatedPoints, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(ellipseResponse.opset);\n    }\n\n    return this._drawable('ellipse', paths, o);\n  }\n\n  circle(x, y, diameter, options) {\n    const ret = this.ellipse(x, y, diameter, diameter, options);\n    ret.shape = 'circle';\n    return ret;\n  }\n\n  linearPath(points, options) {\n    const o = this._options(options);\n\n    return this._drawable('linearPath', [linearPath(points, false, o)], o);\n  }\n\n  arc(x, y, width, height, start, stop, closed = false, options) {\n    const o = this._options(options);\n\n    const paths = [];\n    const outline = arc(x, y, width, height, start, stop, closed, true, o);\n\n    if (closed && o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = arc(x, y, width, height, start, stop, true, false, o);\n        shape.type = 'fillPath';\n        paths.push(shape);\n      } else {\n        paths.push(patternFillArc(x, y, width, height, start, stop, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._drawable('arc', paths, o);\n  }\n\n  curve(points, options) {\n    const o = this._options(options);\n\n    const paths = [];\n    const outline = curve(points, o);\n\n    if (o.fill && o.fill !== NOS) {\n      const bezPoints = curveAsBezierPoints(points, o);\n\n      if (bezPoints.length >= 4) {\n        const polyPoints = getPointsOnBezierCurves(bezPoints, Math.max(50, 50 * o.roughness));\n\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon(polyPoints, o));\n        } else {\n          paths.push(patternFillPolygon(polyPoints, o));\n        }\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._drawable('curve', paths, o);\n  }\n\n  polygon(points, options) {\n    const o = this._options(options);\n\n    const paths = [];\n    const outline = linearPath(points, true, o);\n\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        paths.push(solidFillPolygon(points, o));\n      } else {\n        paths.push(patternFillPolygon(points, o));\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._drawable('polygon', paths, o);\n  }\n\n  path(d, options) {\n    const o = this._options(options);\n\n    const paths = [];\n\n    if (!d) {\n      return this._drawable('path', paths, o);\n    }\n\n    const outline = svgPath(d, o);\n\n    if (o.fill) {\n      if (o.fillStyle === 'solid') {\n        const shape = {\n          type: 'path2Dfill',\n          path: d,\n          ops: []\n        };\n        paths.push(shape);\n      } else {\n        const size = this.computePathSize(d);\n        const points = [[0, 0], [size[0], 0], [size[0], size[1]], [0, size[1]]];\n        const shape = patternFillPolygon(points, o);\n        shape.type = 'path2Dpattern';\n        shape.size = size;\n        shape.path = d;\n        paths.push(shape);\n      }\n    }\n\n    if (o.stroke !== NOS) {\n      paths.push(outline);\n    }\n\n    return this._drawable('path', paths, o);\n  }\n\n  computePathSize(d) {\n    let size = [0, 0];\n\n    if (hasSelf && self.document) {\n      try {\n        const svg = self.document.createElementNS(SVGNS, 'svg');\n        svg.setAttribute('width', '0');\n        svg.setAttribute('height', '0');\n        const pathNode = self.document.createElementNS(SVGNS, 'path');\n        pathNode.setAttribute('d', d);\n        svg.appendChild(pathNode);\n        self.document.body.appendChild(svg);\n        const bb = pathNode.getBBox();\n\n        if (bb) {\n          size[0] = bb.width || 0;\n          size[1] = bb.height || 0;\n        }\n\n        self.document.body.removeChild(svg);\n      } catch (err) {}\n    }\n\n    const canvasSize = this.getCanvasSize();\n\n    if (!(size[0] * size[1])) {\n      size = canvasSize;\n    }\n\n    return size;\n  }\n\n  getCanvasSize() {\n    const val = w => {\n      if (w && typeof w === 'object') {\n        if (w.baseVal && w.baseVal.value) {\n          return w.baseVal.value;\n        }\n      }\n\n      return w || 100;\n    };\n\n    if (this.surface) {\n      return [val(this.surface.width), val(this.surface.height)];\n    }\n\n    return [100, 100];\n  }\n\n  opsToPath(drawing) {\n    let path = '';\n\n    for (const item of drawing.ops) {\n      const data = item.data;\n\n      switch (item.op) {\n        case 'move':\n          path += `M${data[0]} ${data[1]} `;\n          break;\n\n        case 'bcurveTo':\n          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n          break;\n\n        case 'qcurveTo':\n          path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n          break;\n\n        case 'lineTo':\n          path += `L${data[0]} ${data[1]} `;\n          break;\n      }\n    }\n\n    return path.trim();\n  }\n\n  toPaths(drawable) {\n    const sets = drawable.sets || [];\n    const o = drawable.options || this.defaultOptions;\n    const paths = [];\n\n    for (const drawing of sets) {\n      let path = null;\n\n      switch (drawing.type) {\n        case 'path':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: o.stroke,\n            strokeWidth: o.strokeWidth,\n            fill: NOS\n          };\n          break;\n\n        case 'fillPath':\n          path = {\n            d: this.opsToPath(drawing),\n            stroke: NOS,\n            strokeWidth: 0,\n            fill: o.fill || NOS\n          };\n          break;\n\n        case 'fillSketch':\n          path = this.fillSketch(drawing, o);\n          break;\n\n        case 'path2Dfill':\n          path = {\n            d: drawing.path || '',\n            stroke: NOS,\n            strokeWidth: 0,\n            fill: o.fill || NOS\n          };\n          break;\n\n        case 'path2Dpattern':\n          {\n            const size = drawing.size;\n            const pattern = {\n              x: 0,\n              y: 0,\n              width: 1,\n              height: 1,\n              viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n              patternUnits: 'objectBoundingBox',\n              path: this.fillSketch(drawing, o)\n            };\n            path = {\n              d: drawing.path,\n              stroke: NOS,\n              strokeWidth: 0,\n              pattern: pattern\n            };\n            break;\n          }\n      }\n\n      if (path) {\n        paths.push(path);\n      }\n    }\n\n    return paths;\n  }\n\n  fillSketch(drawing, o) {\n    let fweight = o.fillWeight;\n\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n\n    return {\n      d: this.opsToPath(drawing),\n      stroke: o.fill || NOS,\n      strokeWidth: fweight,\n      fill: NOS\n    };\n  }\n\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/generator.js"],"names":["SVGNS","getPointsOnBezierCurves","line","solidFillPolygon","patternFillPolygon","rectangle","ellipseWithParams","generateEllipseParams","linearPath","arc","patternFillArc","curve","svgPath","curveAsBezierPoints","randomSeed","hasSelf","self","NOS","RoughGenerator","constructor","config","surface","defaultOptions","maxRandomnessOffset","roughness","bowing","stroke","strokeWidth","curveTightness","curveFitting","curveStepCount","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","seed","roughnessGain","options","_options","newSeed","Object","assign","_drawable","shape","sets","x1","y1","x2","y2","o","x","y","width","height","paths","outline","fill","points","push","ellipse","ellipseParams","ellipseResponse","opset","type","estimatedPoints","circle","diameter","ret","start","stop","closed","bezPoints","length","polyPoints","Math","max","polygon","path","d","ops","size","computePathSize","document","svg","createElementNS","setAttribute","pathNode","appendChild","body","bb","getBBox","removeChild","err","canvasSize","getCanvasSize","val","w","baseVal","value","opsToPath","drawing","item","data","op","trim","toPaths","drawable","fillSketch","pattern","viewBox","round","patternUnits","fweight"],"mappings":"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","sourcesContent":["import { SVGNS } from './core';\nimport { getPointsOnBezierCurves } from './geometry.js';\nimport { line, solidFillPolygon, patternFillPolygon, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath, curveAsBezierPoints } from './renderer.js';\nimport { randomSeed } from './math';\nconst hasSelf = typeof self !== 'undefined';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config, surface) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            roughnessGain: 1\n        };\n        this.config = config || {};\n        this.surface = surface;\n        if (this.config.options) {\n            this.defaultOptions = this._options(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _options(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _drawable(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygon(ellipseResponse.estimatedPoints, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._drawable('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = curve(points, o);\n        if (o.fill && o.fill !== NOS) {\n            const bezPoints = curveAsBezierPoints(points, o);\n            if (bezPoints.length >= 4) {\n                const polyPoints = getPointsOnBezierCurves(bezPoints, Math.max(50, 50 * o.roughness));\n                if (o.fillStyle === 'solid') {\n                    paths.push(solidFillPolygon(polyPoints, o));\n                }\n                else {\n                    paths.push(patternFillPolygon(polyPoints, o));\n                }\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        const outline = svgPath(d, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('path', paths, o);\n    }\n    computePathSize(d) {\n        let size = [0, 0];\n        if (hasSelf && self.document) {\n            try {\n                const svg = self.document.createElementNS(SVGNS, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(SVGNS, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                self.document.body.appendChild(svg);\n                const bb = pathNode.getBBox();\n                if (bb) {\n                    size[0] = bb.width || 0;\n                    size[1] = bb.height || 0;\n                }\n                self.document.body.removeChild(svg);\n            }\n            catch (err) { }\n        }\n        const canvasSize = this.getCanvasSize();\n        if (!(size[0] * size[1])) {\n            size = canvasSize;\n        }\n        return size;\n    }\n    getCanvasSize() {\n        const val = (w) => {\n            if (w && typeof w === 'object') {\n                if (w.baseVal && w.baseVal.value) {\n                    return w.baseVal.value;\n                }\n            }\n            return w || 100;\n        };\n        if (this.surface) {\n            return [val(this.surface.width), val(this.surface.height)];\n        }\n        return [100, 100];\n    }\n    opsToPath(drawing) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'qcurveTo':\n                    path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n                case 'path2Dfill':\n                    path = {\n                        d: drawing.path || '',\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS\n                    };\n                    break;\n                case 'path2Dpattern': {\n                    const size = drawing.size;\n                    const pattern = {\n                        x: 0, y: 0, width: 1, height: 1,\n                        viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n                        patternUnits: 'objectBoundingBox',\n                        path: this.fillSketch(drawing, o)\n                    };\n                    path = {\n                        d: drawing.path,\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        pattern: pattern\n                    };\n                    break;\n                }\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}