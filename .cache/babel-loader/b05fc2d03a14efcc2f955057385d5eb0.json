{"ast":null,"code":"import _slicedToArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _objectSpread from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/pro/Solutions/drawboard-light/src/components/App.tsx\";\nimport React from \"react\";\nimport socketIOClient from \"socket.io-client\";\nimport rough from \"roughjs/bin/rough\";\nimport { newElement, newTextElement, duplicateElement, normalizeResizeHandle, isInvisiblySmallElement, isTextElement, textWysiwyg, getCommonBounds, getCursorForResizingElement, getPerfectElementSize, normalizeDimensions } from \"../element\";\nimport { deleteSelectedElements, getElementsWithinSelection, isOverScrollBars, getElementAtPosition, createScene, getElementContainingPosition, getNormalizedZoom, getSelectedElements, isSomeElementSelected } from \"../scene\";\nimport { decryptAESGEM, encryptAESGEM, saveToLocalStorage, loadScene, loadFromBlob, SOCKET_SERVER } from \"../data\";\nimport { restore } from \"../data/restore\";\nimport { renderScene } from \"../renderer\";\nimport { isWritableElement, isInputLike, isToolIcon, debounce, distance, distance2d, resetCursor, viewportCoordsToSceneCoords, sceneCoordsToViewportCoords } from \"../utils\";\nimport { KEYS, isArrowKey } from \"../keys\";\nimport { findShapeByKey, shapesShortcutKeys } from \"../shapes\";\nimport { createHistory } from \"../history\";\nimport ContextMenu from \"./ContextMenu\";\nimport { getElementWithResizeHandler } from \"../element/resizeTest\";\nimport { ActionManager } from \"../actions/manager\";\nimport \"../actions\";\nimport { actions } from \"../actions/register\";\nimport { getDefaultAppState } from \"../appState\";\nimport { t, getLanguage } from \"../i18n\";\nimport { copyToAppClipboard, getClipboardContent } from \"../clipboard\";\nimport { normalizeScroll } from \"../scene\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport { createUndoAction, createRedoAction } from \"../actions/actionHistory\";\nimport { CURSOR_TYPE, ELEMENT_SHIFT_TRANSLATE_AMOUNT, ELEMENT_TRANSLATE_AMOUNT, POINTER_BUTTON, DRAGGING_THRESHOLD, TEXT_TO_CENTER_SNAP_THRESHOLD } from \"../constants\";\nimport { LayerUI } from \"./LayerUI\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { generateCollaborationLink, getCollaborationLinkData } from \"../data\"; // -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\nif (process.env.NODE_ENV === \"test\") {\n  window.__TEST__ = {};\n}\n\nwindow.generateCollaborationLink = generateCollaborationLink; // -----------------------------------------------------------------------------\n\nvar _createScene = createScene(),\n    elements = _createScene.elements;\n\nif (process.env.NODE_ENV === \"test\") {\n  Object.defineProperty(window.__TEST__, \"elements\", {\n    get: function get() {\n      return elements;\n    }\n  });\n}\n\nvar _createHistory = createHistory(),\n    history = _createHistory.history;\n\nvar cursorX = 0;\nvar cursorY = 0;\nvar isHoldingSpace = false;\nvar isPanning = false;\nvar isDraggingScrollBar = false;\nvar currentScrollBars = {\n  horizontal: null,\n  vertical: null\n};\nvar _lastPointerUp = null;\nvar gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null\n};\n\nfunction setCursorForShape(shape) {\n  if (shape === \"selection\") {\n    resetCursor();\n  } else {\n    document.documentElement.style.cursor = shape === \"text\" ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR;\n  }\n}\n\nexport var App =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(App, _React$Component);\n\n  // we don't want the socket to emit any updates until it is fully initalized\n  function App(props) {\n    var _this;\n\n    _classCallCheck(this, App);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this, props));\n    _this.canvas = null;\n    _this.rc = null;\n    _this.socket = null;\n    _this.socketInitialized = false;\n    _this.roomID = null;\n    _this.roomKey = null;\n    _this.actionManager = void 0;\n    _this.canvasOnlyActions = [\"selectAll\"];\n\n    _this.syncActionResult = function (res) {\n      var commitToHistory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (_this.unmounted) {\n        return;\n      }\n\n      if (res.elements) {\n        elements = res.elements;\n\n        if (commitToHistory) {\n          history.resumeRecording();\n        }\n\n        _this.setState({});\n      }\n\n      if (res.appState) {\n        if (commitToHistory) {\n          history.resumeRecording();\n        }\n\n        _this.setState(_objectSpread({}, res.appState));\n      }\n    };\n\n    _this.onCut = function (event) {\n      if (isWritableElement(event.target)) {\n        return;\n      }\n\n      copyToAppClipboard(elements, _this.state);\n\n      var _deleteSelectedElemen = deleteSelectedElements(elements, _this.state),\n          nextElements = _deleteSelectedElemen.elements,\n          appState = _deleteSelectedElemen.appState;\n\n      elements = nextElements;\n      history.resumeRecording();\n\n      _this.setState(_objectSpread({}, appState));\n\n      event.preventDefault();\n    };\n\n    _this.onCopy = function (event) {\n      if (isWritableElement(event.target)) {\n        return;\n      }\n\n      copyToAppClipboard(elements, _this.state);\n      event.preventDefault();\n    };\n\n    _this.onUnload = function () {\n      isHoldingSpace = false;\n\n      _this.saveDebounced();\n\n      _this.saveDebounced.flush();\n    };\n\n    _this.disableEvent = function (event) {\n      event.preventDefault();\n    };\n\n    _this.initializeSocketClient = function () {\n      if (_this.socket) {\n        return;\n      }\n\n      var roomMatch = getCollaborationLinkData(window.location.href);\n\n      if (roomMatch) {\n        _this.socket = socketIOClient(SOCKET_SERVER);\n        _this.roomID = roomMatch[1];\n        _this.roomKey = roomMatch[2];\n\n        _this.socket.on(\"init-room\", function () {\n          _this.socket && _this.socket.emit(\"join-room\", _this.roomID);\n        });\n\n        _this.socket.on(\"client-broadcast\",\n        /*#__PURE__*/\n        function () {\n          var _ref = _asyncToGenerator(\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee(encryptedData, iv) {\n            var decryptedData, _decryptedData$payloa, sceneElements, sceneAppState, restoredState, _decryptedData$payloa2, socketID, pointerCoords;\n\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (_this.roomKey) {\n                      _context.next = 2;\n                      break;\n                    }\n\n                    return _context.abrupt(\"return\");\n\n                  case 2:\n                    _context.next = 4;\n                    return decryptAESGEM(encryptedData, _this.roomKey, iv);\n\n                  case 4:\n                    decryptedData = _context.sent;\n                    _context.t0 = decryptedData.type;\n                    _context.next = _context.t0 === \"INVALID_RESPONSE\" ? 8 : _context.t0 === \"SCENE_UPDATE\" ? 9 : _context.t0 === \"MOUSE_LOCATION\" ? 15 : 18;\n                    break;\n\n                  case 8:\n                    return _context.abrupt(\"return\");\n\n                  case 9:\n                    _decryptedData$payloa = decryptedData.payload, sceneElements = _decryptedData$payloa.elements, sceneAppState = _decryptedData$payloa.appState;\n                    restoredState = restore(sceneElements || [], sceneAppState || getDefaultAppState(), {\n                      scrollToContent: true\n                    });\n                    elements = restoredState.elements;\n\n                    _this.setState({});\n\n                    if (_this.socketInitialized === false) {\n                      _this.socketInitialized = true;\n                    }\n\n                    return _context.abrupt(\"break\", 18);\n\n                  case 15:\n                    _decryptedData$payloa2 = decryptedData.payload, socketID = _decryptedData$payloa2.socketID, pointerCoords = _decryptedData$payloa2.pointerCoords;\n\n                    _this.setState({\n                      remotePointers: _objectSpread({}, _this.state.remotePointers, _defineProperty({}, socketID, pointerCoords))\n                    });\n\n                    return _context.abrupt(\"break\", 18);\n\n                  case 18:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n\n        _this.socket.on(\"first-in-room\", function () {\n          if (_this.socket) {\n            _this.socket.off(\"first-in-room\");\n          }\n\n          _this.socketInitialized = true;\n        });\n\n        _this.socket.on(\"room-user-count\", function (collaboratorCount) {\n          _this.setState({\n            collaboratorCount: collaboratorCount\n          });\n        });\n\n        _this.socket.on(\"new-user\",\n        /*#__PURE__*/\n        function () {\n          var _ref2 = _asyncToGenerator(\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee2(socketID) {\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _this.broadcastSocketData({\n                      type: \"SCENE_UPDATE\",\n                      payload: {\n                        elements: elements,\n                        appState: _this.state\n                      }\n                    });\n\n                  case 1:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function (_x3) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      }\n    };\n\n    _this.broadcastSocketData =\n    /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(data) {\n        var json, encoded, encrypted;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(_this.socketInitialized && _this.socket && _this.roomID && _this.roomKey)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                json = JSON.stringify(data);\n                encoded = new TextEncoder().encode(json);\n                _context3.next = 5;\n                return encryptAESGEM(encoded, _this.roomKey);\n\n              case 5:\n                encrypted = _context3.sent;\n\n                _this.socket.emit(\"server-broadcast\", _this.roomID, encrypted.data, encrypted.iv);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    _this.unmounted = false;\n    _this.state = getDefaultAppState();\n\n    _this.onResize = function () {\n      elements.forEach(function (element) {\n        return invalidateShapeForElement(element);\n      });\n\n      _this.setState({});\n    };\n\n    _this.updateCurrentCursorPosition = function (event) {\n      cursorX = event.x;\n      cursorY = event.y;\n    };\n\n    _this.onKeyDown = function (event) {\n      if (isWritableElement(event.target) && event.key !== KEYS.ESCAPE || // case: using arrows to move between buttons\n      isArrowKey(event.key) && isInputLike(event.target)) {\n        return;\n      }\n\n      if (_this.actionManager.handleKeyDown(event)) {\n        return;\n      }\n\n      var shape = findShapeByKey(event.key);\n\n      if (isArrowKey(event.key)) {\n        var step = event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT;\n        elements = elements.map(function (el) {\n          if (_this.state.selectedElementIds[el.id]) {\n            var element = _objectSpread({}, el);\n\n            if (event.key === KEYS.ARROW_LEFT) {\n              element.x -= step;\n            } else if (event.key === KEYS.ARROW_RIGHT) {\n              element.x += step;\n            } else if (event.key === KEYS.ARROW_UP) {\n              element.y -= step;\n            } else if (event.key === KEYS.ARROW_DOWN) {\n              element.y += step;\n            }\n\n            return element;\n          }\n\n          return el;\n        });\n\n        _this.setState({});\n\n        event.preventDefault();\n      } else if (shapesShortcutKeys.includes(event.key.toLowerCase()) && !event.ctrlKey && !event.altKey && !event.metaKey && _this.state.draggingElement === null) {\n        _this.selectShapeTool(shape);\n      } else if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n        isHoldingSpace = true;\n        document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n      }\n    };\n\n    _this.onKeyUp = function (event) {\n      if (event.key === KEYS.SPACE) {\n        if (_this.state.elementType === \"selection\") {\n          resetCursor();\n        } else {\n          document.documentElement.style.cursor = _this.state.elementType === \"text\" ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR;\n\n          _this.setState({\n            selectedElementIds: {}\n          });\n        }\n\n        isHoldingSpace = false;\n      }\n    };\n\n    _this.copyToAppClipboard = function () {\n      copyToAppClipboard(elements, _this.state);\n    };\n\n    _this.pasteFromClipboard =\n    /*#__PURE__*/\n    function () {\n      var _ref4 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(event) {\n        var target, elementUnderCursor, data, _viewportCoordsToScen, x, y, element;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // #686\n                target = document.activeElement;\n                elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n\n                if (!( // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n                //  thus these checks don't make sense\n                !event || elementUnderCursor instanceof HTMLCanvasElement && !isWritableElement(target))) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                _context4.next = 5;\n                return getClipboardContent(event);\n\n              case 5:\n                data = _context4.sent;\n\n                if (data.elements) {\n                  _this.addElementsFromPaste(data.elements);\n                } else if (data.text) {\n                  _viewportCoordsToScen = viewportCoordsToSceneCoords({\n                    clientX: cursorX,\n                    clientY: cursorY\n                  }, _this.state, _this.canvas), x = _viewportCoordsToScen.x, y = _viewportCoordsToScen.y;\n                  element = newTextElement(newElement(\"text\", x, y, _this.state.currentItemStrokeColor, _this.state.currentItemBackgroundColor, _this.state.currentItemFillStyle, _this.state.currentItemStrokeWidth, _this.state.currentItemRoughness, _this.state.currentItemOpacity), data.text, _this.state.currentItemFont);\n                  elements = [].concat(_toConsumableArray(elements), [element]);\n\n                  _this.setState({\n                    selectedElementIds: _defineProperty({}, element.id, true)\n                  });\n\n                  history.resumeRecording();\n                }\n\n                _this.selectShapeTool(\"selection\");\n\n                event === null || event === void 0 ? void 0 : event.preventDefault();\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x5) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n\n    _this.onGestureStart = function (event) {\n      event.preventDefault();\n      gesture.initialScale = _this.state.zoom;\n    };\n\n    _this.onGestureChange = function (event) {\n      event.preventDefault();\n\n      _this.setState({\n        zoom: getNormalizedZoom(gesture.initialScale * event.scale)\n      });\n    };\n\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      gesture.initialScale = null;\n    };\n\n    _this.setAppState = function (obj) {\n      _this.setState(obj);\n    };\n\n    _this.setElements = function (elements_) {\n      elements = elements_;\n\n      _this.setState({});\n    };\n\n    _this.removePointer = function (event) {\n      gesture.pointers.delete(event.pointerId);\n    };\n\n    _this.handleCanvasDoubleClick = function (event) {\n      resetCursor();\n\n      var _viewportCoordsToScen2 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n          x = _viewportCoordsToScen2.x,\n          y = _viewportCoordsToScen2.y;\n\n      var elementAtPosition = getElementAtPosition(elements, _this.state, x, y, _this.state.zoom);\n      var element = elementAtPosition && isTextElement(elementAtPosition) ? elementAtPosition : newTextElement(newElement(\"text\", x, y, _this.state.currentItemStrokeColor, _this.state.currentItemBackgroundColor, _this.state.currentItemFillStyle, _this.state.currentItemStrokeWidth, _this.state.currentItemRoughness, _this.state.currentItemOpacity), \"\", // default text\n      _this.state.currentItemFont // default font\n      );\n\n      _this.setState({\n        editingElement: element\n      });\n\n      var textX = event.clientX;\n      var textY = event.clientY;\n\n      if (elementAtPosition && isTextElement(elementAtPosition)) {\n        elements = elements.filter(function (element) {\n          return element.id !== elementAtPosition.id;\n        });\n\n        _this.setState({});\n\n        var centerElementX = elementAtPosition.x + elementAtPosition.width / 2;\n        var centerElementY = elementAtPosition.y + elementAtPosition.height / 2;\n\n        var _sceneCoordsToViewpor = sceneCoordsToViewportCoords({\n          sceneX: centerElementX,\n          sceneY: centerElementY\n        }, _this.state, _this.canvas),\n            centerElementXInViewport = _sceneCoordsToViewpor.x,\n            centerElementYInViewport = _sceneCoordsToViewpor.y;\n\n        textX = centerElementXInViewport;\n        textY = centerElementYInViewport; // x and y will change after calling newTextElement function\n\n        element.x = centerElementX;\n        element.y = centerElementY;\n      } else if (!event.altKey) {\n        var snappedToCenterPosition = _this.getTextWysiwygSnappedToCenterPosition(x, y);\n\n        if (snappedToCenterPosition) {\n          element.x = snappedToCenterPosition.elementCenterX;\n          element.y = snappedToCenterPosition.elementCenterY;\n          textX = snappedToCenterPosition.wysiwygX;\n          textY = snappedToCenterPosition.wysiwygY;\n        }\n      }\n\n      var resetSelection = function resetSelection() {\n        _this.setState({\n          draggingElement: null,\n          editingElement: null\n        });\n      };\n\n      textWysiwyg({\n        initText: element.text,\n        x: textX,\n        y: textY,\n        strokeColor: element.strokeColor,\n        font: element.font,\n        opacity: _this.state.currentItemOpacity,\n        zoom: _this.state.zoom,\n        onSubmit: function onSubmit(text) {\n          if (text) {\n            elements = [].concat(_toConsumableArray(elements), [_objectSpread({}, newTextElement(element, text, element.font))]);\n          }\n\n          _this.setState(function (prevState) {\n            return {\n              selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, element.id, true))\n            };\n          });\n\n          history.resumeRecording();\n          resetSelection();\n        },\n        onCancel: function onCancel() {\n          resetSelection();\n        }\n      });\n    };\n\n    _this.handleCanvasPointerMove = function (event) {\n      var pointerCoords = viewportCoordsToSceneCoords(event, _this.state, _this.canvas);\n\n      _this.savePointer(pointerCoords);\n\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY\n      });\n\n      if (gesture.pointers.size === 2) {\n        var center = getCenter(gesture.pointers);\n\n        var _deltaX = center.x - gesture.lastCenter.x;\n\n        var _deltaY = center.y - gesture.lastCenter.y;\n\n        gesture.lastCenter = center;\n\n        var _distance = getDistance(Array.from(gesture.pointers.values()));\n\n        var scaleFactor = _distance / gesture.initialDistance;\n\n        _this.setState({\n          scrollX: normalizeScroll(_this.state.scrollX + _deltaX / _this.state.zoom),\n          scrollY: normalizeScroll(_this.state.scrollY + _deltaY / _this.state.zoom),\n          zoom: getNormalizedZoom(gesture.initialScale * scaleFactor)\n        });\n      } else {\n        gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n      }\n\n      if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n        return;\n      }\n\n      var _isOverScrollBars = isOverScrollBars(currentScrollBars, event.clientX, event.clientY),\n          isOverHorizontalScrollBar = _isOverScrollBars.isOverHorizontalScrollBar,\n          isOverVerticalScrollBar = _isOverScrollBars.isOverVerticalScrollBar;\n\n      var isOverScrollBar = isOverVerticalScrollBar || isOverHorizontalScrollBar;\n\n      if (!_this.state.draggingElement && !_this.state.multiElement) {\n        if (isOverScrollBar) {\n          resetCursor();\n        } else {\n          setCursorForShape(_this.state.elementType);\n        }\n      }\n\n      var _viewportCoordsToScen3 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n          x = _viewportCoordsToScen3.x,\n          y = _viewportCoordsToScen3.y;\n\n      if (_this.state.multiElement) {\n        var multiElement = _this.state.multiElement;\n        var originX = multiElement.x;\n        var originY = multiElement.y;\n        var points = multiElement.points;\n        var pnt = points[points.length - 1];\n        pnt[0] = x - originX;\n        pnt[1] = y - originY;\n        invalidateShapeForElement(multiElement);\n\n        _this.setState({});\n\n        return;\n      }\n\n      var hasDeselectedButton = Boolean(event.buttons);\n\n      if (hasDeselectedButton || _this.state.elementType !== \"selection\") {\n        return;\n      }\n\n      var selectedElements = getSelectedElements(elements, _this.state);\n\n      if (selectedElements.length === 1 && !isOverScrollBar) {\n        var resizeElement = getElementWithResizeHandler(elements, _this.state, {\n          x: x,\n          y: y\n        }, _this.state.zoom, event.pointerType);\n\n        if (resizeElement && resizeElement.resizeHandle) {\n          document.documentElement.style.cursor = getCursorForResizingElement(resizeElement);\n          return;\n        }\n      }\n\n      var hitElement = getElementAtPosition(elements, _this.state, x, y, _this.state.zoom);\n      document.documentElement.style.cursor = hitElement && !isOverScrollBar ? \"move\" : \"\";\n    };\n\n    _this.handleCanvasPointerDown = function (event) {\n      if (_lastPointerUp !== null) {\n        // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n        // this can happen when a contextual menu or alert is triggered. In order to avoid\n        // being in a weird state, we clean up on the next pointerdown\n        _lastPointerUp(event);\n      }\n\n      if (isPanning) {\n        return;\n      }\n\n      _this.setState({\n        lastPointerDownWith: event.pointerType\n      }); // pan canvas on wheel button drag or space+drag\n\n\n      if (gesture.pointers.size === 0 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace)) {\n        isPanning = true;\n        document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n        var _lastX = event.clientX,\n            _lastY = event.clientY;\n\n        var _onPointerMove = function _onPointerMove(event) {\n          var deltaX = _lastX - event.clientX;\n          var deltaY = _lastY - event.clientY;\n          _lastX = event.clientX;\n          _lastY = event.clientY;\n\n          _this.setState({\n            scrollX: normalizeScroll(_this.state.scrollX - deltaX / _this.state.zoom),\n            scrollY: normalizeScroll(_this.state.scrollY - deltaY / _this.state.zoom)\n          });\n        };\n\n        var teardown = _lastPointerUp = function lastPointerUp() {\n          _lastPointerUp = null;\n          isPanning = false;\n\n          if (!isHoldingSpace) {\n            setCursorForShape(_this.state.elementType);\n          }\n\n          window.removeEventListener(\"pointermove\", _onPointerMove);\n          window.removeEventListener(\"pointerup\", teardown);\n          window.removeEventListener(\"blur\", teardown);\n        };\n\n        window.addEventListener(\"blur\", teardown);\n        window.addEventListener(\"pointermove\", _onPointerMove, {\n          passive: true\n        });\n        window.addEventListener(\"pointerup\", teardown);\n        return;\n      } // only handle left mouse button or touch\n\n\n      if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH) {\n        return;\n      }\n\n      gesture.pointers.set(event.pointerId, {\n        x: event.clientX,\n        y: event.clientY\n      });\n\n      if (gesture.pointers.size === 2) {\n        gesture.lastCenter = getCenter(gesture.pointers);\n        gesture.initialScale = _this.state.zoom;\n        gesture.initialDistance = getDistance(Array.from(gesture.pointers.values()));\n      } // fixes pointermove causing selection of UI texts #32\n\n\n      event.preventDefault(); // Preventing the event above disables default behavior\n      //  of defocusing potentially focused element, which is what we\n      //  want when clicking inside the canvas.\n\n      if (document.activeElement instanceof HTMLElement) {\n        document.activeElement.blur();\n      } // don't select while panning\n\n\n      if (gesture.pointers.size > 1) {\n        return;\n      } // Handle scrollbars dragging\n\n\n      var _isOverScrollBars2 = isOverScrollBars(currentScrollBars, event.clientX, event.clientY),\n          isOverHorizontalScrollBar = _isOverScrollBars2.isOverHorizontalScrollBar,\n          isOverVerticalScrollBar = _isOverScrollBars2.isOverVerticalScrollBar;\n\n      var _viewportCoordsToScen4 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n          x = _viewportCoordsToScen4.x,\n          y = _viewportCoordsToScen4.y;\n\n      var lastX = x;\n      var lastY = y;\n\n      if ((isOverHorizontalScrollBar || isOverVerticalScrollBar) && !_this.state.multiElement) {\n        isDraggingScrollBar = true;\n        lastX = event.clientX;\n        lastY = event.clientY;\n\n        var _onPointerMove2 = function _onPointerMove2(event) {\n          var target = event.target;\n\n          if (!(target instanceof HTMLElement)) {\n            return;\n          }\n\n          if (isOverHorizontalScrollBar) {\n            var _x6 = event.clientX;\n            var dx = _x6 - lastX;\n\n            _this.setState({\n              scrollX: normalizeScroll(_this.state.scrollX - dx / _this.state.zoom)\n            });\n\n            lastX = _x6;\n            return;\n          }\n\n          if (isOverVerticalScrollBar) {\n            var _y = event.clientY;\n            var dy = _y - lastY;\n\n            _this.setState({\n              scrollY: normalizeScroll(_this.state.scrollY - dy / _this.state.zoom)\n            });\n\n            lastY = _y;\n          }\n        };\n\n        var _onPointerUp = function _onPointerUp() {\n          isDraggingScrollBar = false;\n          setCursorForShape(_this.state.elementType);\n          _lastPointerUp = null;\n          window.removeEventListener(\"pointermove\", _onPointerMove2);\n          window.removeEventListener(\"pointerup\", _onPointerUp);\n        };\n\n        _lastPointerUp = _onPointerUp;\n        window.addEventListener(\"pointermove\", _onPointerMove2);\n        window.addEventListener(\"pointerup\", _onPointerUp);\n        return;\n      }\n\n      var originX = x;\n      var originY = y;\n      var element = newElement(_this.state.elementType, x, y, _this.state.currentItemStrokeColor, _this.state.currentItemBackgroundColor, _this.state.currentItemFillStyle, _this.state.currentItemStrokeWidth, _this.state.currentItemRoughness, _this.state.currentItemOpacity);\n\n      if (isTextElement(element)) {\n        element = newTextElement(element, \"\", _this.state.currentItemFont);\n      }\n\n      var resizeHandle = false;\n      var isResizingElements = false;\n      var draggingOccurred = false;\n      var hitElement = null;\n      var elementIsAddedToSelection = false;\n\n      if (_this.state.elementType === \"selection\") {\n        var resizeElement = getElementWithResizeHandler(elements, _this.state, {\n          x: x,\n          y: y\n        }, _this.state.zoom, event.pointerType);\n        var selectedElements = getSelectedElements(elements, _this.state);\n\n        if (selectedElements.length === 1 && resizeElement) {\n          _this.setState({\n            resizingElement: resizeElement ? resizeElement.element : null\n          });\n\n          resizeHandle = resizeElement.resizeHandle;\n          document.documentElement.style.cursor = getCursorForResizingElement(resizeElement);\n          isResizingElements = true;\n        } else {\n          hitElement = getElementAtPosition(elements, _this.state, x, y, _this.state.zoom); // clear selection if shift is not clicked\n\n          if (!(hitElement && _this.state.selectedElementIds[hitElement.id]) && !event.shiftKey) {\n            _this.setState({\n              selectedElementIds: {}\n            });\n          } // If we click on something\n\n\n          if (hitElement) {\n            // deselect if item is selected\n            // if shift is not clicked, this will always return true\n            // otherwise, it will trigger selection based on current\n            // state of the box\n            if (!_this.state.selectedElementIds[hitElement.id]) {\n              _this.setState(function (prevState) {\n                return {\n                  selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, hitElement.id, true))\n                };\n              });\n\n              elements = elements.slice();\n              elementIsAddedToSelection = true;\n            } // We duplicate the selected element if alt is pressed on pointer down\n\n\n            if (event.altKey) {\n              // Move the currently selected elements to the top of the z index stack, and\n              // put the duplicates where the selected elements used to be.\n              var nextElements = [];\n              var elementsToAppend = [];\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var _element = _step.value;\n\n                  if (_this.state.selectedElementIds[_element.id]) {\n                    nextElements.push(duplicateElement(_element));\n                    elementsToAppend.push(_element);\n                  } else {\n                    nextElements.push(_element);\n                  }\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              elements = [].concat(nextElements, elementsToAppend);\n            }\n          }\n        }\n      } else {\n        _this.setState({\n          selectedElementIds: {}\n        });\n      }\n\n      if (isTextElement(element)) {\n        var _this$state$editingEl;\n\n        // if we're currently still editing text, clicking outside\n        //  should only finalize it, not create another (irrespective\n        //  of state.elementLocked)\n        if (((_this$state$editingEl = _this.state.editingElement) === null || _this$state$editingEl === void 0 ? void 0 : _this$state$editingEl.type) === \"text\") {\n          return;\n        }\n\n        if (elementIsAddedToSelection) {\n          element = hitElement;\n        }\n\n        var textX = event.clientX;\n        var textY = event.clientY;\n\n        if (!event.altKey) {\n          var snappedToCenterPosition = _this.getTextWysiwygSnappedToCenterPosition(x, y);\n\n          if (snappedToCenterPosition) {\n            element.x = snappedToCenterPosition.elementCenterX;\n            element.y = snappedToCenterPosition.elementCenterY;\n            textX = snappedToCenterPosition.wysiwygX;\n            textY = snappedToCenterPosition.wysiwygY;\n          }\n        }\n\n        var resetSelection = function resetSelection() {\n          _this.setState({\n            draggingElement: null,\n            editingElement: null\n          });\n        };\n\n        textWysiwyg({\n          initText: \"\",\n          x: textX,\n          y: textY,\n          strokeColor: _this.state.currentItemStrokeColor,\n          opacity: _this.state.currentItemOpacity,\n          font: _this.state.currentItemFont,\n          zoom: _this.state.zoom,\n          onSubmit: function onSubmit(text) {\n            if (text) {\n              elements = [].concat(_toConsumableArray(elements), [_objectSpread({}, newTextElement(element, text, _this.state.currentItemFont))]);\n            }\n\n            _this.setState(function (prevState) {\n              return {\n                selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, element.id, true))\n              };\n            });\n\n            if (_this.state.elementLocked) {\n              setCursorForShape(_this.state.elementType);\n            }\n\n            history.resumeRecording();\n            resetSelection();\n          },\n          onCancel: function onCancel() {\n            resetSelection();\n          }\n        });\n        resetCursor();\n\n        if (!_this.state.elementLocked) {\n          _this.setState({\n            editingElement: element,\n            elementType: \"selection\"\n          });\n        } else {\n          _this.setState({\n            editingElement: element\n          });\n        }\n\n        return;\n      } else if (_this.state.elementType === \"arrow\" || _this.state.elementType === \"line\") {\n        if (_this.state.multiElement) {\n          var multiElement = _this.state.multiElement;\n          var rx = multiElement.x,\n              ry = multiElement.y;\n\n          _this.setState(function (prevState) {\n            return {\n              selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, multiElement.id, true))\n            };\n          });\n\n          multiElement.points.push([x - rx, y - ry]);\n          invalidateShapeForElement(multiElement);\n        } else {\n          _this.setState(function (prevState) {\n            return {\n              selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, element.id, false))\n            };\n          });\n\n          element.points.push([0, 0]);\n          invalidateShapeForElement(element);\n          elements = [].concat(_toConsumableArray(elements), [element]);\n\n          _this.setState({\n            draggingElement: element\n          });\n        }\n      } else if (element.type === \"selection\") {\n        _this.setState({\n          selectionElement: element,\n          draggingElement: element\n        });\n      } else {\n        elements = [].concat(_toConsumableArray(elements), [element]);\n\n        _this.setState({\n          multiElement: null,\n          draggingElement: element\n        });\n      }\n\n      var resizeArrowFn = null;\n\n      var arrowResizeOrigin = function arrowResizeOrigin(element, p1, deltaX, deltaY, pointerX, pointerY, perfect) {\n        if (perfect) {\n          var absPx = p1[0] + element.x;\n          var absPy = p1[1] + element.y;\n\n          var _getPerfectElementSiz = getPerfectElementSize(element.type, pointerX - element.x - p1[0], pointerY - element.y - p1[1]),\n              width = _getPerfectElementSiz.width,\n              height = _getPerfectElementSiz.height;\n\n          var dx = element.x + width + p1[0];\n          var dy = element.y + height + p1[1];\n          element.x = dx;\n          element.y = dy;\n          p1[0] = absPx - element.x;\n          p1[1] = absPy - element.y;\n        } else {\n          element.x += deltaX;\n          element.y += deltaY;\n          p1[0] -= deltaX;\n          p1[1] -= deltaY;\n        }\n      };\n\n      var arrowResizeEnd = function arrowResizeEnd(element, p1, deltaX, deltaY, pointerX, pointerY, perfect) {\n        if (perfect) {\n          var _getPerfectElementSiz2 = getPerfectElementSize(element.type, pointerX - element.x, pointerY - element.y),\n              width = _getPerfectElementSiz2.width,\n              height = _getPerfectElementSiz2.height;\n\n          p1[0] = width;\n          p1[1] = height;\n        } else {\n          p1[0] += deltaX;\n          p1[1] += deltaY;\n        }\n      };\n\n      var onPointerMove = function onPointerMove(event) {\n        var target = event.target;\n\n        if (!(target instanceof HTMLElement)) {\n          return;\n        }\n\n        if (isOverHorizontalScrollBar) {\n          var _x7 = event.clientX;\n          var dx = _x7 - lastX;\n\n          _this.setState({\n            scrollX: normalizeScroll(_this.state.scrollX - dx / _this.state.zoom)\n          });\n\n          lastX = _x7;\n          return;\n        }\n\n        if (isOverVerticalScrollBar) {\n          var _y2 = event.clientY;\n          var dy = _y2 - lastY;\n\n          _this.setState({\n            scrollY: normalizeScroll(_this.state.scrollY - dy / _this.state.zoom)\n          });\n\n          lastY = _y2;\n          return;\n        } // for arrows, don't start dragging until a given threshold\n        //  to ensure we don't create a 2-point arrow by mistake when\n        //  user clicks mouse in a way that it moves a tiny bit (thus\n        //  triggering pointermove)\n\n\n        if (!draggingOccurred && (_this.state.elementType === \"arrow\" || _this.state.elementType === \"line\")) {\n          var _viewportCoordsToScen5 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n              _x8 = _viewportCoordsToScen5.x,\n              _y3 = _viewportCoordsToScen5.y;\n\n          if (distance2d(_x8, _y3, originX, originY) < DRAGGING_THRESHOLD) {\n            return;\n          }\n        }\n\n        if (isResizingElements && _this.state.resizingElement) {\n          _this.setState({\n            isResizing: true\n          });\n\n          var el = _this.state.resizingElement;\n\n          var _selectedElements = getSelectedElements(elements, _this.state);\n\n          if (_selectedElements.length === 1) {\n            var _viewportCoordsToScen6 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n                _x9 = _viewportCoordsToScen6.x,\n                _y4 = _viewportCoordsToScen6.y;\n\n            var _deltaX2 = _x9 - lastX;\n\n            var _deltaY2 = _y4 - lastY;\n\n            var _element2 = _selectedElements[0];\n\n            var _isLinear = _element2.type === \"line\" || _element2.type === \"arrow\";\n\n            switch (resizeHandle) {\n              case \"nw\":\n                if (_isLinear && _element2.points.length === 2) {\n                  var _element2$points = _slicedToArray(_element2.points, 2),\n                      _p = _element2$points[1];\n\n                  if (!resizeArrowFn) {\n                    if (_p[0] < 0 || _p[1] < 0) {\n                      resizeArrowFn = arrowResizeEnd;\n                    } else {\n                      resizeArrowFn = arrowResizeOrigin;\n                    }\n                  }\n\n                  resizeArrowFn(_element2, _p, _deltaX2, _deltaY2, _x9, _y4, event.shiftKey);\n                } else {\n                  _element2.width -= _deltaX2;\n                  _element2.x += _deltaX2;\n\n                  if (event.shiftKey) {\n                    _element2.y += _element2.height - _element2.width;\n                    _element2.height = _element2.width;\n                  } else {\n                    _element2.height -= _deltaY2;\n                    _element2.y += _deltaY2;\n                  }\n                }\n\n                break;\n\n              case \"ne\":\n                if (_isLinear && _element2.points.length === 2) {\n                  var _element2$points2 = _slicedToArray(_element2.points, 2),\n                      _p2 = _element2$points2[1];\n\n                  if (!resizeArrowFn) {\n                    if (_p2[0] >= 0) {\n                      resizeArrowFn = arrowResizeEnd;\n                    } else {\n                      resizeArrowFn = arrowResizeOrigin;\n                    }\n                  }\n\n                  resizeArrowFn(_element2, _p2, _deltaX2, _deltaY2, _x9, _y4, event.shiftKey);\n                } else {\n                  _element2.width += _deltaX2;\n\n                  if (event.shiftKey) {\n                    _element2.y += _element2.height - _element2.width;\n                    _element2.height = _element2.width;\n                  } else {\n                    _element2.height -= _deltaY2;\n                    _element2.y += _deltaY2;\n                  }\n                }\n\n                break;\n\n              case \"sw\":\n                if (_isLinear && _element2.points.length === 2) {\n                  var _element2$points3 = _slicedToArray(_element2.points, 2),\n                      _p3 = _element2$points3[1];\n\n                  if (!resizeArrowFn) {\n                    if (_p3[0] <= 0) {\n                      resizeArrowFn = arrowResizeEnd;\n                    } else {\n                      resizeArrowFn = arrowResizeOrigin;\n                    }\n                  }\n\n                  resizeArrowFn(_element2, _p3, _deltaX2, _deltaY2, _x9, _y4, event.shiftKey);\n                } else {\n                  _element2.width -= _deltaX2;\n                  _element2.x += _deltaX2;\n\n                  if (event.shiftKey) {\n                    _element2.height = _element2.width;\n                  } else {\n                    _element2.height += _deltaY2;\n                  }\n                }\n\n                break;\n\n              case \"se\":\n                if (_isLinear && _element2.points.length === 2) {\n                  var _element2$points4 = _slicedToArray(_element2.points, 2),\n                      _p4 = _element2$points4[1];\n\n                  if (!resizeArrowFn) {\n                    if (_p4[0] > 0 || _p4[1] > 0) {\n                      resizeArrowFn = arrowResizeEnd;\n                    } else {\n                      resizeArrowFn = arrowResizeOrigin;\n                    }\n                  }\n\n                  resizeArrowFn(_element2, _p4, _deltaX2, _deltaY2, _x9, _y4, event.shiftKey);\n                } else {\n                  if (event.shiftKey) {\n                    _element2.width += _deltaX2;\n                    _element2.height = _element2.width;\n                  } else {\n                    _element2.width += _deltaX2;\n                    _element2.height += _deltaY2;\n                  }\n                }\n\n                break;\n\n              case \"n\":\n                {\n                  _element2.height -= _deltaY2;\n                  _element2.y += _deltaY2;\n\n                  if (_element2.points.length > 0) {\n                    var len = _element2.points.length;\n\n                    var points = _toConsumableArray(_element2.points).sort(function (a, b) {\n                      return a[1] - b[1];\n                    });\n\n                    for (var i = 1; i < points.length; ++i) {\n                      var pnt = points[i];\n                      pnt[1] -= _deltaY2 / (len - i);\n                    }\n                  }\n\n                  break;\n                }\n\n              case \"w\":\n                {\n                  _element2.width -= _deltaX2;\n                  _element2.x += _deltaX2;\n\n                  if (_element2.points.length > 0) {\n                    var _len = _element2.points.length;\n\n                    var _points = _toConsumableArray(_element2.points).sort(function (a, b) {\n                      return a[0] - b[0];\n                    });\n\n                    for (var _i = 0; _i < _points.length; ++_i) {\n                      var _pnt = _points[_i];\n                      _pnt[0] -= _deltaX2 / (_len - _i);\n                    }\n                  }\n\n                  break;\n                }\n\n              case \"s\":\n                {\n                  _element2.height += _deltaY2;\n\n                  if (_element2.points.length > 0) {\n                    var _len2 = _element2.points.length;\n\n                    var _points2 = _toConsumableArray(_element2.points).sort(function (a, b) {\n                      return a[1] - b[1];\n                    });\n\n                    for (var _i2 = 1; _i2 < _points2.length; ++_i2) {\n                      var _pnt2 = _points2[_i2];\n                      _pnt2[1] += _deltaY2 / (_len2 - _i2);\n                    }\n                  }\n\n                  break;\n                }\n\n              case \"e\":\n                {\n                  _element2.width += _deltaX2;\n\n                  if (_element2.points.length > 0) {\n                    var _len3 = _element2.points.length;\n\n                    var _points3 = _toConsumableArray(_element2.points).sort(function (a, b) {\n                      return a[0] - b[0];\n                    });\n\n                    for (var _i3 = 1; _i3 < _points3.length; ++_i3) {\n                      var _pnt3 = _points3[_i3];\n                      _pnt3[0] += _deltaX2 / (_len3 - _i3);\n                    }\n                  }\n\n                  break;\n                }\n            }\n\n            if (resizeHandle) {\n              resizeHandle = normalizeResizeHandle(_element2, resizeHandle);\n            }\n\n            normalizeDimensions(_element2);\n            document.documentElement.style.cursor = getCursorForResizingElement({\n              element: _element2,\n              resizeHandle: resizeHandle\n            });\n            el.x = _element2.x;\n            el.y = _element2.y;\n            invalidateShapeForElement(el);\n            lastX = _x9;\n            lastY = _y4;\n\n            _this.setState({});\n\n            return;\n          }\n        }\n\n        if (hitElement && _this.state.selectedElementIds[hitElement.id]) {\n          // Marking that click was used for dragging to check\n          // if elements should be deselected on pointerup\n          draggingOccurred = true;\n\n          var _selectedElements2 = getSelectedElements(elements, _this.state);\n\n          if (_selectedElements2.length > 0) {\n            var _viewportCoordsToScen7 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n                _x10 = _viewportCoordsToScen7.x,\n                _y5 = _viewportCoordsToScen7.y;\n\n            _selectedElements2.forEach(function (element) {\n              element.x += _x10 - lastX;\n              element.y += _y5 - lastY;\n            });\n\n            lastX = _x10;\n            lastY = _y5;\n\n            _this.setState({});\n\n            return;\n          }\n        } // It is very important to read this.state within each move event,\n        // otherwise we would read a stale one!\n\n\n        var draggingElement = _this.state.draggingElement;\n\n        if (!draggingElement) {\n          return;\n        }\n\n        var _viewportCoordsToScen8 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n            x = _viewportCoordsToScen8.x,\n            y = _viewportCoordsToScen8.y;\n\n        var width = distance(originX, x);\n        var height = distance(originY, y);\n        var isLinear = _this.state.elementType === \"line\" || _this.state.elementType === \"arrow\";\n\n        if (isLinear) {\n          draggingOccurred = true;\n          var _points4 = draggingElement.points;\n\n          var _dx = x - draggingElement.x;\n\n          var _dy = y - draggingElement.y;\n\n          if (event.shiftKey && _points4.length === 2) {\n            var _getPerfectElementSiz3 = getPerfectElementSize(_this.state.elementType, _dx, _dy);\n\n            _dx = _getPerfectElementSiz3.width;\n            _dy = _getPerfectElementSiz3.height;\n          }\n\n          if (_points4.length === 1) {\n            _points4.push([_dx, _dy]);\n          } else if (_points4.length > 1) {\n            var _pnt4 = _points4[_points4.length - 1];\n            _pnt4[0] = _dx;\n            _pnt4[1] = _dy;\n          }\n        } else {\n          if (event.shiftKey) {\n            var _getPerfectElementSiz4 = getPerfectElementSize(_this.state.elementType, width, y < originY ? -height : height);\n\n            width = _getPerfectElementSiz4.width;\n            height = _getPerfectElementSiz4.height;\n\n            if (height < 0) {\n              height = -height;\n            }\n          }\n\n          draggingElement.x = x < originX ? originX - width : originX;\n          draggingElement.y = y < originY ? originY - height : originY;\n          draggingElement.width = width;\n          draggingElement.height = height;\n        }\n\n        invalidateShapeForElement(draggingElement);\n\n        if (_this.state.elementType === \"selection\") {\n          if (!event.shiftKey && isSomeElementSelected(elements, _this.state)) {\n            _this.setState({\n              selectedElementIds: {}\n            });\n          }\n\n          var elementsWithinSelection = getElementsWithinSelection(elements, draggingElement);\n\n          _this.setState(function (prevState) {\n            return {\n              selectedElementIds: _objectSpread({}, prevState.selectedElementIds, {}, Object.fromEntries(elementsWithinSelection.map(function (element) {\n                return [element.id, true];\n              })))\n            };\n          });\n        }\n\n        _this.setState({});\n      };\n\n      var onPointerUp = function onPointerUp(event) {\n        var _this$state = _this.state,\n            draggingElement = _this$state.draggingElement,\n            resizingElement = _this$state.resizingElement,\n            multiElement = _this$state.multiElement,\n            elementType = _this$state.elementType,\n            elementLocked = _this$state.elementLocked;\n\n        _this.setState({\n          isResizing: false,\n          resizingElement: null,\n          selectionElement: null\n        });\n\n        resizeArrowFn = null;\n        _lastPointerUp = null;\n        window.removeEventListener(\"pointermove\", onPointerMove);\n        window.removeEventListener(\"pointerup\", onPointerUp);\n\n        if (elementType === \"arrow\" || elementType === \"line\") {\n          if (draggingElement.points.length > 1) {\n            history.resumeRecording();\n\n            _this.setState({});\n          }\n\n          if (!draggingOccurred && draggingElement && !multiElement) {\n            var _viewportCoordsToScen9 = viewportCoordsToSceneCoords(event, _this.state, _this.canvas),\n                _x11 = _viewportCoordsToScen9.x,\n                _y6 = _viewportCoordsToScen9.y;\n\n            draggingElement.points.push([_x11 - draggingElement.x, _y6 - draggingElement.y]);\n            invalidateShapeForElement(draggingElement);\n\n            _this.setState({\n              multiElement: _this.state.draggingElement\n            });\n          } else if (draggingOccurred && !multiElement) {\n            if (!elementLocked) {\n              resetCursor();\n\n              _this.setState(function (prevState) {\n                return {\n                  draggingElement: null,\n                  elementType: \"selection\",\n                  selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, _this.state.draggingElement.id, true))\n                };\n              });\n            } else {\n              _this.setState(function (prevState) {\n                return {\n                  draggingElement: null,\n                  selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, _this.state.draggingElement.id, true))\n                };\n              });\n            }\n          }\n\n          return;\n        }\n\n        if (elementType !== \"selection\" && draggingElement && isInvisiblySmallElement(draggingElement)) {\n          // remove invisible element which was added in onPointerDown\n          elements = elements.slice(0, -1);\n\n          _this.setState({\n            draggingElement: null\n          });\n\n          return;\n        }\n\n        if (normalizeDimensions(draggingElement)) {\n          _this.setState({});\n        }\n\n        if (resizingElement) {\n          history.resumeRecording();\n\n          _this.setState({});\n        }\n\n        if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n          elements = elements.filter(function (el) {\n            return el.id !== resizingElement.id;\n          });\n        } // If click occurred on already selected element\n        // it is needed to remove selection from other elements\n        // or if SHIFT or META key pressed remove selection\n        // from hitted element\n        //\n        // If click occurred and elements were dragged or some element\n        // was added to selection (on pointerdown phase) we need to keep\n        // selection unchanged\n\n\n        if (hitElement && !draggingOccurred && !elementIsAddedToSelection) {\n          if (event.shiftKey) {\n            _this.setState(function (prevState) {\n              return {\n                selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, hitElement.id, false))\n              };\n            });\n          } else {\n            _this.setState(function (prevState) {\n              return {\n                selectedElementIds: _defineProperty({}, hitElement.id, true)\n              };\n            });\n          }\n        }\n\n        if (draggingElement === null) {\n          // if no element is clicked, clear the selection and redraw\n          _this.setState({\n            selectedElementIds: {}\n          });\n\n          return;\n        }\n\n        if (!elementLocked) {\n          _this.setState(function (prevState) {\n            return {\n              selectedElementIds: _objectSpread({}, prevState.selectedElementIds, _defineProperty({}, draggingElement.id, true))\n            };\n          });\n        }\n\n        if (elementType !== \"selection\" || isSomeElementSelected(elements, _this.state)) {\n          history.resumeRecording();\n        }\n\n        if (!elementLocked) {\n          resetCursor();\n\n          _this.setState({\n            draggingElement: null,\n            elementType: \"selection\"\n          });\n        } else {\n          _this.setState({\n            draggingElement: null\n          });\n        }\n      };\n\n      _lastPointerUp = onPointerUp;\n      window.addEventListener(\"pointermove\", onPointerMove);\n      window.addEventListener(\"pointerup\", onPointerUp);\n    };\n\n    _this.handleWheel = function (event) {\n      event.preventDefault();\n      var deltaX = event.deltaX,\n          deltaY = event.deltaY; // note that event.ctrlKey is necessary to handle pinch zooming\n\n      if (event.metaKey || event.ctrlKey) {\n        var sign = Math.sign(deltaY);\n        var MAX_STEP = 10;\n        var delta = Math.abs(deltaY);\n\n        if (delta > MAX_STEP) {\n          delta = MAX_STEP;\n        }\n\n        delta *= sign;\n\n        _this.setState(function (_ref5) {\n          var zoom = _ref5.zoom;\n          return {\n            zoom: getNormalizedZoom(zoom - delta / 100)\n          };\n        });\n\n        return;\n      }\n\n      _this.setState(function (_ref6) {\n        var zoom = _ref6.zoom,\n            scrollX = _ref6.scrollX,\n            scrollY = _ref6.scrollY;\n        return {\n          scrollX: normalizeScroll(scrollX - deltaX / zoom),\n          scrollY: normalizeScroll(scrollY - deltaY / zoom)\n        };\n      });\n    };\n\n    _this.addElementsFromPaste = function (clipboardElements) {\n      var _getCommonBounds = getCommonBounds(clipboardElements),\n          _getCommonBounds2 = _slicedToArray(_getCommonBounds, 4),\n          minX = _getCommonBounds2[0],\n          minY = _getCommonBounds2[1],\n          maxX = _getCommonBounds2[2],\n          maxY = _getCommonBounds2[3];\n\n      var elementsCenterX = distance(minX, maxX) / 2;\n      var elementsCenterY = distance(minY, maxY) / 2;\n\n      var _viewportCoordsToScen10 = viewportCoordsToSceneCoords({\n        clientX: cursorX,\n        clientY: cursorY\n      }, _this.state, _this.canvas),\n          x = _viewportCoordsToScen10.x,\n          y = _viewportCoordsToScen10.y;\n\n      var dx = x - elementsCenterX;\n      var dy = y - elementsCenterY;\n      var newElements = clipboardElements.map(function (clipboardElements) {\n        var duplicate = duplicateElement(clipboardElements);\n        duplicate.x += dx - minX;\n        duplicate.y += dy - minY;\n        return duplicate;\n      });\n      elements = [].concat(_toConsumableArray(elements), _toConsumableArray(newElements));\n      history.resumeRecording();\n\n      _this.setState({\n        selectedElementIds: Object.fromEntries(newElements.map(function (element) {\n          return [element.id, true];\n        }))\n      });\n    };\n\n    _this.savePointer = function (pointerCoords) {\n      if (isNaN(pointerCoords.x) || isNaN(pointerCoords.y)) {\n        // sometimes the pointer goes off screen\n        return;\n      }\n\n      _this.socket && _this.broadcastSocketData({\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketID: _this.socket.id,\n          pointerCoords: pointerCoords\n        }\n      });\n    };\n\n    _this.saveDebounced = debounce(function () {\n      saveToLocalStorage(elements, _this.state);\n    }, 300);\n    _this.actionManager = new ActionManager(_this.syncActionResult, function () {\n      return _this.state;\n    }, function () {\n      return elements;\n    });\n\n    _this.actionManager.registerAll(actions);\n\n    _this.actionManager.registerAction(createUndoAction(history));\n\n    _this.actionManager.registerAction(createRedoAction(history));\n\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        var _this2 = this;\n\n        var searchParams, id, _scene, jsonMatch, _scene2, roomMatch, scene;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (process.env.NODE_ENV === \"test\") {\n                  Object.defineProperty(window.__TEST__, \"appState\", {\n                    configurable: true,\n                    get: function get() {\n                      return _this2.state;\n                    }\n                  });\n                }\n\n                document.addEventListener(\"copy\", this.onCopy);\n                document.addEventListener(\"paste\", this.pasteFromClipboard);\n                document.addEventListener(\"cut\", this.onCut);\n                document.addEventListener(\"keydown\", this.onKeyDown, false);\n                document.addEventListener(\"keyup\", this.onKeyUp, {\n                  passive: true\n                });\n                document.addEventListener(\"mousemove\", this.updateCurrentCursorPosition);\n                window.addEventListener(\"resize\", this.onResize, false);\n                window.addEventListener(\"unload\", this.onUnload, false);\n                window.addEventListener(\"blur\", this.onUnload, false);\n                window.addEventListener(\"dragover\", this.disableEvent, false);\n                window.addEventListener(\"drop\", this.disableEvent, false); // Safari-only desktop pinch zoom\n\n                document.addEventListener(\"gesturestart\", this.onGestureStart, false);\n                document.addEventListener(\"gesturechange\", this.onGestureChange, false);\n                document.addEventListener(\"gestureend\", this.onGestureEnd, false);\n                searchParams = new URLSearchParams(window.location.search);\n                id = searchParams.get(\"id\");\n\n                if (!id) {\n                  _context5.next = 22;\n                  break;\n                }\n\n                _context5.next = 20;\n                return loadScene(id);\n\n              case 20:\n                _scene = _context5.sent;\n                this.syncActionResult(_scene);\n\n              case 22:\n                jsonMatch = window.location.hash.match(/^#json=([0-9]+),([a-zA-Z0-9_-]+)$/);\n\n                if (!jsonMatch) {\n                  _context5.next = 29;\n                  break;\n                }\n\n                _context5.next = 26;\n                return loadScene(jsonMatch[1], jsonMatch[2]);\n\n              case 26:\n                _scene2 = _context5.sent;\n                this.syncActionResult(_scene2);\n                return _context5.abrupt(\"return\");\n\n              case 29:\n                roomMatch = getCollaborationLinkData(window.location.href);\n\n                if (!roomMatch) {\n                  _context5.next = 33;\n                  break;\n                }\n\n                this.initializeSocketClient();\n                return _context5.abrupt(\"return\");\n\n              case 33:\n                _context5.next = 35;\n                return loadScene(null);\n\n              case 35:\n                scene = _context5.sent;\n                this.syncActionResult(scene);\n\n              case 37:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      }\n\n      return componentDidMount;\n    }()\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.unmounted = true;\n      document.removeEventListener(\"copy\", this.onCopy);\n      document.removeEventListener(\"paste\", this.pasteFromClipboard);\n      document.removeEventListener(\"cut\", this.onCut);\n      document.removeEventListener(\"keydown\", this.onKeyDown, false);\n      document.removeEventListener(\"mousemove\", this.updateCurrentCursorPosition, false);\n      document.removeEventListener(\"keyup\", this.onKeyUp);\n      window.removeEventListener(\"resize\", this.onResize, false);\n      window.removeEventListener(\"unload\", this.onUnload, false);\n      window.removeEventListener(\"blur\", this.onUnload, false);\n      window.removeEventListener(\"dragover\", this.disableEvent, false);\n      window.removeEventListener(\"drop\", this.disableEvent, false);\n      document.removeEventListener(\"gesturestart\", this.onGestureStart, false);\n      document.removeEventListener(\"gesturechange\", this.onGestureChange, false);\n      document.removeEventListener(\"gestureend\", this.onGestureEnd, false);\n    }\n  }, {\n    key: \"selectShapeTool\",\n    value: function selectShapeTool(elementType) {\n      if (!isHoldingSpace) {\n        setCursorForShape(elementType);\n      }\n\n      if (isToolIcon(document.activeElement)) {\n        document.activeElement.blur();\n      }\n\n      if (elementType !== \"selection\") {\n        this.setState({\n          elementType: elementType,\n          selectedElementIds: {}\n        });\n      } else {\n        this.setState({\n          elementType: elementType\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var canvasDOMWidth = window.innerWidth;\n      var canvasDOMHeight = window.innerHeight;\n      var canvasScale = window.devicePixelRatio;\n      var canvasWidth = canvasDOMWidth * canvasScale;\n      var canvasHeight = canvasDOMHeight * canvasScale;\n      return React.createElement(\"div\", {\n        className: \"container\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 595\n        },\n        __self: this\n      }, React.createElement(LayerUI, {\n        canvas: this.canvas,\n        appState: this.state,\n        setAppState: this.setAppState,\n        actionManager: this.actionManager,\n        elements: elements,\n        setElements: this.setElements,\n        language: getLanguage(),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 596\n        },\n        __self: this\n      }), React.createElement(\"main\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 605\n        },\n        __self: this\n      }, React.createElement(\"canvas\", {\n        id: \"canvas\",\n        style: {\n          width: canvasDOMWidth,\n          height: canvasDOMHeight\n        },\n        width: canvasWidth,\n        height: canvasHeight,\n        ref: function ref(canvas) {\n          // canvas is null when unmounting\n          if (canvas !== null) {\n            var _this3$canvas$getCont;\n\n            _this3.canvas = canvas;\n            _this3.rc = rough.canvas(_this3.canvas);\n\n            _this3.canvas.addEventListener(\"wheel\", _this3.handleWheel, {\n              passive: false\n            });\n\n            (_this3$canvas$getCont = _this3.canvas.getContext(\"2d\")) === null || _this3$canvas$getCont === void 0 ? void 0 : _this3$canvas$getCont.setTransform(canvasScale, 0, 0, canvasScale, 0, 0);\n          } else {\n            var _this3$canvas;\n\n            (_this3$canvas = _this3.canvas) === null || _this3$canvas === void 0 ? void 0 : _this3$canvas.removeEventListener(\"wheel\", _this3.handleWheel);\n          }\n        },\n        onContextMenu: function onContextMenu(event) {\n          event.preventDefault();\n\n          var _viewportCoordsToScen11 = viewportCoordsToSceneCoords(event, _this3.state, _this3.canvas),\n              x = _viewportCoordsToScen11.x,\n              y = _viewportCoordsToScen11.y;\n\n          var element = getElementAtPosition(elements, _this3.state, x, y, _this3.state.zoom);\n\n          if (!element) {\n            ContextMenu.push({\n              options: [navigator.clipboard && {\n                label: t(\"labels.paste\"),\n                action: function action() {\n                  return _this3.pasteFromClipboard(null);\n                }\n              }].concat(_toConsumableArray(_this3.actionManager.getContextMenuItems(function (action) {\n                return _this3.canvasOnlyActions.includes(action.name);\n              }))),\n              top: event.clientY,\n              left: event.clientX\n            });\n            return;\n          }\n\n          if (!_this3.state.selectedElementIds[element.id]) {\n            _this3.setState({\n              selectedElementIds: _defineProperty({}, element.id, true)\n            });\n          }\n\n          ContextMenu.push({\n            options: [navigator.clipboard && {\n              label: t(\"labels.copy\"),\n              action: _this3.copyToAppClipboard\n            }, navigator.clipboard && {\n              label: t(\"labels.paste\"),\n              action: function action() {\n                return _this3.pasteFromClipboard(null);\n              }\n            }].concat(_toConsumableArray(_this3.actionManager.getContextMenuItems(function (action) {\n              return !_this3.canvasOnlyActions.includes(action.name);\n            }))),\n            top: event.clientY,\n            left: event.clientX\n          });\n        },\n        onPointerDown: this.handleCanvasPointerDown,\n        onDoubleClick: this.handleCanvasDoubleClick,\n        onPointerMove: this.handleCanvasPointerMove,\n        onPointerUp: this.removePointer,\n        onPointerCancel: this.removePointer,\n        onDrop: function onDrop(event) {\n          var file = event.dataTransfer.files[0];\n\n          if ((file === null || file === void 0 ? void 0 : file.type) === \"application/json\" || (file === null || file === void 0 ? void 0 : file.name.endsWith(\".excalidraw\"))) {\n            loadFromBlob(file).then(function (_ref7) {\n              var elements = _ref7.elements,\n                  appState = _ref7.appState;\n              return _this3.syncActionResult({\n                elements: elements,\n                appState: appState\n              });\n            }).catch(function (error) {\n              return console.error(error);\n            });\n          }\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 606\n        },\n        __self: this\n      }, t(\"labels.drawingCanvas\"))));\n    }\n  }, {\n    key: \"getTextWysiwygSnappedToCenterPosition\",\n    value: function getTextWysiwygSnappedToCenterPosition(x, y) {\n      var elementClickedInside = getElementContainingPosition(elements, x, y);\n\n      if (elementClickedInside) {\n        var elementCenterX = elementClickedInside.x + elementClickedInside.width / 2;\n        var elementCenterY = elementClickedInside.y + elementClickedInside.height / 2;\n        var distanceToCenter = Math.hypot(x - elementCenterX, y - elementCenterY);\n        var isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n\n        if (isSnappedToCenter) {\n          var wysiwygX = this.state.scrollX + elementClickedInside.x + elementClickedInside.width / 2;\n          var wysiwygY = this.state.scrollY + elementClickedInside.y + elementClickedInside.height / 2;\n          return {\n            wysiwygX: wysiwygX,\n            wysiwygY: wysiwygY,\n            elementCenterX: elementCenterX,\n            elementCenterY: elementCenterY\n          };\n        }\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.state.isCollaborating && !this.socket) {\n        this.initializeSocketClient();\n      }\n\n      var pointerViewportCoords = {};\n\n      for (var clientId in this.state.remotePointers) {\n        var remotePointerCoord = this.state.remotePointers[clientId];\n        pointerViewportCoords[clientId] = sceneCoordsToViewportCoords({\n          sceneX: remotePointerCoord.x,\n          sceneY: remotePointerCoord.y\n        }, this.state, this.canvas);\n      }\n\n      var _renderScene = renderScene(elements, this.state, this.state.selectionElement, this.rc, this.canvas, {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords\n      }, {\n        renderOptimizations: true\n      }),\n          atLeastOneVisibleElement = _renderScene.atLeastOneVisibleElement,\n          scrollBars = _renderScene.scrollBars;\n\n      if (scrollBars) {\n        currentScrollBars = scrollBars;\n      }\n\n      var scrolledOutside = !atLeastOneVisibleElement && elements.length > 0;\n\n      if (this.state.scrolledOutside !== scrolledOutside) {\n        this.setState({\n          scrolledOutside: scrolledOutside\n        });\n      }\n\n      this.saveDebounced();\n\n      if (history.isRecording()) {\n        this.broadcastSocketData({\n          type: \"SCENE_UPDATE\",\n          payload: {\n            elements: elements,\n            appState: this.state\n          }\n        });\n        history.pushEntry(this.state, elements);\n        history.skipRecording();\n      }\n    }\n  }]);\n\n  return App;\n}(React.Component);","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/components/App.tsx"],"names":["React","socketIOClient","rough","newElement","newTextElement","duplicateElement","normalizeResizeHandle","isInvisiblySmallElement","isTextElement","textWysiwyg","getCommonBounds","getCursorForResizingElement","getPerfectElementSize","normalizeDimensions","deleteSelectedElements","getElementsWithinSelection","isOverScrollBars","getElementAtPosition","createScene","getElementContainingPosition","getNormalizedZoom","getSelectedElements","isSomeElementSelected","decryptAESGEM","encryptAESGEM","saveToLocalStorage","loadScene","loadFromBlob","SOCKET_SERVER","restore","renderScene","isWritableElement","isInputLike","isToolIcon","debounce","distance","distance2d","resetCursor","viewportCoordsToSceneCoords","sceneCoordsToViewportCoords","KEYS","isArrowKey","findShapeByKey","shapesShortcutKeys","createHistory","ContextMenu","getElementWithResizeHandler","ActionManager","actions","getDefaultAppState","t","getLanguage","copyToAppClipboard","getClipboardContent","normalizeScroll","getCenter","getDistance","createUndoAction","createRedoAction","CURSOR_TYPE","ELEMENT_SHIFT_TRANSLATE_AMOUNT","ELEMENT_TRANSLATE_AMOUNT","POINTER_BUTTON","DRAGGING_THRESHOLD","TEXT_TO_CENTER_SNAP_THRESHOLD","LayerUI","invalidateShapeForElement","generateCollaborationLink","getCollaborationLinkData","process","env","NODE_ENV","window","__TEST__","elements","Object","defineProperty","get","history","cursorX","cursorY","isHoldingSpace","isPanning","isDraggingScrollBar","currentScrollBars","horizontal","vertical","lastPointerUp","gesture","pointers","Map","lastCenter","initialDistance","initialScale","setCursorForShape","shape","document","documentElement","style","cursor","TEXT","CROSSHAIR","App","props","canvas","rc","socket","socketInitialized","roomID","roomKey","actionManager","canvasOnlyActions","syncActionResult","res","commitToHistory","unmounted","resumeRecording","setState","appState","onCut","event","target","state","nextElements","preventDefault","onCopy","onUnload","saveDebounced","flush","disableEvent","initializeSocketClient","roomMatch","location","href","on","emit","encryptedData","iv","decryptedData","type","payload","sceneElements","sceneAppState","restoredState","scrollToContent","socketID","pointerCoords","remotePointers","off","collaboratorCount","broadcastSocketData","data","json","JSON","stringify","encoded","TextEncoder","encode","encrypted","onResize","forEach","element","updateCurrentCursorPosition","x","y","onKeyDown","key","ESCAPE","handleKeyDown","step","shiftKey","map","el","selectedElementIds","id","ARROW_LEFT","ARROW_RIGHT","ARROW_UP","ARROW_DOWN","includes","toLowerCase","ctrlKey","altKey","metaKey","draggingElement","selectShapeTool","SPACE","size","GRABBING","onKeyUp","elementType","pasteFromClipboard","activeElement","elementUnderCursor","elementFromPoint","HTMLCanvasElement","addElementsFromPaste","text","clientX","clientY","currentItemStrokeColor","currentItemBackgroundColor","currentItemFillStyle","currentItemStrokeWidth","currentItemRoughness","currentItemOpacity","currentItemFont","onGestureStart","zoom","onGestureChange","scale","onGestureEnd","setAppState","obj","setElements","elements_","removePointer","delete","pointerId","handleCanvasDoubleClick","elementAtPosition","editingElement","textX","textY","filter","centerElementX","width","centerElementY","height","sceneX","sceneY","centerElementXInViewport","centerElementYInViewport","snappedToCenterPosition","getTextWysiwygSnappedToCenterPosition","elementCenterX","elementCenterY","wysiwygX","wysiwygY","resetSelection","initText","strokeColor","font","opacity","onSubmit","prevState","onCancel","handleCanvasPointerMove","savePointer","set","center","deltaX","deltaY","Array","from","values","scaleFactor","scrollX","scrollY","isOverHorizontalScrollBar","isOverVerticalScrollBar","isOverScrollBar","multiElement","originX","originY","points","pnt","length","hasDeselectedButton","Boolean","buttons","selectedElements","resizeElement","pointerType","resizeHandle","hitElement","handleCanvasPointerDown","lastPointerDownWith","button","WHEEL","MAIN","lastX","lastY","onPointerMove","teardown","removeEventListener","addEventListener","passive","TOUCH","HTMLElement","blur","dx","dy","onPointerUp","isResizingElements","draggingOccurred","elementIsAddedToSelection","resizingElement","slice","elementsToAppend","push","elementLocked","rx","ry","selectionElement","resizeArrowFn","arrowResizeOrigin","p1","pointerX","pointerY","perfect","absPx","absPy","arrowResizeEnd","isResizing","isLinear","len","sort","a","b","i","elementsWithinSelection","fromEntries","handleWheel","sign","Math","MAX_STEP","delta","abs","clipboardElements","minX","minY","maxX","maxY","elementsCenterX","elementsCenterY","newElements","duplicate","isNaN","registerAll","registerAction","configurable","searchParams","URLSearchParams","search","scene","jsonMatch","hash","match","canvasDOMWidth","innerWidth","canvasDOMHeight","innerHeight","canvasScale","devicePixelRatio","canvasWidth","canvasHeight","getContext","setTransform","options","navigator","clipboard","label","action","getContextMenuItems","name","top","left","file","dataTransfer","files","endsWith","then","catch","error","console","elementClickedInside","distanceToCenter","hypot","isSnappedToCenter","isCollaborating","pointerViewportCoords","clientId","remotePointerCoord","viewBackgroundColor","remotePointerViewportCoords","renderOptimizations","atLeastOneVisibleElement","scrollBars","scrolledOutside","isRecording","pushEntry","skipRecording","Component"],"mappings":";;;;;;;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,KAAP,MAAkB,mBAAlB;AAIA,SACEC,UADF,EAEEC,cAFF,EAGEC,gBAHF,EAKEC,qBALF,EAMEC,uBANF,EAOEC,aAPF,EAQEC,WARF,EASEC,eATF,EAUEC,2BAVF,EAWEC,qBAXF,EAYEC,mBAZF,QAaO,YAbP;AAcA,SACEC,sBADF,EAEEC,0BAFF,EAGEC,gBAHF,EAIEC,oBAJF,EAKEC,WALF,EAMEC,4BANF,EAOEC,iBAPF,EAQEC,mBARF,EASEC,qBATF,QAUO,UAVP;AAWA,SACEC,aADF,EAEEC,aAFF,EAGEC,kBAHF,EAIEC,SAJF,EAKEC,YALF,EAMEC,aANF,QAQO,SARP;AASA,SAASC,OAAT,QAAwB,iBAAxB;AAEA,SAASC,WAAT,QAA4B,aAA5B;AAIA,SACEC,iBADF,EAEEC,WAFF,EAGEC,UAHF,EAIEC,QAJF,EAKEC,QALF,EAMEC,UANF,EAOEC,WAPF,EAQEC,2BARF,EASEC,2BATF,QAUO,UAVP;AAWA,SAASC,IAAT,EAAeC,UAAf,QAAiC,SAAjC;AAEA,SAASC,cAAT,EAAyBC,kBAAzB,QAAmD,WAAnD;AACA,SAASC,aAAT,QAA8B,YAA9B;AAEA,OAAOC,WAAP,MAAwB,eAAxB;AAEA,SAASC,2BAAT,QAA4C,uBAA5C;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,OAAO,YAAP;AACA,SAASC,OAAT,QAAwB,qBAAxB;AAGA,SAASC,kBAAT,QAAmC,aAAnC;AACA,SAASC,CAAT,EAAYC,WAAZ,QAA+B,SAA/B;AAEA,SAASC,kBAAT,EAA6BC,mBAA7B,QAAwD,cAAxD;AACA,SAASC,eAAT,QAAgC,UAAhC;AACA,SAASC,SAAT,EAAoBC,WAApB,QAAuC,YAAvC;AACA,SAASC,gBAAT,EAA2BC,gBAA3B,QAAmD,0BAAnD;AACA,SACEC,WADF,EAEEC,8BAFF,EAGEC,wBAHF,EAIEC,cAJF,EAKEC,kBALF,EAMEC,6BANF,QAOO,cAPP;AAQA,SAASC,OAAT,QAAwB,WAAxB;AAEA,SAASC,yBAAT,QAA0C,2BAA1C;AACA,SAASC,yBAAT,EAAoCC,wBAApC,QAAoE,SAApE,C,CAEA;AACA;AACA;;AAaA,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,MAA7B,EAAqC;AACnCC,EAAAA,MAAM,CAACC,QAAP,GAAkB,EAAlB;AACD;;AACDD,MAAM,CAACL,yBAAP,GAAmCA,yBAAnC,C,CAEA;;mBAEmBjD,WAAW,E;IAAxBwD,Q,gBAAAA,Q;;AAEN,IAAIL,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,MAA7B,EAAqC;AACnCI,EAAAA,MAAM,CAACC,cAAP,CAAsBJ,MAAM,CAACC,QAA7B,EAAuC,UAAvC,EAAmD;AACjDI,IAAAA,GADiD,iBAC3C;AACJ,aAAOH,QAAP;AACD;AAHgD,GAAnD;AAKD;;qBAEmB9B,aAAa,E;IAAzBkC,O,kBAAAA,O;;AAER,IAAIC,OAAO,GAAG,CAAd;AACA,IAAIC,OAAO,GAAG,CAAd;AACA,IAAIC,cAAuB,GAAG,KAA9B;AACA,IAAIC,SAAkB,GAAG,KAAzB;AACA,IAAIC,mBAA4B,GAAG,KAAnC;AACA,IAAIC,iBAA6B,GAAG;AAAEC,EAAAA,UAAU,EAAE,IAAd;AAAoBC,EAAAA,QAAQ,EAAE;AAA9B,CAApC;AAEA,IAAIC,cAA4C,GAAG,IAAnD;AACA,IAAMC,OAAgB,GAAG;AACvBC,EAAAA,QAAQ,EAAE,IAAIC,GAAJ,EADa;AAEvBC,EAAAA,UAAU,EAAE,IAFW;AAGvBC,EAAAA,eAAe,EAAE,IAHM;AAIvBC,EAAAA,YAAY,EAAE;AAJS,CAAzB;;AAOA,SAASC,iBAAT,CAA2BC,KAA3B,EAA0C;AACxC,MAAIA,KAAK,KAAK,WAAd,EAA2B;AACzB1D,IAAAA,WAAW;AACZ,GAFD,MAEO;AACL2D,IAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GACEJ,KAAK,KAAK,MAAV,GAAmBpC,WAAW,CAACyC,IAA/B,GAAsCzC,WAAW,CAAC0C,SADpD;AAED;AACF;;AAED,WAAaC,GAAb;AAAA;AAAA;AAAA;;AAIsC;AAMpC,eAAYC,KAAZ,EAAwB;AAAA;;AAAA;;AACtB,6EAAMA,KAAN;AADsB,UATxBC,MASwB,GATW,IASX;AAAA,UARxBC,EAQwB,GARC,IAQD;AAAA,UAPxBC,MAOwB,GAPe,IAOf;AAAA,UANxBC,iBAMwB,GANK,KAML;AAAA,UALxBC,MAKwB,GALA,IAKA;AAAA,UAJxBC,OAIwB,GAJC,IAID;AAAA,UAFxBC,aAEwB;AAAA,UADxBC,iBACwB,GADJ,CAAC,WAAD,CACI;;AAAA,UAahBC,gBAbgB,GAaG,UACzBC,GADyB,EAGtB;AAAA,UADHC,eACG,uEADwB,IACxB;;AACH,UAAI,MAAKC,SAAT,EAAoB;AAClB;AACD;;AACD,UAAIF,GAAG,CAACvC,QAAR,EAAkB;AAChBA,QAAAA,QAAQ,GAAGuC,GAAG,CAACvC,QAAf;;AACA,YAAIwC,eAAJ,EAAqB;AACnBpC,UAAAA,OAAO,CAACsC,eAAR;AACD;;AACD,cAAKC,QAAL,CAAc,EAAd;AACD;;AAED,UAAIJ,GAAG,CAACK,QAAR,EAAkB;AAChB,YAAIJ,eAAJ,EAAqB;AACnBpC,UAAAA,OAAO,CAACsC,eAAR;AACD;;AACD,cAAKC,QAAL,mBAAmBJ,GAAG,CAACK,QAAvB;AACD;AACF,KAlCuB;;AAAA,UAoChBC,KApCgB,GAoCR,UAACC,KAAD,EAA2B;AACzC,UAAIzF,iBAAiB,CAACyF,KAAK,CAACC,MAAP,CAArB,EAAqC;AACnC;AACD;;AACDrE,MAAAA,kBAAkB,CAACsB,QAAD,EAAW,MAAKgD,KAAhB,CAAlB;;AAJyC,kCAKI5G,sBAAsB,CACjE4D,QADiE,EAEjE,MAAKgD,KAF4D,CAL1B;AAAA,UAKvBC,YALuB,yBAKjCjD,QALiC;AAAA,UAKT4C,QALS,yBAKTA,QALS;;AASzC5C,MAAAA,QAAQ,GAAGiD,YAAX;AACA7C,MAAAA,OAAO,CAACsC,eAAR;;AACA,YAAKC,QAAL,mBAAmBC,QAAnB;;AACAE,MAAAA,KAAK,CAACI,cAAN;AACD,KAjDuB;;AAAA,UAkDhBC,MAlDgB,GAkDP,UAACL,KAAD,EAA2B;AAC1C,UAAIzF,iBAAiB,CAACyF,KAAK,CAACC,MAAP,CAArB,EAAqC;AACnC;AACD;;AACDrE,MAAAA,kBAAkB,CAACsB,QAAD,EAAW,MAAKgD,KAAhB,CAAlB;AACAF,MAAAA,KAAK,CAACI,cAAN;AACD,KAxDuB;;AAAA,UA0DhBE,QA1DgB,GA0DL,YAAM;AACvB7C,MAAAA,cAAc,GAAG,KAAjB;;AACA,YAAK8C,aAAL;;AACA,YAAKA,aAAL,CAAmBC,KAAnB;AACD,KA9DuB;;AAAA,UAgEhBC,YAhEgB,GAgEoB,UAAAT,KAAK,EAAI;AACnDA,MAAAA,KAAK,CAACI,cAAN;AACD,KAlEuB;;AAAA,UAoEhBM,sBApEgB,GAoES,YAAM;AACrC,UAAI,MAAKxB,MAAT,EAAiB;AACf;AACD;;AACD,UAAMyB,SAAS,GAAG/D,wBAAwB,CAACI,MAAM,CAAC4D,QAAP,CAAgBC,IAAjB,CAA1C;;AACA,UAAIF,SAAJ,EAAe;AACb,cAAKzB,MAAL,GAAczG,cAAc,CAAC2B,aAAD,CAA5B;AACA,cAAKgF,MAAL,GAAcuB,SAAS,CAAC,CAAD,CAAvB;AACA,cAAKtB,OAAL,GAAesB,SAAS,CAAC,CAAD,CAAxB;;AACA,cAAKzB,MAAL,CAAY4B,EAAZ,CAAe,WAAf,EAA4B,YAAM;AAChC,gBAAK5B,MAAL,IAAe,MAAKA,MAAL,CAAY6B,IAAZ,CAAiB,WAAjB,EAA8B,MAAK3B,MAAnC,CAAf;AACD,SAFD;;AAGA,cAAKF,MAAL,CAAY4B,EAAZ,CACE,kBADF;AAAA;AAAA;AAAA;AAAA;AAAA,mCAEE,iBAAOE,aAAP,EAAmCC,EAAnC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,wBACO,MAAK5B,OADZ;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,2BAI8BtF,aAAa,CACvCiH,aADuC,EAEvC,MAAK3B,OAFkC,EAGvC4B,EAHuC,CAJ3C;;AAAA;AAIQC,oBAAAA,aAJR;AAAA,kCAUUA,aAAa,CAACC,IAVxB;AAAA,oDAWS,kBAXT,uBAaS,cAbT,uBA6BS,gBA7BT;AAAA;;AAAA;AAAA;;AAAA;AAAA,4CAiBUD,aAAa,CAACE,OAjBxB,EAekBC,aAflB,yBAeQnE,QAfR,EAgBkBoE,aAhBlB,yBAgBQxB,QAhBR;AAkBYyB,oBAAAA,aAlBZ,GAkB4BlH,OAAO,CAC3BgH,aAAa,IAAI,EADU,EAE3BC,aAAa,IAAI7F,kBAAkB,EAFR,EAG3B;AAAE+F,sBAAAA,eAAe,EAAE;AAAnB,qBAH2B,CAlBnC;AAuBMtE,oBAAAA,QAAQ,GAAGqE,aAAa,CAACrE,QAAzB;;AACA,0BAAK2C,QAAL,CAAc,EAAd;;AACA,wBAAI,MAAKV,iBAAL,KAA2B,KAA/B,EAAsC;AACpC,4BAAKA,iBAAL,GAAyB,IAAzB;AACD;;AA3BP;;AAAA;AAAA,6CA8B0C+B,aAAa,CAACE,OA9BxD,EA8BcK,QA9Bd,0BA8BcA,QA9Bd,EA8BwBC,aA9BxB,0BA8BwBA,aA9BxB;;AA+BM,0BAAK7B,QAAL,CAAc;AACZ8B,sBAAAA,cAAc,oBACT,MAAKzB,KAAL,CAAWyB,cADF,sBAEXF,QAFW,EAEAC,aAFA;AADF,qBAAd;;AA/BN;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAFF;;AAAA;AAAA;AAAA;AAAA;;AA2CA,cAAKxC,MAAL,CAAY4B,EAAZ,CAAe,eAAf,EAAgC,YAAM;AACpC,cAAI,MAAK5B,MAAT,EAAiB;AACf,kBAAKA,MAAL,CAAY0C,GAAZ,CAAgB,eAAhB;AACD;;AACD,gBAAKzC,iBAAL,GAAyB,IAAzB;AACD,SALD;;AAMA,cAAKD,MAAL,CAAY4B,EAAZ,CAAe,iBAAf,EAAkC,UAACe,iBAAD,EAA+B;AAC/D,gBAAKhC,QAAL,CAAc;AAAEgC,YAAAA,iBAAiB,EAAjBA;AAAF,WAAd;AACD,SAFD;;AAGA,cAAK3C,MAAL,CAAY4B,EAAZ,CAAe,UAAf;AAAA;AAAA;AAAA;AAAA;AAAA,mCAA2B,kBAAOW,QAAP;AAAA;AAAA;AAAA;AAAA;AACzB,0BAAKK,mBAAL,CAAyB;AACvBX,sBAAAA,IAAI,EAAE,cADiB;AAEvBC,sBAAAA,OAAO,EAAE;AACPlE,wBAAAA,QAAQ,EAARA,QADO;AAEP4C,wBAAAA,QAAQ,EAAE,MAAKI;AAFR;AAFc,qBAAzB;;AADyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAA3B;;AAAA;AAAA;AAAA;AAAA;AASD;AACF,KA9IuB;;AAAA,UAgJhB4B,mBAhJgB;AAAA;AAAA;AAAA;AAAA;AAAA,+BAgJM,kBAAOC,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBACxB,MAAK5C,iBAAL,IAA0B,MAAKD,MAA/B,IAAyC,MAAKE,MAA9C,IAAwD,MAAKC,OADrC;AAAA;AAAA;AAAA;;AAEpB2C,gBAAAA,IAFoB,GAEbC,IAAI,CAACC,SAAL,CAAeH,IAAf,CAFa;AAGpBI,gBAAAA,OAHoB,GAGV,IAAIC,WAAJ,GAAkBC,MAAlB,CAAyBL,IAAzB,CAHU;AAAA;AAAA,uBAIFhI,aAAa,CAACmI,OAAD,EAAU,MAAK9C,OAAf,CAJX;;AAAA;AAIpBiD,gBAAAA,SAJoB;;AAK1B,sBAAKpD,MAAL,CAAY6B,IAAZ,CACE,kBADF,EAEE,MAAK3B,MAFP,EAGEkD,SAAS,CAACP,IAHZ,EAIEO,SAAS,CAACrB,EAJZ;;AAL0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAhJN;;AAAA;AAAA;AAAA;AAAA;;AAAA,UA8JhBtB,SA9JgB,GA8JJ,KA9JI;AAAA,UA8PjBO,KA9PiB,GA8PCzE,kBAAkB,EA9PnB;;AAAA,UAgQhB8G,QAhQgB,GAgQL,YAAM;AACvBrF,MAAAA,QAAQ,CAACsF,OAAT,CAAiB,UAAAC,OAAO;AAAA,eAAI/F,yBAAyB,CAAC+F,OAAD,CAA7B;AAAA,OAAxB;;AACA,YAAK5C,QAAL,CAAc,EAAd;AACD,KAnQuB;;AAAA,UAqQhB6C,2BArQgB,GAqQc,UAAC1C,KAAD,EAAuB;AAC3DzC,MAAAA,OAAO,GAAGyC,KAAK,CAAC2C,CAAhB;AACAnF,MAAAA,OAAO,GAAGwC,KAAK,CAAC4C,CAAhB;AACD,KAxQuB;;AAAA,UA0QhBC,SA1QgB,GA0QJ,UAAC7C,KAAD,EAA0B;AAC5C,UACGzF,iBAAiB,CAACyF,KAAK,CAACC,MAAP,CAAjB,IAAmCD,KAAK,CAAC8C,GAAN,KAAc9H,IAAI,CAAC+H,MAAvD,IACA;AACC9H,MAAAA,UAAU,CAAC+E,KAAK,CAAC8C,GAAP,CAAV,IAAyBtI,WAAW,CAACwF,KAAK,CAACC,MAAP,CAHvC,EAIE;AACA;AACD;;AAED,UAAI,MAAKX,aAAL,CAAmB0D,aAAnB,CAAiChD,KAAjC,CAAJ,EAA6C;AAC3C;AACD;;AAED,UAAMzB,KAAK,GAAGrD,cAAc,CAAC8E,KAAK,CAAC8C,GAAP,CAA5B;;AAEA,UAAI7H,UAAU,CAAC+E,KAAK,CAAC8C,GAAP,CAAd,EAA2B;AACzB,YAAMG,IAAI,GAAGjD,KAAK,CAACkD,QAAN,GACT9G,8BADS,GAETC,wBAFJ;AAGAa,QAAAA,QAAQ,GAAGA,QAAQ,CAACiG,GAAT,CAAa,UAAAC,EAAE,EAAI;AAC5B,cAAI,MAAKlD,KAAL,CAAWmD,kBAAX,CAA8BD,EAAE,CAACE,EAAjC,CAAJ,EAA0C;AACxC,gBAAMb,OAAO,qBAAQW,EAAR,CAAb;;AACA,gBAAIpD,KAAK,CAAC8C,GAAN,KAAc9H,IAAI,CAACuI,UAAvB,EAAmC;AACjCd,cAAAA,OAAO,CAACE,CAAR,IAAaM,IAAb;AACD,aAFD,MAEO,IAAIjD,KAAK,CAAC8C,GAAN,KAAc9H,IAAI,CAACwI,WAAvB,EAAoC;AACzCf,cAAAA,OAAO,CAACE,CAAR,IAAaM,IAAb;AACD,aAFM,MAEA,IAAIjD,KAAK,CAAC8C,GAAN,KAAc9H,IAAI,CAACyI,QAAvB,EAAiC;AACtChB,cAAAA,OAAO,CAACG,CAAR,IAAaK,IAAb;AACD,aAFM,MAEA,IAAIjD,KAAK,CAAC8C,GAAN,KAAc9H,IAAI,CAAC0I,UAAvB,EAAmC;AACxCjB,cAAAA,OAAO,CAACG,CAAR,IAAaK,IAAb;AACD;;AACD,mBAAOR,OAAP;AACD;;AACD,iBAAOW,EAAP;AACD,SAfU,CAAX;;AAgBA,cAAKvD,QAAL,CAAc,EAAd;;AACAG,QAAAA,KAAK,CAACI,cAAN;AACD,OAtBD,MAsBO,IACLjF,kBAAkB,CAACwI,QAAnB,CAA4B3D,KAAK,CAAC8C,GAAN,CAAUc,WAAV,EAA5B,KACA,CAAC5D,KAAK,CAAC6D,OADP,IAEA,CAAC7D,KAAK,CAAC8D,MAFP,IAGA,CAAC9D,KAAK,CAAC+D,OAHP,IAIA,MAAK7D,KAAL,CAAW8D,eAAX,KAA+B,IAL1B,EAML;AACA,cAAKC,eAAL,CAAqB1F,KAArB;AACD,OARM,MAQA,IAAIyB,KAAK,CAAC8C,GAAN,KAAc9H,IAAI,CAACkJ,KAAnB,IAA4BlG,OAAO,CAACC,QAAR,CAAiBkG,IAAjB,KAA0B,CAA1D,EAA6D;AAClE1G,QAAAA,cAAc,GAAG,IAAjB;AACAe,QAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GAAwCxC,WAAW,CAACiI,QAApD;AACD;AACF,KA3TuB;;AAAA,UA6ThBC,OA7TgB,GA6TN,UAACrE,KAAD,EAA0B;AAC1C,UAAIA,KAAK,CAAC8C,GAAN,KAAc9H,IAAI,CAACkJ,KAAvB,EAA8B;AAC5B,YAAI,MAAKhE,KAAL,CAAWoE,WAAX,KAA2B,WAA/B,EAA4C;AAC1CzJ,UAAAA,WAAW;AACZ,SAFD,MAEO;AACL2D,UAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GACE,MAAKuB,KAAL,CAAWoE,WAAX,KAA2B,MAA3B,GACInI,WAAW,CAACyC,IADhB,GAEIzC,WAAW,CAAC0C,SAHlB;;AAIA,gBAAKgB,QAAL,CAAc;AAAEwD,YAAAA,kBAAkB,EAAE;AAAtB,WAAd;AACD;;AACD5F,QAAAA,cAAc,GAAG,KAAjB;AACD;AACF,KA1UuB;;AAAA,UA4UhB7B,kBA5UgB,GA4UK,YAAM;AACjCA,MAAAA,kBAAkB,CAACsB,QAAD,EAAW,MAAKgD,KAAhB,CAAlB;AACD,KA9UuB;;AAAA,UAgVhBqE,kBAhVgB;AAAA;AAAA;AAAA;AAAA;AAAA,+BAgVK,kBAAOvE,KAAP;AAAA;;AAAA;AAAA;AAAA;AAAA;AAC3B;AACMC,gBAAAA,MAFqB,GAEZzB,QAAQ,CAACgG,aAFG;AAGrBC,gBAAAA,kBAHqB,GAGAjG,QAAQ,CAACkG,gBAAT,CAA0BnH,OAA1B,EAAmCC,OAAnC,CAHA;;AAAA,uBAKzB;AACA;AACA,iBAACwC,KAAD,IACCyE,kBAAkB,YAAYE,iBAA9B,IACC,CAACpK,iBAAiB,CAAC0F,MAAD,CATK;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAWNpE,mBAAmB,CAACmE,KAAD,CAXb;;AAAA;AAWnB+B,gBAAAA,IAXmB;;AAYzB,oBAAIA,IAAI,CAAC7E,QAAT,EAAmB;AACjB,wBAAK0H,oBAAL,CAA0B7C,IAAI,CAAC7E,QAA/B;AACD,iBAFD,MAEO,IAAI6E,IAAI,CAAC8C,IAAT,EAAe;AAAA,0CACH/J,2BAA2B,CAC1C;AAAEgK,oBAAAA,OAAO,EAAEvH,OAAX;AAAoBwH,oBAAAA,OAAO,EAAEvH;AAA7B,mBAD0C,EAE1C,MAAK0C,KAFqC,EAG1C,MAAKlB,MAHqC,CADxB,EACZ2D,CADY,yBACZA,CADY,EACTC,CADS,yBACTA,CADS;AAOdH,kBAAAA,OAPc,GAOJ7J,cAAc,CAC5BD,UAAU,CACR,MADQ,EAERgK,CAFQ,EAGRC,CAHQ,EAIR,MAAK1C,KAAL,CAAW8E,sBAJH,EAKR,MAAK9E,KAAL,CAAW+E,0BALH,EAMR,MAAK/E,KAAL,CAAWgF,oBANH,EAOR,MAAKhF,KAAL,CAAWiF,sBAPH,EAQR,MAAKjF,KAAL,CAAWkF,oBARH,EASR,MAAKlF,KAAL,CAAWmF,kBATH,CADkB,EAY5BtD,IAAI,CAAC8C,IAZuB,EAa5B,MAAK3E,KAAL,CAAWoF,eAbiB,CAPV;AAuBpBpI,kBAAAA,QAAQ,gCAAOA,QAAP,IAAiBuF,OAAjB,EAAR;;AACA,wBAAK5C,QAAL,CAAc;AAAEwD,oBAAAA,kBAAkB,sBAAKZ,OAAO,CAACa,EAAb,EAAkB,IAAlB;AAApB,mBAAd;;AACAhG,kBAAAA,OAAO,CAACsC,eAAR;AACD;;AACD,sBAAKqE,eAAL,CAAqB,WAArB;;AACAjE,gBAAAA,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEI,cAAP;;AA1CyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAhVL;;AAAA;AAAA;AAAA;AAAA;;AAAA,UA4YhBmF,cA5YgB,GA4YC,UAACvF,KAAD,EAAyB;AAChDA,MAAAA,KAAK,CAACI,cAAN;AACApC,MAAAA,OAAO,CAACK,YAAR,GAAuB,MAAK6B,KAAL,CAAWsF,IAAlC;AACD,KA/YuB;;AAAA,UAgZhBC,eAhZgB,GAgZE,UAACzF,KAAD,EAAyB;AACjDA,MAAAA,KAAK,CAACI,cAAN;;AAEA,YAAKP,QAAL,CAAc;AACZ2F,QAAAA,IAAI,EAAE5L,iBAAiB,CAACoE,OAAO,CAACK,YAAR,GAAwB2B,KAAK,CAAC0F,KAA/B;AADX,OAAd;AAGD,KAtZuB;;AAAA,UAuZhBC,YAvZgB,GAuZD,UAAC3F,KAAD,EAAyB;AAC9CA,MAAAA,KAAK,CAACI,cAAN;AACApC,MAAAA,OAAO,CAACK,YAAR,GAAuB,IAAvB;AACD,KA1ZuB;;AAAA,UA4ZxBuH,WA5ZwB,GA4ZV,UAACC,GAAD,EAAc;AAC1B,YAAKhG,QAAL,CAAcgG,GAAd;AACD,KA9ZuB;;AAAA,UAgaxBC,WAhawB,GAgaV,UAACC,SAAD,EAA6C;AACzD7I,MAAAA,QAAQ,GAAG6I,SAAX;;AACA,YAAKlG,QAAL,CAAc,EAAd;AACD,KAnauB;;AAAA,UAqaxBmG,aArawB,GAqaR,UAAChG,KAAD,EAA4C;AAC1DhC,MAAAA,OAAO,CAACC,QAAR,CAAiBgI,MAAjB,CAAwBjG,KAAK,CAACkG,SAA9B;AACD,KAvauB;;AAAA,UAwiBhBC,uBAxiBgB,GAwiBU,UAChCnG,KADgC,EAE7B;AACHnF,MAAAA,WAAW;;AADR,mCAGcC,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CAHzC;AAAA,UAGK2D,CAHL,0BAGKA,CAHL;AAAA,UAGQC,CAHR,0BAGQA,CAHR;;AASH,UAAMwD,iBAAiB,GAAG3M,oBAAoB,CAC5CyD,QAD4C,EAE5C,MAAKgD,KAFuC,EAG5CyC,CAH4C,EAI5CC,CAJ4C,EAK5C,MAAK1C,KAAL,CAAWsF,IALiC,CAA9C;AAQA,UAAM/C,OAAO,GACX2D,iBAAiB,IAAIpN,aAAa,CAACoN,iBAAD,CAAlC,GACIA,iBADJ,GAEIxN,cAAc,CACZD,UAAU,CACR,MADQ,EAERgK,CAFQ,EAGRC,CAHQ,EAIR,MAAK1C,KAAL,CAAW8E,sBAJH,EAKR,MAAK9E,KAAL,CAAW+E,0BALH,EAMR,MAAK/E,KAAL,CAAWgF,oBANH,EAOR,MAAKhF,KAAL,CAAWiF,sBAPH,EAQR,MAAKjF,KAAL,CAAWkF,oBARH,EASR,MAAKlF,KAAL,CAAWmF,kBATH,CADE,EAYZ,EAZY,EAYR;AACJ,YAAKnF,KAAL,CAAWoF,eAbC,CAagB;AAbhB,OAHpB;;AAmBA,YAAKzF,QAAL,CAAc;AAAEwG,QAAAA,cAAc,EAAE5D;AAAlB,OAAd;;AAEA,UAAI6D,KAAK,GAAGtG,KAAK,CAAC8E,OAAlB;AACA,UAAIyB,KAAK,GAAGvG,KAAK,CAAC+E,OAAlB;;AAEA,UAAIqB,iBAAiB,IAAIpN,aAAa,CAACoN,iBAAD,CAAtC,EAA2D;AACzDlJ,QAAAA,QAAQ,GAAGA,QAAQ,CAACsJ,MAAT,CACT,UAAA/D,OAAO;AAAA,iBAAIA,OAAO,CAACa,EAAR,KAAe8C,iBAAiB,CAAC9C,EAArC;AAAA,SADE,CAAX;;AAGA,cAAKzD,QAAL,CAAc,EAAd;;AAEA,YAAM4G,cAAc,GAAGL,iBAAiB,CAACzD,CAAlB,GAAsByD,iBAAiB,CAACM,KAAlB,GAA0B,CAAvE;AACA,YAAMC,cAAc,GAAGP,iBAAiB,CAACxD,CAAlB,GAAsBwD,iBAAiB,CAACQ,MAAlB,GAA2B,CAAxE;;AAPyD,oCAYrD7L,2BAA2B,CAC7B;AAAE8L,UAAAA,MAAM,EAAEJ,cAAV;AAA0BK,UAAAA,MAAM,EAAEH;AAAlC,SAD6B,EAE7B,MAAKzG,KAFwB,EAG7B,MAAKlB,MAHwB,CAZ0B;AAAA,YAUpD+H,wBAVoD,yBAUvDpE,CAVuD;AAAA,YAWpDqE,wBAXoD,yBAWvDpE,CAXuD;;AAkBzD0D,QAAAA,KAAK,GAAGS,wBAAR;AACAR,QAAAA,KAAK,GAAGS,wBAAR,CAnByD,CAqBzD;;AACAvE,QAAAA,OAAO,CAACE,CAAR,GAAY8D,cAAZ;AACAhE,QAAAA,OAAO,CAACG,CAAR,GAAY+D,cAAZ;AACD,OAxBD,MAwBO,IAAI,CAAC3G,KAAK,CAAC8D,MAAX,EAAmB;AACxB,YAAMmD,uBAAuB,GAAG,MAAKC,qCAAL,CAC9BvE,CAD8B,EAE9BC,CAF8B,CAAhC;;AAKA,YAAIqE,uBAAJ,EAA6B;AAC3BxE,UAAAA,OAAO,CAACE,CAAR,GAAYsE,uBAAuB,CAACE,cAApC;AACA1E,UAAAA,OAAO,CAACG,CAAR,GAAYqE,uBAAuB,CAACG,cAApC;AACAd,UAAAA,KAAK,GAAGW,uBAAuB,CAACI,QAAhC;AACAd,UAAAA,KAAK,GAAGU,uBAAuB,CAACK,QAAhC;AACD;AACF;;AAED,UAAMC,cAAc,GAAG,SAAjBA,cAAiB,GAAM;AAC3B,cAAK1H,QAAL,CAAc;AACZmE,UAAAA,eAAe,EAAE,IADL;AAEZqC,UAAAA,cAAc,EAAE;AAFJ,SAAd;AAID,OALD;;AAOApN,MAAAA,WAAW,CAAC;AACVuO,QAAAA,QAAQ,EAAE/E,OAAO,CAACoC,IADR;AAEVlC,QAAAA,CAAC,EAAE2D,KAFO;AAGV1D,QAAAA,CAAC,EAAE2D,KAHO;AAIVkB,QAAAA,WAAW,EAAEhF,OAAO,CAACgF,WAJX;AAKVC,QAAAA,IAAI,EAAEjF,OAAO,CAACiF,IALJ;AAMVC,QAAAA,OAAO,EAAE,MAAKzH,KAAL,CAAWmF,kBANV;AAOVG,QAAAA,IAAI,EAAE,MAAKtF,KAAL,CAAWsF,IAPP;AAQVoC,QAAAA,QAAQ,EAAE,kBAAA/C,IAAI,EAAI;AAChB,cAAIA,IAAJ,EAAU;AACR3H,YAAAA,QAAQ,gCACHA,QADG,sBAKDtE,cAAc,CAAC6J,OAAD,EAAUoC,IAAV,EAAgBpC,OAAO,CAACiF,IAAxB,CALb,GAAR;AAQD;;AACD,gBAAK7H,QAAL,CAAc,UAAAgI,SAAS;AAAA,mBAAK;AAC1BxE,cAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEfZ,OAAO,CAACa,EAFO,EAEF,IAFE;AADQ,aAAL;AAAA,WAAvB;;AAMAhG,UAAAA,OAAO,CAACsC,eAAR;AACA2H,UAAAA,cAAc;AACf,SA3BS;AA4BVO,QAAAA,QAAQ,EAAE,oBAAM;AACdP,UAAAA,cAAc;AACf;AA9BS,OAAD,CAAX;AAgCD,KAhqBuB;;AAAA,UAkqBhBQ,uBAlqBgB,GAkqBU,UAChC/H,KADgC,EAE7B;AACH,UAAM0B,aAAa,GAAG5G,2BAA2B,CAC/CkF,KAD+C,EAE/C,MAAKE,KAF0C,EAG/C,MAAKlB,MAH0C,CAAjD;;AAKA,YAAKgJ,WAAL,CAAiBtG,aAAjB;;AACA1D,MAAAA,OAAO,CAACC,QAAR,CAAiBgK,GAAjB,CAAqBjI,KAAK,CAACkG,SAA3B,EAAsC;AACpCvD,QAAAA,CAAC,EAAE3C,KAAK,CAAC8E,OAD2B;AAEpClC,QAAAA,CAAC,EAAE5C,KAAK,CAAC+E;AAF2B,OAAtC;;AAKA,UAAI/G,OAAO,CAACC,QAAR,CAAiBkG,IAAjB,KAA0B,CAA9B,EAAiC;AAC/B,YAAM+D,MAAM,GAAGnM,SAAS,CAACiC,OAAO,CAACC,QAAT,CAAxB;;AACA,YAAMkK,OAAM,GAAGD,MAAM,CAACvF,CAAP,GAAW3E,OAAO,CAACG,UAAR,CAAoBwE,CAA9C;;AACA,YAAMyF,OAAM,GAAGF,MAAM,CAACtF,CAAP,GAAW5E,OAAO,CAACG,UAAR,CAAoByE,CAA9C;;AACA5E,QAAAA,OAAO,CAACG,UAAR,GAAqB+J,MAArB;;AAEA,YAAMvN,SAAQ,GAAGqB,WAAW,CAACqM,KAAK,CAACC,IAAN,CAAWtK,OAAO,CAACC,QAAR,CAAiBsK,MAAjB,EAAX,CAAD,CAA5B;;AACA,YAAMC,WAAW,GAAG7N,SAAQ,GAAGqD,OAAO,CAACI,eAAvC;;AAEA,cAAKyB,QAAL,CAAc;AACZ4I,UAAAA,OAAO,EAAE3M,eAAe,CAAC,MAAKoE,KAAL,CAAWuI,OAAX,GAAqBN,OAAM,GAAG,MAAKjI,KAAL,CAAWsF,IAA1C,CADZ;AAEZkD,UAAAA,OAAO,EAAE5M,eAAe,CAAC,MAAKoE,KAAL,CAAWwI,OAAX,GAAqBN,OAAM,GAAG,MAAKlI,KAAL,CAAWsF,IAA1C,CAFZ;AAGZA,UAAAA,IAAI,EAAE5L,iBAAiB,CAACoE,OAAO,CAACK,YAAR,GAAwBmK,WAAzB;AAHX,SAAd;AAKD,OAdD,MAcO;AACLxK,QAAAA,OAAO,CAACG,UAAR,GAAqBH,OAAO,CAACI,eAAR,GAA0BJ,OAAO,CAACK,YAAR,GAAuB,IAAtE;AACD;;AAED,UAAIZ,cAAc,IAAIC,SAAlB,IAA+BC,mBAAnC,EAAwD;AACtD;AACD;;AAhCE,8BAoCCnE,gBAAgB,CAACoE,iBAAD,EAAoBoC,KAAK,CAAC8E,OAA1B,EAAmC9E,KAAK,CAAC+E,OAAzC,CApCjB;AAAA,UAkCD4D,yBAlCC,qBAkCDA,yBAlCC;AAAA,UAmCDC,uBAnCC,qBAmCDA,uBAnCC;;AAqCH,UAAMC,eAAe,GACnBD,uBAAuB,IAAID,yBAD7B;;AAEA,UAAI,CAAC,MAAKzI,KAAL,CAAW8D,eAAZ,IAA+B,CAAC,MAAK9D,KAAL,CAAW4I,YAA/C,EAA6D;AAC3D,YAAID,eAAJ,EAAqB;AACnBhO,UAAAA,WAAW;AACZ,SAFD,MAEO;AACLyD,UAAAA,iBAAiB,CAAC,MAAK4B,KAAL,CAAWoE,WAAZ,CAAjB;AACD;AACF;;AA7CE,mCA+CcxJ,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CA/CzC;AAAA,UA+CK2D,CA/CL,0BA+CKA,CA/CL;AAAA,UA+CQC,CA/CR,0BA+CQA,CA/CR;;AAoDH,UAAI,MAAK1C,KAAL,CAAW4I,YAAf,EAA6B;AAAA,YACnBA,YADmB,GACF,MAAK5I,KADH,CACnB4I,YADmB;AAE3B,YAAMC,OAAO,GAAGD,YAAY,CAACnG,CAA7B;AACA,YAAMqG,OAAO,GAAGF,YAAY,CAAClG,CAA7B;AACA,YAAMqG,MAAM,GAAGH,YAAY,CAACG,MAA5B;AACA,YAAMC,GAAG,GAAGD,MAAM,CAACA,MAAM,CAACE,MAAP,GAAgB,CAAjB,CAAlB;AACAD,QAAAA,GAAG,CAAC,CAAD,CAAH,GAASvG,CAAC,GAAGoG,OAAb;AACAG,QAAAA,GAAG,CAAC,CAAD,CAAH,GAAStG,CAAC,GAAGoG,OAAb;AACAtM,QAAAA,yBAAyB,CAACoM,YAAD,CAAzB;;AACA,cAAKjJ,QAAL,CAAc,EAAd;;AACA;AACD;;AAED,UAAMuJ,mBAAmB,GAAGC,OAAO,CAACrJ,KAAK,CAACsJ,OAAP,CAAnC;;AACA,UAAIF,mBAAmB,IAAI,MAAKlJ,KAAL,CAAWoE,WAAX,KAA2B,WAAtD,EAAmE;AACjE;AACD;;AAED,UAAMiF,gBAAgB,GAAG1P,mBAAmB,CAACqD,QAAD,EAAW,MAAKgD,KAAhB,CAA5C;;AACA,UAAIqJ,gBAAgB,CAACJ,MAAjB,KAA4B,CAA5B,IAAiC,CAACN,eAAtC,EAAuD;AACrD,YAAMW,aAAa,GAAGlO,2BAA2B,CAC/C4B,QAD+C,EAE/C,MAAKgD,KAF0C,EAG/C;AAAEyC,UAAAA,CAAC,EAADA,CAAF;AAAKC,UAAAA,CAAC,EAADA;AAAL,SAH+C,EAI/C,MAAK1C,KAAL,CAAWsF,IAJoC,EAK/CxF,KAAK,CAACyJ,WALyC,CAAjD;;AAOA,YAAID,aAAa,IAAIA,aAAa,CAACE,YAAnC,EAAiD;AAC/ClL,UAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GAAwCxF,2BAA2B,CACjEqQ,aADiE,CAAnE;AAGA;AACD;AACF;;AACD,UAAMG,UAAU,GAAGlQ,oBAAoB,CACrCyD,QADqC,EAErC,MAAKgD,KAFgC,EAGrCyC,CAHqC,EAIrCC,CAJqC,EAKrC,MAAK1C,KAAL,CAAWsF,IAL0B,CAAvC;AAOAhH,MAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GACEgL,UAAU,IAAI,CAACd,eAAf,GAAiC,MAAjC,GAA0C,EAD5C;AAED,KAnwBuB;;AAAA,UAqwBhBe,uBArwBgB,GAqwBU,UAChC5J,KADgC,EAE7B;AACH,UAAIjC,cAAa,KAAK,IAAtB,EAA4B;AAC1B;AACA;AACA;AACAA,QAAAA,cAAa,CAACiC,KAAD,CAAb;AACD;;AAED,UAAItC,SAAJ,EAAe;AACb;AACD;;AAED,YAAKmC,QAAL,CAAc;AAAEgK,QAAAA,mBAAmB,EAAE7J,KAAK,CAACyJ;AAA7B,OAAd,EAZG,CAcH;;;AACA,UACEzL,OAAO,CAACC,QAAR,CAAiBkG,IAAjB,KAA0B,CAA1B,KACCnE,KAAK,CAAC8J,MAAN,KAAiBxN,cAAc,CAACyN,KAAhC,IACE/J,KAAK,CAAC8J,MAAN,KAAiBxN,cAAc,CAAC0N,IAAhC,IAAwCvM,cAF3C,CADF,EAIE;AACAC,QAAAA,SAAS,GAAG,IAAZ;AACAc,QAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GAAwCxC,WAAW,CAACiI,QAApD;AAFA,YAGe6F,MAHf,GAGyCjK,KAHzC,CAGM8E,OAHN;AAAA,YAG+BoF,MAH/B,GAGyClK,KAHzC,CAGsB+E,OAHtB;;AAIA,YAAMoF,cAAa,GAAG,SAAhBA,cAAgB,CAACnK,KAAD,EAAyB;AAC7C,cAAMmI,MAAM,GAAG8B,MAAK,GAAGjK,KAAK,CAAC8E,OAA7B;AACA,cAAMsD,MAAM,GAAG8B,MAAK,GAAGlK,KAAK,CAAC+E,OAA7B;AACAkF,UAAAA,MAAK,GAAGjK,KAAK,CAAC8E,OAAd;AACAoF,UAAAA,MAAK,GAAGlK,KAAK,CAAC+E,OAAd;;AAEA,gBAAKlF,QAAL,CAAc;AACZ4I,YAAAA,OAAO,EAAE3M,eAAe,CACtB,MAAKoE,KAAL,CAAWuI,OAAX,GAAqBN,MAAM,GAAG,MAAKjI,KAAL,CAAWsF,IADnB,CADZ;AAIZkD,YAAAA,OAAO,EAAE5M,eAAe,CACtB,MAAKoE,KAAL,CAAWwI,OAAX,GAAqBN,MAAM,GAAG,MAAKlI,KAAL,CAAWsF,IADnB;AAJZ,WAAd;AAQD,SAdD;;AAeA,YAAM4E,QAAQ,GAAIrM,cAAa,GAAG,yBAAM;AACtCA,UAAAA,cAAa,GAAG,IAAhB;AACAL,UAAAA,SAAS,GAAG,KAAZ;;AACA,cAAI,CAACD,cAAL,EAAqB;AACnBa,YAAAA,iBAAiB,CAAC,MAAK4B,KAAL,CAAWoE,WAAZ,CAAjB;AACD;;AACDtH,UAAAA,MAAM,CAACqN,mBAAP,CAA2B,aAA3B,EAA0CF,cAA1C;AACAnN,UAAAA,MAAM,CAACqN,mBAAP,CAA2B,WAA3B,EAAwCD,QAAxC;AACApN,UAAAA,MAAM,CAACqN,mBAAP,CAA2B,MAA3B,EAAmCD,QAAnC;AACD,SATD;;AAUApN,QAAAA,MAAM,CAACsN,gBAAP,CAAwB,MAAxB,EAAgCF,QAAhC;AACApN,QAAAA,MAAM,CAACsN,gBAAP,CAAwB,aAAxB,EAAuCH,cAAvC,EAAsD;AACpDI,UAAAA,OAAO,EAAE;AAD2C,SAAtD;AAGAvN,QAAAA,MAAM,CAACsN,gBAAP,CAAwB,WAAxB,EAAqCF,QAArC;AACA;AACD,OAtDE,CAwDH;;;AACA,UACEpK,KAAK,CAAC8J,MAAN,KAAiBxN,cAAc,CAAC0N,IAAhC,IACAhK,KAAK,CAAC8J,MAAN,KAAiBxN,cAAc,CAACkO,KAFlC,EAGE;AACA;AACD;;AAEDxM,MAAAA,OAAO,CAACC,QAAR,CAAiBgK,GAAjB,CAAqBjI,KAAK,CAACkG,SAA3B,EAAsC;AACpCvD,QAAAA,CAAC,EAAE3C,KAAK,CAAC8E,OAD2B;AAEpClC,QAAAA,CAAC,EAAE5C,KAAK,CAAC+E;AAF2B,OAAtC;;AAKA,UAAI/G,OAAO,CAACC,QAAR,CAAiBkG,IAAjB,KAA0B,CAA9B,EAAiC;AAC/BnG,QAAAA,OAAO,CAACG,UAAR,GAAqBpC,SAAS,CAACiC,OAAO,CAACC,QAAT,CAA9B;AACAD,QAAAA,OAAO,CAACK,YAAR,GAAuB,MAAK6B,KAAL,CAAWsF,IAAlC;AACAxH,QAAAA,OAAO,CAACI,eAAR,GAA0BpC,WAAW,CACnCqM,KAAK,CAACC,IAAN,CAAWtK,OAAO,CAACC,QAAR,CAAiBsK,MAAjB,EAAX,CADmC,CAArC;AAGD,OA3EE,CA6EH;;;AACAvI,MAAAA,KAAK,CAACI,cAAN,GA9EG,CA+EH;AACA;AACA;;AACA,UAAI5B,QAAQ,CAACgG,aAAT,YAAkCiG,WAAtC,EAAmD;AACjDjM,QAAAA,QAAQ,CAACgG,aAAT,CAAuBkG,IAAvB;AACD,OApFE,CAsFH;;;AACA,UAAI1M,OAAO,CAACC,QAAR,CAAiBkG,IAAjB,GAAwB,CAA5B,EAA+B;AAC7B;AACD,OAzFE,CA2FH;;;AA3FG,+BA+FC3K,gBAAgB,CAACoE,iBAAD,EAAoBoC,KAAK,CAAC8E,OAA1B,EAAmC9E,KAAK,CAAC+E,OAAzC,CA/FjB;AAAA,UA6FD4D,yBA7FC,sBA6FDA,yBA7FC;AAAA,UA8FDC,uBA9FC,sBA8FDA,uBA9FC;;AAAA,mCAiGc9N,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CAjGzC;AAAA,UAiGK2D,CAjGL,0BAiGKA,CAjGL;AAAA,UAiGQC,CAjGR,0BAiGQA,CAjGR;;AAsGH,UAAIqH,KAAK,GAAGtH,CAAZ;AACA,UAAIuH,KAAK,GAAGtH,CAAZ;;AAEA,UACE,CAAC+F,yBAAyB,IAAIC,uBAA9B,KACA,CAAC,MAAK1I,KAAL,CAAW4I,YAFd,EAGE;AACAnL,QAAAA,mBAAmB,GAAG,IAAtB;AACAsM,QAAAA,KAAK,GAAGjK,KAAK,CAAC8E,OAAd;AACAoF,QAAAA,KAAK,GAAGlK,KAAK,CAAC+E,OAAd;;AACA,YAAMoF,eAAa,GAAG,SAAhBA,eAAgB,CAACnK,KAAD,EAAyB;AAC7C,cAAMC,MAAM,GAAGD,KAAK,CAACC,MAArB;;AACA,cAAI,EAAEA,MAAM,YAAYwK,WAApB,CAAJ,EAAsC;AACpC;AACD;;AAED,cAAI9B,yBAAJ,EAA+B;AAC7B,gBAAMhG,GAAC,GAAG3C,KAAK,CAAC8E,OAAhB;AACA,gBAAM6F,EAAE,GAAGhI,GAAC,GAAGsH,KAAf;;AACA,kBAAKpK,QAAL,CAAc;AACZ4I,cAAAA,OAAO,EAAE3M,eAAe,CAAC,MAAKoE,KAAL,CAAWuI,OAAX,GAAqBkC,EAAE,GAAG,MAAKzK,KAAL,CAAWsF,IAAtC;AADZ,aAAd;;AAGAyE,YAAAA,KAAK,GAAGtH,GAAR;AACA;AACD;;AAED,cAAIiG,uBAAJ,EAA6B;AAC3B,gBAAMhG,EAAC,GAAG5C,KAAK,CAAC+E,OAAhB;AACA,gBAAM6F,EAAE,GAAGhI,EAAC,GAAGsH,KAAf;;AACA,kBAAKrK,QAAL,CAAc;AACZ6I,cAAAA,OAAO,EAAE5M,eAAe,CAAC,MAAKoE,KAAL,CAAWwI,OAAX,GAAqBkC,EAAE,GAAG,MAAK1K,KAAL,CAAWsF,IAAtC;AADZ,aAAd;;AAGA0E,YAAAA,KAAK,GAAGtH,EAAR;AACD;AACF,SAxBD;;AA0BA,YAAMiI,YAAW,GAAG,SAAdA,YAAc,GAAM;AACxBlN,UAAAA,mBAAmB,GAAG,KAAtB;AACAW,UAAAA,iBAAiB,CAAC,MAAK4B,KAAL,CAAWoE,WAAZ,CAAjB;AACAvG,UAAAA,cAAa,GAAG,IAAhB;AACAf,UAAAA,MAAM,CAACqN,mBAAP,CAA2B,aAA3B,EAA0CF,eAA1C;AACAnN,UAAAA,MAAM,CAACqN,mBAAP,CAA2B,WAA3B,EAAwCQ,YAAxC;AACD,SAND;;AAQA9M,QAAAA,cAAa,GAAG8M,YAAhB;AAEA7N,QAAAA,MAAM,CAACsN,gBAAP,CAAwB,aAAxB,EAAuCH,eAAvC;AACAnN,QAAAA,MAAM,CAACsN,gBAAP,CAAwB,WAAxB,EAAqCO,YAArC;AACA;AACD;;AAED,UAAM9B,OAAO,GAAGpG,CAAhB;AACA,UAAMqG,OAAO,GAAGpG,CAAhB;AAEA,UAAIH,OAAO,GAAG9J,UAAU,CACtB,MAAKuH,KAAL,CAAWoE,WADW,EAEtB3B,CAFsB,EAGtBC,CAHsB,EAItB,MAAK1C,KAAL,CAAW8E,sBAJW,EAKtB,MAAK9E,KAAL,CAAW+E,0BALW,EAMtB,MAAK/E,KAAL,CAAWgF,oBANW,EAOtB,MAAKhF,KAAL,CAAWiF,sBAPW,EAQtB,MAAKjF,KAAL,CAAWkF,oBARW,EAStB,MAAKlF,KAAL,CAAWmF,kBATW,CAAxB;;AAYA,UAAIrM,aAAa,CAACyJ,OAAD,CAAjB,EAA4B;AAC1BA,QAAAA,OAAO,GAAG7J,cAAc,CAAC6J,OAAD,EAAU,EAAV,EAAc,MAAKvC,KAAL,CAAWoF,eAAzB,CAAxB;AACD;;AAGD,UAAIoE,YAA4B,GAAG,KAAnC;AACA,UAAIoB,kBAAkB,GAAG,KAAzB;AACA,UAAIC,gBAAgB,GAAG,KAAvB;AACA,UAAIpB,UAAoC,GAAG,IAA3C;AACA,UAAIqB,yBAAyB,GAAG,KAAhC;;AACA,UAAI,MAAK9K,KAAL,CAAWoE,WAAX,KAA2B,WAA/B,EAA4C;AAC1C,YAAMkF,aAAa,GAAGlO,2BAA2B,CAC/C4B,QAD+C,EAE/C,MAAKgD,KAF0C,EAG/C;AAAEyC,UAAAA,CAAC,EAADA,CAAF;AAAKC,UAAAA,CAAC,EAADA;AAAL,SAH+C,EAI/C,MAAK1C,KAAL,CAAWsF,IAJoC,EAK/CxF,KAAK,CAACyJ,WALyC,CAAjD;AAQA,YAAMF,gBAAgB,GAAG1P,mBAAmB,CAACqD,QAAD,EAAW,MAAKgD,KAAhB,CAA5C;;AACA,YAAIqJ,gBAAgB,CAACJ,MAAjB,KAA4B,CAA5B,IAAiCK,aAArC,EAAoD;AAClD,gBAAK3J,QAAL,CAAc;AACZoL,YAAAA,eAAe,EAAEzB,aAAa,GAAGA,aAAa,CAAC/G,OAAjB,GAA2B;AAD7C,WAAd;;AAIAiH,UAAAA,YAAY,GAAGF,aAAa,CAACE,YAA7B;AACAlL,UAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GAAwCxF,2BAA2B,CACjEqQ,aADiE,CAAnE;AAGAsB,UAAAA,kBAAkB,GAAG,IAArB;AACD,SAVD,MAUO;AACLnB,UAAAA,UAAU,GAAGlQ,oBAAoB,CAC/ByD,QAD+B,EAE/B,MAAKgD,KAF0B,EAG/ByC,CAH+B,EAI/BC,CAJ+B,EAK/B,MAAK1C,KAAL,CAAWsF,IALoB,CAAjC,CADK,CAQL;;AACA,cACE,EAAEmE,UAAU,IAAI,MAAKzJ,KAAL,CAAWmD,kBAAX,CAA8BsG,UAAU,CAACrG,EAAzC,CAAhB,KACA,CAACtD,KAAK,CAACkD,QAFT,EAGE;AACA,kBAAKrD,QAAL,CAAc;AAAEwD,cAAAA,kBAAkB,EAAE;AAAtB,aAAd;AACD,WAdI,CAgBL;;;AACA,cAAIsG,UAAJ,EAAgB;AACd;AACA;AACA;AACA;AACA,gBAAI,CAAC,MAAKzJ,KAAL,CAAWmD,kBAAX,CAA8BsG,UAAU,CAACrG,EAAzC,CAAL,EAAmD;AACjD,oBAAKzD,QAAL,CAAc,UAAAgI,SAAS;AAAA,uBAAK;AAC1BxE,kBAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEfsG,UAAU,CAAErG,EAFG,EAEE,IAFF;AADQ,iBAAL;AAAA,eAAvB;;AAMApG,cAAAA,QAAQ,GAAGA,QAAQ,CAACgO,KAAT,EAAX;AACAF,cAAAA,yBAAyB,GAAG,IAA5B;AACD,aAda,CAgBd;;;AACA,gBAAIhL,KAAK,CAAC8D,MAAV,EAAkB;AAChB;AACA;AACA,kBAAM3D,YAAY,GAAG,EAArB;AACA,kBAAMgL,gBAAgB,GAAG,EAAzB;AAJgB;AAAA;AAAA;;AAAA;AAKhB,qCAAsBjO,QAAtB,8HAAgC;AAAA,sBAArBuF,QAAqB;;AAC9B,sBAAI,MAAKvC,KAAL,CAAWmD,kBAAX,CAA8BZ,QAAO,CAACa,EAAtC,CAAJ,EAA+C;AAC7CnD,oBAAAA,YAAY,CAACiL,IAAb,CAAkBvS,gBAAgB,CAAC4J,QAAD,CAAlC;AACA0I,oBAAAA,gBAAgB,CAACC,IAAjB,CAAsB3I,QAAtB;AACD,mBAHD,MAGO;AACLtC,oBAAAA,YAAY,CAACiL,IAAb,CAAkB3I,QAAlB;AACD;AACF;AAZe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAahBvF,cAAAA,QAAQ,aAAOiD,YAAP,EAAwBgL,gBAAxB,CAAR;AACD;AACF;AACF;AACF,OAvED,MAuEO;AACL,cAAKtL,QAAL,CAAc;AAAEwD,UAAAA,kBAAkB,EAAE;AAAtB,SAAd;AACD;;AAED,UAAIrK,aAAa,CAACyJ,OAAD,CAAjB,EAA4B;AAAA;;AAC1B;AACA;AACA;AACA,YAAI,gCAAKvC,KAAL,CAAWmG,cAAX,gFAA2BlF,IAA3B,MAAoC,MAAxC,EAAgD;AAC9C;AACD;;AACD,YAAI6J,yBAAJ,EAA+B;AAC7BvI,UAAAA,OAAO,GAAGkH,UAAV;AACD;;AACD,YAAIrD,KAAK,GAAGtG,KAAK,CAAC8E,OAAlB;AACA,YAAIyB,KAAK,GAAGvG,KAAK,CAAC+E,OAAlB;;AACA,YAAI,CAAC/E,KAAK,CAAC8D,MAAX,EAAmB;AACjB,cAAMmD,uBAAuB,GAAG,MAAKC,qCAAL,CAC9BvE,CAD8B,EAE9BC,CAF8B,CAAhC;;AAIA,cAAIqE,uBAAJ,EAA6B;AAC3BxE,YAAAA,OAAO,CAACE,CAAR,GAAYsE,uBAAuB,CAACE,cAApC;AACA1E,YAAAA,OAAO,CAACG,CAAR,GAAYqE,uBAAuB,CAACG,cAApC;AACAd,YAAAA,KAAK,GAAGW,uBAAuB,CAACI,QAAhC;AACAd,YAAAA,KAAK,GAAGU,uBAAuB,CAACK,QAAhC;AACD;AACF;;AAED,YAAMC,cAAc,GAAG,SAAjBA,cAAiB,GAAM;AAC3B,gBAAK1H,QAAL,CAAc;AACZmE,YAAAA,eAAe,EAAE,IADL;AAEZqC,YAAAA,cAAc,EAAE;AAFJ,WAAd;AAID,SALD;;AAOApN,QAAAA,WAAW,CAAC;AACVuO,UAAAA,QAAQ,EAAE,EADA;AAEV7E,UAAAA,CAAC,EAAE2D,KAFO;AAGV1D,UAAAA,CAAC,EAAE2D,KAHO;AAIVkB,UAAAA,WAAW,EAAE,MAAKvH,KAAL,CAAW8E,sBAJd;AAKV2C,UAAAA,OAAO,EAAE,MAAKzH,KAAL,CAAWmF,kBALV;AAMVqC,UAAAA,IAAI,EAAE,MAAKxH,KAAL,CAAWoF,eANP;AAOVE,UAAAA,IAAI,EAAE,MAAKtF,KAAL,CAAWsF,IAPP;AAQVoC,UAAAA,QAAQ,EAAE,kBAAA/C,IAAI,EAAI;AAChB,gBAAIA,IAAJ,EAAU;AACR3H,cAAAA,QAAQ,gCACHA,QADG,sBAGDtE,cAAc,CAAC6J,OAAD,EAAUoC,IAAV,EAAgB,MAAK3E,KAAL,CAAWoF,eAA3B,CAHb,GAAR;AAMD;;AACD,kBAAKzF,QAAL,CAAc,UAAAgI,SAAS;AAAA,qBAAK;AAC1BxE,gBAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEfZ,OAAO,CAACa,EAFO,EAEF,IAFE;AADQ,eAAL;AAAA,aAAvB;;AAMA,gBAAI,MAAKpD,KAAL,CAAWmL,aAAf,EAA8B;AAC5B/M,cAAAA,iBAAiB,CAAC,MAAK4B,KAAL,CAAWoE,WAAZ,CAAjB;AACD;;AACDhH,YAAAA,OAAO,CAACsC,eAAR;AACA2H,YAAAA,cAAc;AACf,WA5BS;AA6BVO,UAAAA,QAAQ,EAAE,oBAAM;AACdP,YAAAA,cAAc;AACf;AA/BS,SAAD,CAAX;AAiCA1M,QAAAA,WAAW;;AACX,YAAI,CAAC,MAAKqF,KAAL,CAAWmL,aAAhB,EAA+B;AAC7B,gBAAKxL,QAAL,CAAc;AACZwG,YAAAA,cAAc,EAAE5D,OADJ;AAEZ6B,YAAAA,WAAW,EAAE;AAFD,WAAd;AAID,SALD,MAKO;AACL,gBAAKzE,QAAL,CAAc;AACZwG,YAAAA,cAAc,EAAE5D;AADJ,WAAd;AAGD;;AACD;AACD,OA7ED,MA6EO,IACL,MAAKvC,KAAL,CAAWoE,WAAX,KAA2B,OAA3B,IACA,MAAKpE,KAAL,CAAWoE,WAAX,KAA2B,MAFtB,EAGL;AACA,YAAI,MAAKpE,KAAL,CAAW4I,YAAf,EAA6B;AAAA,cACnBA,YADmB,GACF,MAAK5I,KADH,CACnB4I,YADmB;AAAA,cAEhBwC,EAFgB,GAEFxC,YAFE,CAEnBnG,CAFmB;AAAA,cAET4I,EAFS,GAEFzC,YAFE,CAEZlG,CAFY;;AAG3B,gBAAK/C,QAAL,CAAc,UAAAgI,SAAS;AAAA,mBAAK;AAC1BxE,cAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEfyF,YAAY,CAACxF,EAFE,EAEG,IAFH;AADQ,aAAL;AAAA,WAAvB;;AAMAwF,UAAAA,YAAY,CAACG,MAAb,CAAoBmC,IAApB,CAAyB,CAACzI,CAAC,GAAG2I,EAAL,EAAS1I,CAAC,GAAG2I,EAAb,CAAzB;AACA7O,UAAAA,yBAAyB,CAACoM,YAAD,CAAzB;AACD,SAXD,MAWO;AACL,gBAAKjJ,QAAL,CAAc,UAAAgI,SAAS;AAAA,mBAAK;AAC1BxE,cAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEfZ,OAAO,CAACa,EAFO,EAEF,KAFE;AADQ,aAAL;AAAA,WAAvB;;AAMAb,UAAAA,OAAO,CAACwG,MAAR,CAAemC,IAAf,CAAoB,CAAC,CAAD,EAAI,CAAJ,CAApB;AACA1O,UAAAA,yBAAyB,CAAC+F,OAAD,CAAzB;AACAvF,UAAAA,QAAQ,gCAAOA,QAAP,IAAiBuF,OAAjB,EAAR;;AACA,gBAAK5C,QAAL,CAAc;AACZmE,YAAAA,eAAe,EAAEvB;AADL,WAAd;AAGD;AACF,OA7BM,MA6BA,IAAIA,OAAO,CAACtB,IAAR,KAAiB,WAArB,EAAkC;AACvC,cAAKtB,QAAL,CAAc;AACZ2L,UAAAA,gBAAgB,EAAE/I,OADN;AAEZuB,UAAAA,eAAe,EAAEvB;AAFL,SAAd;AAID,OALM,MAKA;AACLvF,QAAAA,QAAQ,gCAAOA,QAAP,IAAiBuF,OAAjB,EAAR;;AACA,cAAK5C,QAAL,CAAc;AAAEiJ,UAAAA,YAAY,EAAE,IAAhB;AAAsB9E,UAAAA,eAAe,EAAEvB;AAAvC,SAAd;AACD;;AAED,UAAIgJ,aAUI,GAAG,IAVX;;AAYA,UAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CACxBjJ,OADwB,EAExBkJ,EAFwB,EAGxBxD,MAHwB,EAIxBC,MAJwB,EAKxBwD,QALwB,EAMxBC,QANwB,EAOxBC,OAPwB,EAQrB;AACH,YAAIA,OAAJ,EAAa;AACX,cAAMC,KAAK,GAAGJ,EAAE,CAAC,CAAD,CAAF,GAAQlJ,OAAO,CAACE,CAA9B;AACA,cAAMqJ,KAAK,GAAGL,EAAE,CAAC,CAAD,CAAF,GAAQlJ,OAAO,CAACG,CAA9B;;AAFW,sCAIexJ,qBAAqB,CAC7CqJ,OAAO,CAACtB,IADqC,EAE7CyK,QAAQ,GAAGnJ,OAAO,CAACE,CAAnB,GAAuBgJ,EAAE,CAAC,CAAD,CAFoB,EAG7CE,QAAQ,GAAGpJ,OAAO,CAACG,CAAnB,GAAuB+I,EAAE,CAAC,CAAD,CAHoB,CAJpC;AAAA,cAIHjF,KAJG,yBAIHA,KAJG;AAAA,cAIIE,MAJJ,yBAIIA,MAJJ;;AAUX,cAAM+D,EAAE,GAAGlI,OAAO,CAACE,CAAR,GAAY+D,KAAZ,GAAoBiF,EAAE,CAAC,CAAD,CAAjC;AACA,cAAMf,EAAE,GAAGnI,OAAO,CAACG,CAAR,GAAYgE,MAAZ,GAAqB+E,EAAE,CAAC,CAAD,CAAlC;AACAlJ,UAAAA,OAAO,CAACE,CAAR,GAAYgI,EAAZ;AACAlI,UAAAA,OAAO,CAACG,CAAR,GAAYgI,EAAZ;AACAe,UAAAA,EAAE,CAAC,CAAD,CAAF,GAAQI,KAAK,GAAGtJ,OAAO,CAACE,CAAxB;AACAgJ,UAAAA,EAAE,CAAC,CAAD,CAAF,GAAQK,KAAK,GAAGvJ,OAAO,CAACG,CAAxB;AACD,SAhBD,MAgBO;AACLH,UAAAA,OAAO,CAACE,CAAR,IAAawF,MAAb;AACA1F,UAAAA,OAAO,CAACG,CAAR,IAAawF,MAAb;AACAuD,UAAAA,EAAE,CAAC,CAAD,CAAF,IAASxD,MAAT;AACAwD,UAAAA,EAAE,CAAC,CAAD,CAAF,IAASvD,MAAT;AACD;AACF,OA/BD;;AAiCA,UAAM6D,cAAc,GAAG,SAAjBA,cAAiB,CACrBxJ,OADqB,EAErBkJ,EAFqB,EAGrBxD,MAHqB,EAIrBC,MAJqB,EAKrBwD,QALqB,EAMrBC,QANqB,EAOrBC,OAPqB,EAQlB;AACH,YAAIA,OAAJ,EAAa;AAAA,uCACe1S,qBAAqB,CAC7CqJ,OAAO,CAACtB,IADqC,EAE7CyK,QAAQ,GAAGnJ,OAAO,CAACE,CAF0B,EAG7CkJ,QAAQ,GAAGpJ,OAAO,CAACG,CAH0B,CADpC;AAAA,cACH8D,KADG,0BACHA,KADG;AAAA,cACIE,MADJ,0BACIA,MADJ;;AAMX+E,UAAAA,EAAE,CAAC,CAAD,CAAF,GAAQjF,KAAR;AACAiF,UAAAA,EAAE,CAAC,CAAD,CAAF,GAAQ/E,MAAR;AACD,SARD,MAQO;AACL+E,UAAAA,EAAE,CAAC,CAAD,CAAF,IAASxD,MAAT;AACAwD,UAAAA,EAAE,CAAC,CAAD,CAAF,IAASvD,MAAT;AACD;AACF,OArBD;;AAuBA,UAAM+B,aAAa,GAAG,SAAhBA,aAAgB,CAACnK,KAAD,EAAyB;AAC7C,YAAMC,MAAM,GAAGD,KAAK,CAACC,MAArB;;AACA,YAAI,EAAEA,MAAM,YAAYwK,WAApB,CAAJ,EAAsC;AACpC;AACD;;AAED,YAAI9B,yBAAJ,EAA+B;AAC7B,cAAMhG,GAAC,GAAG3C,KAAK,CAAC8E,OAAhB;AACA,cAAM6F,EAAE,GAAGhI,GAAC,GAAGsH,KAAf;;AACA,gBAAKpK,QAAL,CAAc;AACZ4I,YAAAA,OAAO,EAAE3M,eAAe,CAAC,MAAKoE,KAAL,CAAWuI,OAAX,GAAqBkC,EAAE,GAAG,MAAKzK,KAAL,CAAWsF,IAAtC;AADZ,WAAd;;AAGAyE,UAAAA,KAAK,GAAGtH,GAAR;AACA;AACD;;AAED,YAAIiG,uBAAJ,EAA6B;AAC3B,cAAMhG,GAAC,GAAG5C,KAAK,CAAC+E,OAAhB;AACA,cAAM6F,EAAE,GAAGhI,GAAC,GAAGsH,KAAf;;AACA,gBAAKrK,QAAL,CAAc;AACZ6I,YAAAA,OAAO,EAAE5M,eAAe,CAAC,MAAKoE,KAAL,CAAWwI,OAAX,GAAqBkC,EAAE,GAAG,MAAK1K,KAAL,CAAWsF,IAAtC;AADZ,WAAd;;AAGA0E,UAAAA,KAAK,GAAGtH,GAAR;AACA;AACD,SAxB4C,CA0B7C;AACA;AACA;AACA;;;AACA,YACE,CAACmI,gBAAD,KACC,MAAK7K,KAAL,CAAWoE,WAAX,KAA2B,OAA3B,IACC,MAAKpE,KAAL,CAAWoE,WAAX,KAA2B,MAF7B,CADF,EAIE;AAAA,uCACiBxJ,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CAD5C;AAAA,cACQ2D,GADR,0BACQA,CADR;AAAA,cACWC,GADX,0BACWA,CADX;;AAMA,cAAIhI,UAAU,CAAC+H,GAAD,EAAIC,GAAJ,EAAOmG,OAAP,EAAgBC,OAAhB,CAAV,GAAqCzM,kBAAzC,EAA6D;AAC3D;AACD;AACF;;AAED,YAAIuO,kBAAkB,IAAI,MAAK5K,KAAL,CAAW+K,eAArC,EAAsD;AACpD,gBAAKpL,QAAL,CAAc;AAAEqM,YAAAA,UAAU,EAAE;AAAd,WAAd;;AACA,cAAM9I,EAAE,GAAG,MAAKlD,KAAL,CAAW+K,eAAtB;;AACA,cAAM1B,iBAAgB,GAAG1P,mBAAmB,CAACqD,QAAD,EAAW,MAAKgD,KAAhB,CAA5C;;AACA,cAAIqJ,iBAAgB,CAACJ,MAAjB,KAA4B,CAAhC,EAAmC;AAAA,yCAChBrO,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CADX;AAAA,gBACzB2D,GADyB,0BACzBA,CADyB;AAAA,gBACtBC,GADsB,0BACtBA,CADsB;;AAMjC,gBAAMuF,QAAM,GAAGxF,GAAC,GAAGsH,KAAnB;;AACA,gBAAM7B,QAAM,GAAGxF,GAAC,GAAGsH,KAAnB;;AACA,gBAAMzH,SAAO,GAAG8G,iBAAgB,CAAC,CAAD,CAAhC;;AACA,gBAAM4C,SAAQ,GAAG1J,SAAO,CAACtB,IAAR,KAAiB,MAAjB,IAA2BsB,SAAO,CAACtB,IAAR,KAAiB,OAA7D;;AACA,oBAAQuI,YAAR;AACE,mBAAK,IAAL;AACE,oBAAIyC,SAAQ,IAAI1J,SAAO,CAACwG,MAAR,CAAeE,MAAf,KAA0B,CAA1C,EAA6C;AAAA,wDAC5B1G,SAAO,CAACwG,MADoB;AAAA,sBAClC0C,EADkC;;AAG3C,sBAAI,CAACF,aAAL,EAAoB;AAClB,wBAAIE,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,IAAaA,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAzB,EAA4B;AAC1BF,sBAAAA,aAAa,GAAGQ,cAAhB;AACD,qBAFD,MAEO;AACLR,sBAAAA,aAAa,GAAGC,iBAAhB;AACD;AACF;;AACDD,kBAAAA,aAAa,CACXhJ,SADW,EAEXkJ,EAFW,EAGXxD,QAHW,EAIXC,QAJW,EAKXzF,GALW,EAMXC,GANW,EAOX5C,KAAK,CAACkD,QAPK,CAAb;AASD,iBAnBD,MAmBO;AACLT,kBAAAA,SAAO,CAACiE,KAAR,IAAiByB,QAAjB;AACA1F,kBAAAA,SAAO,CAACE,CAAR,IAAawF,QAAb;;AAEA,sBAAInI,KAAK,CAACkD,QAAV,EAAoB;AAClBT,oBAAAA,SAAO,CAACG,CAAR,IAAaH,SAAO,CAACmE,MAAR,GAAiBnE,SAAO,CAACiE,KAAtC;AACAjE,oBAAAA,SAAO,CAACmE,MAAR,GAAiBnE,SAAO,CAACiE,KAAzB;AACD,mBAHD,MAGO;AACLjE,oBAAAA,SAAO,CAACmE,MAAR,IAAkBwB,QAAlB;AACA3F,oBAAAA,SAAO,CAACG,CAAR,IAAawF,QAAb;AACD;AACF;;AACD;;AACF,mBAAK,IAAL;AACE,oBAAI+D,SAAQ,IAAI1J,SAAO,CAACwG,MAAR,CAAeE,MAAf,KAA0B,CAA1C,EAA6C;AAAA,yDAC5B1G,SAAO,CAACwG,MADoB;AAAA,sBAClC0C,GADkC;;AAE3C,sBAAI,CAACF,aAAL,EAAoB;AAClB,wBAAIE,GAAE,CAAC,CAAD,CAAF,IAAS,CAAb,EAAgB;AACdF,sBAAAA,aAAa,GAAGQ,cAAhB;AACD,qBAFD,MAEO;AACLR,sBAAAA,aAAa,GAAGC,iBAAhB;AACD;AACF;;AACDD,kBAAAA,aAAa,CACXhJ,SADW,EAEXkJ,GAFW,EAGXxD,QAHW,EAIXC,QAJW,EAKXzF,GALW,EAMXC,GANW,EAOX5C,KAAK,CAACkD,QAPK,CAAb;AASD,iBAlBD,MAkBO;AACLT,kBAAAA,SAAO,CAACiE,KAAR,IAAiByB,QAAjB;;AACA,sBAAInI,KAAK,CAACkD,QAAV,EAAoB;AAClBT,oBAAAA,SAAO,CAACG,CAAR,IAAaH,SAAO,CAACmE,MAAR,GAAiBnE,SAAO,CAACiE,KAAtC;AACAjE,oBAAAA,SAAO,CAACmE,MAAR,GAAiBnE,SAAO,CAACiE,KAAzB;AACD,mBAHD,MAGO;AACLjE,oBAAAA,SAAO,CAACmE,MAAR,IAAkBwB,QAAlB;AACA3F,oBAAAA,SAAO,CAACG,CAAR,IAAawF,QAAb;AACD;AACF;;AACD;;AACF,mBAAK,IAAL;AACE,oBAAI+D,SAAQ,IAAI1J,SAAO,CAACwG,MAAR,CAAeE,MAAf,KAA0B,CAA1C,EAA6C;AAAA,yDAC5B1G,SAAO,CAACwG,MADoB;AAAA,sBAClC0C,GADkC;;AAE3C,sBAAI,CAACF,aAAL,EAAoB;AAClB,wBAAIE,GAAE,CAAC,CAAD,CAAF,IAAS,CAAb,EAAgB;AACdF,sBAAAA,aAAa,GAAGQ,cAAhB;AACD,qBAFD,MAEO;AACLR,sBAAAA,aAAa,GAAGC,iBAAhB;AACD;AACF;;AACDD,kBAAAA,aAAa,CACXhJ,SADW,EAEXkJ,GAFW,EAGXxD,QAHW,EAIXC,QAJW,EAKXzF,GALW,EAMXC,GANW,EAOX5C,KAAK,CAACkD,QAPK,CAAb;AASD,iBAlBD,MAkBO;AACLT,kBAAAA,SAAO,CAACiE,KAAR,IAAiByB,QAAjB;AACA1F,kBAAAA,SAAO,CAACE,CAAR,IAAawF,QAAb;;AACA,sBAAInI,KAAK,CAACkD,QAAV,EAAoB;AAClBT,oBAAAA,SAAO,CAACmE,MAAR,GAAiBnE,SAAO,CAACiE,KAAzB;AACD,mBAFD,MAEO;AACLjE,oBAAAA,SAAO,CAACmE,MAAR,IAAkBwB,QAAlB;AACD;AACF;;AACD;;AACF,mBAAK,IAAL;AACE,oBAAI+D,SAAQ,IAAI1J,SAAO,CAACwG,MAAR,CAAeE,MAAf,KAA0B,CAA1C,EAA6C;AAAA,yDAC5B1G,SAAO,CAACwG,MADoB;AAAA,sBAClC0C,GADkC;;AAE3C,sBAAI,CAACF,aAAL,EAAoB;AAClB,wBAAIE,GAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,IAAaA,GAAE,CAAC,CAAD,CAAF,GAAQ,CAAzB,EAA4B;AAC1BF,sBAAAA,aAAa,GAAGQ,cAAhB;AACD,qBAFD,MAEO;AACLR,sBAAAA,aAAa,GAAGC,iBAAhB;AACD;AACF;;AACDD,kBAAAA,aAAa,CACXhJ,SADW,EAEXkJ,GAFW,EAGXxD,QAHW,EAIXC,QAJW,EAKXzF,GALW,EAMXC,GANW,EAOX5C,KAAK,CAACkD,QAPK,CAAb;AASD,iBAlBD,MAkBO;AACL,sBAAIlD,KAAK,CAACkD,QAAV,EAAoB;AAClBT,oBAAAA,SAAO,CAACiE,KAAR,IAAiByB,QAAjB;AACA1F,oBAAAA,SAAO,CAACmE,MAAR,GAAiBnE,SAAO,CAACiE,KAAzB;AACD,mBAHD,MAGO;AACLjE,oBAAAA,SAAO,CAACiE,KAAR,IAAiByB,QAAjB;AACA1F,oBAAAA,SAAO,CAACmE,MAAR,IAAkBwB,QAAlB;AACD;AACF;;AACD;;AACF,mBAAK,GAAL;AAAU;AACR3F,kBAAAA,SAAO,CAACmE,MAAR,IAAkBwB,QAAlB;AACA3F,kBAAAA,SAAO,CAACG,CAAR,IAAawF,QAAb;;AAEA,sBAAI3F,SAAO,CAACwG,MAAR,CAAeE,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,wBAAMiD,GAAG,GAAG3J,SAAO,CAACwG,MAAR,CAAeE,MAA3B;;AAEA,wBAAMF,MAAM,GAAG,mBAAIxG,SAAO,CAACwG,MAAZ,EAAoBoD,IAApB,CAAyB,UAACC,CAAD,EAAIC,CAAJ;AAAA,6BAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAlB;AAAA,qBAAzB,CAAf;;AAEA,yBAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvD,MAAM,CAACE,MAA3B,EAAmC,EAAEqD,CAArC,EAAwC;AACtC,0BAAMtD,GAAG,GAAGD,MAAM,CAACuD,CAAD,CAAlB;AACAtD,sBAAAA,GAAG,CAAC,CAAD,CAAH,IAAUd,QAAM,IAAIgE,GAAG,GAAGI,CAAV,CAAhB;AACD;AACF;;AACD;AACD;;AACD,mBAAK,GAAL;AAAU;AACR/J,kBAAAA,SAAO,CAACiE,KAAR,IAAiByB,QAAjB;AACA1F,kBAAAA,SAAO,CAACE,CAAR,IAAawF,QAAb;;AAEA,sBAAI1F,SAAO,CAACwG,MAAR,CAAeE,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,wBAAMiD,IAAG,GAAG3J,SAAO,CAACwG,MAAR,CAAeE,MAA3B;;AACA,wBAAMF,OAAM,GAAG,mBAAIxG,SAAO,CAACwG,MAAZ,EAAoBoD,IAApB,CAAyB,UAACC,CAAD,EAAIC,CAAJ;AAAA,6BAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAlB;AAAA,qBAAzB,CAAf;;AAEA,yBAAK,IAAIC,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGvD,OAAM,CAACE,MAA3B,EAAmC,EAAEqD,EAArC,EAAwC;AACtC,0BAAMtD,IAAG,GAAGD,OAAM,CAACuD,EAAD,CAAlB;AACAtD,sBAAAA,IAAG,CAAC,CAAD,CAAH,IAAUf,QAAM,IAAIiE,IAAG,GAAGI,EAAV,CAAhB;AACD;AACF;;AACD;AACD;;AACD,mBAAK,GAAL;AAAU;AACR/J,kBAAAA,SAAO,CAACmE,MAAR,IAAkBwB,QAAlB;;AACA,sBAAI3F,SAAO,CAACwG,MAAR,CAAeE,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,wBAAMiD,KAAG,GAAG3J,SAAO,CAACwG,MAAR,CAAeE,MAA3B;;AACA,wBAAMF,QAAM,GAAG,mBAAIxG,SAAO,CAACwG,MAAZ,EAAoBoD,IAApB,CAAyB,UAACC,CAAD,EAAIC,CAAJ;AAAA,6BAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAlB;AAAA,qBAAzB,CAAf;;AAEA,yBAAK,IAAIC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGvD,QAAM,CAACE,MAA3B,EAAmC,EAAEqD,GAArC,EAAwC;AACtC,0BAAMtD,KAAG,GAAGD,QAAM,CAACuD,GAAD,CAAlB;AACAtD,sBAAAA,KAAG,CAAC,CAAD,CAAH,IAAUd,QAAM,IAAIgE,KAAG,GAAGI,GAAV,CAAhB;AACD;AACF;;AACD;AACD;;AACD,mBAAK,GAAL;AAAU;AACR/J,kBAAAA,SAAO,CAACiE,KAAR,IAAiByB,QAAjB;;AACA,sBAAI1F,SAAO,CAACwG,MAAR,CAAeE,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,wBAAMiD,KAAG,GAAG3J,SAAO,CAACwG,MAAR,CAAeE,MAA3B;;AACA,wBAAMF,QAAM,GAAG,mBAAIxG,SAAO,CAACwG,MAAZ,EAAoBoD,IAApB,CAAyB,UAACC,CAAD,EAAIC,CAAJ;AAAA,6BAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAlB;AAAA,qBAAzB,CAAf;;AAEA,yBAAK,IAAIC,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGvD,QAAM,CAACE,MAA3B,EAAmC,EAAEqD,GAArC,EAAwC;AACtC,0BAAMtD,KAAG,GAAGD,QAAM,CAACuD,GAAD,CAAlB;AACAtD,sBAAAA,KAAG,CAAC,CAAD,CAAH,IAAUf,QAAM,IAAIiE,KAAG,GAAGI,GAAV,CAAhB;AACD;AACF;;AACD;AACD;AAlLH;;AAqLA,gBAAI9C,YAAJ,EAAkB;AAChBA,cAAAA,YAAY,GAAG5Q,qBAAqB,CAAC2J,SAAD,EAAUiH,YAAV,CAApC;AACD;;AACDrQ,YAAAA,mBAAmB,CAACoJ,SAAD,CAAnB;AAEAjE,YAAAA,QAAQ,CAACC,eAAT,CAAyBC,KAAzB,CAA+BC,MAA/B,GAAwCxF,2BAA2B,CAAC;AAClEsJ,cAAAA,OAAO,EAAPA,SADkE;AAElEiH,cAAAA,YAAY,EAAZA;AAFkE,aAAD,CAAnE;AAIAtG,YAAAA,EAAE,CAACT,CAAH,GAAOF,SAAO,CAACE,CAAf;AACAS,YAAAA,EAAE,CAACR,CAAH,GAAOH,SAAO,CAACG,CAAf;AACAlG,YAAAA,yBAAyB,CAAC0G,EAAD,CAAzB;AAEA6G,YAAAA,KAAK,GAAGtH,GAAR;AACAuH,YAAAA,KAAK,GAAGtH,GAAR;;AACA,kBAAK/C,QAAL,CAAc,EAAd;;AACA;AACD;AACF;;AAED,YAAI8J,UAAU,IAAI,MAAKzJ,KAAL,CAAWmD,kBAAX,CAA8BsG,UAAU,CAACrG,EAAzC,CAAlB,EAAgE;AAC9D;AACA;AACAyH,UAAAA,gBAAgB,GAAG,IAAnB;;AACA,cAAMxB,kBAAgB,GAAG1P,mBAAmB,CAACqD,QAAD,EAAW,MAAKgD,KAAhB,CAA5C;;AACA,cAAIqJ,kBAAgB,CAACJ,MAAjB,GAA0B,CAA9B,EAAiC;AAAA,yCACdrO,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CADb;AAAA,gBACvB2D,IADuB,0BACvBA,CADuB;AAAA,gBACpBC,GADoB,0BACpBA,CADoB;;AAO/B2G,YAAAA,kBAAgB,CAAC/G,OAAjB,CAAyB,UAAAC,OAAO,EAAI;AAClCA,cAAAA,OAAO,CAACE,CAAR,IAAaA,IAAC,GAAGsH,KAAjB;AACAxH,cAAAA,OAAO,CAACG,CAAR,IAAaA,GAAC,GAAGsH,KAAjB;AACD,aAHD;;AAIAD,YAAAA,KAAK,GAAGtH,IAAR;AACAuH,YAAAA,KAAK,GAAGtH,GAAR;;AACA,kBAAK/C,QAAL,CAAc,EAAd;;AACA;AACD;AACF,SAzR4C,CA2R7C;AACA;;;AACA,YAAMmE,eAAe,GAAG,MAAK9D,KAAL,CAAW8D,eAAnC;;AACA,YAAI,CAACA,eAAL,EAAsB;AACpB;AACD;;AAhS4C,qCAkS5BlJ,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CAlSC;AAAA,YAkSrC2D,CAlSqC,0BAkSrCA,CAlSqC;AAAA,YAkSlCC,CAlSkC,0BAkSlCA,CAlSkC;;AAwS7C,YAAI8D,KAAK,GAAG/L,QAAQ,CAACoO,OAAD,EAAUpG,CAAV,CAApB;AACA,YAAIiE,MAAM,GAAGjM,QAAQ,CAACqO,OAAD,EAAUpG,CAAV,CAArB;AAEA,YAAMuJ,QAAQ,GACZ,MAAKjM,KAAL,CAAWoE,WAAX,KAA2B,MAA3B,IAAqC,MAAKpE,KAAL,CAAWoE,WAAX,KAA2B,OADlE;;AAGA,YAAI6H,QAAJ,EAAc;AACZpB,UAAAA,gBAAgB,GAAG,IAAnB;AACA,cAAM9B,QAAM,GAAGjF,eAAe,CAACiF,MAA/B;;AACA,cAAI0B,GAAE,GAAGhI,CAAC,GAAGqB,eAAe,CAACrB,CAA7B;;AACA,cAAIiI,GAAE,GAAGhI,CAAC,GAAGoB,eAAe,CAACpB,CAA7B;;AAEA,cAAI5C,KAAK,CAACkD,QAAN,IAAkB+F,QAAM,CAACE,MAAP,KAAkB,CAAxC,EAA2C;AAAA,yCACZ/P,qBAAqB,CAChD,MAAK8G,KAAL,CAAWoE,WADqC,EAEhDqG,GAFgD,EAGhDC,GAHgD,CADT;;AAC/BD,YAAAA,GAD+B,0BACtCjE,KADsC;AACnBkE,YAAAA,GADmB,0BAC3BhE,MAD2B;AAM1C;;AAED,cAAIqC,QAAM,CAACE,MAAP,KAAkB,CAAtB,EAAyB;AACvBF,YAAAA,QAAM,CAACmC,IAAP,CAAY,CAACT,GAAD,EAAKC,GAAL,CAAZ;AACD,WAFD,MAEO,IAAI3B,QAAM,CAACE,MAAP,GAAgB,CAApB,EAAuB;AAC5B,gBAAMD,KAAG,GAAGD,QAAM,CAACA,QAAM,CAACE,MAAP,GAAgB,CAAjB,CAAlB;AACAD,YAAAA,KAAG,CAAC,CAAD,CAAH,GAASyB,GAAT;AACAzB,YAAAA,KAAG,CAAC,CAAD,CAAH,GAAS0B,GAAT;AACD;AACF,SArBD,MAqBO;AACL,cAAI5K,KAAK,CAACkD,QAAV,EAAoB;AAAA,yCACG9J,qBAAqB,CACxC,MAAK8G,KAAL,CAAWoE,WAD6B,EAExCoC,KAFwC,EAGxC9D,CAAC,GAAGoG,OAAJ,GAAc,CAACpC,MAAf,GAAwBA,MAHgB,CADxB;;AACfF,YAAAA,KADe,0BACfA,KADe;AACRE,YAAAA,MADQ,0BACRA,MADQ;;AAOlB,gBAAIA,MAAM,GAAG,CAAb,EAAgB;AACdA,cAAAA,MAAM,GAAG,CAACA,MAAV;AACD;AACF;;AAED5C,UAAAA,eAAe,CAACrB,CAAhB,GAAoBA,CAAC,GAAGoG,OAAJ,GAAcA,OAAO,GAAGrC,KAAxB,GAAgCqC,OAApD;AACA/E,UAAAA,eAAe,CAACpB,CAAhB,GAAoBA,CAAC,GAAGoG,OAAJ,GAAcA,OAAO,GAAGpC,MAAxB,GAAiCoC,OAArD;AAEAhF,UAAAA,eAAe,CAAC0C,KAAhB,GAAwBA,KAAxB;AACA1C,UAAAA,eAAe,CAAC4C,MAAhB,GAAyBA,MAAzB;AACD;;AAEDlK,QAAAA,yBAAyB,CAACsH,eAAD,CAAzB;;AAEA,YAAI,MAAK9D,KAAL,CAAWoE,WAAX,KAA2B,WAA/B,EAA4C;AAC1C,cAAI,CAACtE,KAAK,CAACkD,QAAP,IAAmBpJ,qBAAqB,CAACoD,QAAD,EAAW,MAAKgD,KAAhB,CAA5C,EAAoE;AAClE,kBAAKL,QAAL,CAAc;AAAEwD,cAAAA,kBAAkB,EAAE;AAAtB,aAAd;AACD;;AACD,cAAMoJ,uBAAuB,GAAGlT,0BAA0B,CACxD2D,QADwD,EAExD8G,eAFwD,CAA1D;;AAIA,gBAAKnE,QAAL,CAAc,UAAAgI,SAAS;AAAA,mBAAK;AAC1BxE,cAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,MAEblG,MAAM,CAACuP,WAAP,CACDD,uBAAuB,CAACtJ,GAAxB,CAA4B,UAAAV,OAAO;AAAA,uBAAI,CAACA,OAAO,CAACa,EAAT,EAAa,IAAb,CAAJ;AAAA,eAAnC,CADC,CAFa;AADQ,aAAL;AAAA,WAAvB;AAQD;;AACD,cAAKzD,QAAL,CAAc,EAAd;AACD,OA3WD;;AA6WA,UAAMgL,WAAW,GAAG,SAAdA,WAAc,CAAC7K,KAAD,EAAyB;AAAA,0BAOvC,MAAKE,KAPkC;AAAA,YAEzC8D,eAFyC,eAEzCA,eAFyC;AAAA,YAGzCiH,eAHyC,eAGzCA,eAHyC;AAAA,YAIzCnC,YAJyC,eAIzCA,YAJyC;AAAA,YAKzCxE,WALyC,eAKzCA,WALyC;AAAA,YAMzC+G,aANyC,eAMzCA,aANyC;;AAS3C,cAAKxL,QAAL,CAAc;AACZqM,UAAAA,UAAU,EAAE,KADA;AAEZjB,UAAAA,eAAe,EAAE,IAFL;AAGZO,UAAAA,gBAAgB,EAAE;AAHN,SAAd;;AAMAC,QAAAA,aAAa,GAAG,IAAhB;AACA1N,QAAAA,cAAa,GAAG,IAAhB;AACAf,QAAAA,MAAM,CAACqN,mBAAP,CAA2B,aAA3B,EAA0CF,aAA1C;AACAnN,QAAAA,MAAM,CAACqN,mBAAP,CAA2B,WAA3B,EAAwCQ,WAAxC;;AAEA,YAAIvG,WAAW,KAAK,OAAhB,IAA2BA,WAAW,KAAK,MAA/C,EAAuD;AACrD,cAAIN,eAAe,CAAEiF,MAAjB,CAAwBE,MAAxB,GAAiC,CAArC,EAAwC;AACtC7L,YAAAA,OAAO,CAACsC,eAAR;;AACA,kBAAKC,QAAL,CAAc,EAAd;AACD;;AACD,cAAI,CAACkL,gBAAD,IAAqB/G,eAArB,IAAwC,CAAC8E,YAA7C,EAA2D;AAAA,yCACxChO,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAKE,KAFqC,EAG1C,MAAKlB,MAHqC,CADa;AAAA,gBACjD2D,IADiD,0BACjDA,CADiD;AAAA,gBAC9CC,GAD8C,0BAC9CA,CAD8C;;AAMzDoB,YAAAA,eAAe,CAACiF,MAAhB,CAAuBmC,IAAvB,CAA4B,CAC1BzI,IAAC,GAAGqB,eAAe,CAACrB,CADM,EAE1BC,GAAC,GAAGoB,eAAe,CAACpB,CAFM,CAA5B;AAIAlG,YAAAA,yBAAyB,CAACsH,eAAD,CAAzB;;AACA,kBAAKnE,QAAL,CAAc;AAAEiJ,cAAAA,YAAY,EAAE,MAAK5I,KAAL,CAAW8D;AAA3B,aAAd;AACD,WAZD,MAYO,IAAI+G,gBAAgB,IAAI,CAACjC,YAAzB,EAAuC;AAC5C,gBAAI,CAACuC,aAAL,EAAoB;AAClBxQ,cAAAA,WAAW;;AACX,oBAAKgF,QAAL,CAAc,UAAAgI,SAAS;AAAA,uBAAK;AAC1B7D,kBAAAA,eAAe,EAAE,IADS;AAE1BM,kBAAAA,WAAW,EAAE,WAFa;AAG1BjB,kBAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEf,MAAKnD,KAAL,CAAW8D,eAAX,CAA4BV,EAFb,EAEkB,IAFlB;AAHQ,iBAAL;AAAA,eAAvB;AAQD,aAVD,MAUO;AACL,oBAAKzD,QAAL,CAAc,UAAAgI,SAAS;AAAA,uBAAK;AAC1B7D,kBAAAA,eAAe,EAAE,IADS;AAE1BX,kBAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEf,MAAKnD,KAAL,CAAW8D,eAAX,CAA4BV,EAFb,EAEkB,IAFlB;AAFQ,iBAAL;AAAA,eAAvB;AAOD;AACF;;AACD;AACD;;AAED,YACEgB,WAAW,KAAK,WAAhB,IACAN,eADA,IAEAjL,uBAAuB,CAACiL,eAAD,CAHzB,EAIE;AACA;AACA9G,UAAAA,QAAQ,GAAGA,QAAQ,CAACgO,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAAX;;AACA,gBAAKrL,QAAL,CAAc;AACZmE,YAAAA,eAAe,EAAE;AADL,WAAd;;AAGA;AACD;;AAED,YAAI3K,mBAAmB,CAAC2K,eAAD,CAAvB,EAA0C;AACxC,gBAAKnE,QAAL,CAAc,EAAd;AACD;;AAED,YAAIoL,eAAJ,EAAqB;AACnB3N,UAAAA,OAAO,CAACsC,eAAR;;AACA,gBAAKC,QAAL,CAAc,EAAd;AACD;;AAED,YAAIoL,eAAe,IAAIlS,uBAAuB,CAACkS,eAAD,CAA9C,EAAiE;AAC/D/N,UAAAA,QAAQ,GAAGA,QAAQ,CAACsJ,MAAT,CAAgB,UAAApD,EAAE;AAAA,mBAAIA,EAAE,CAACE,EAAH,KAAU2H,eAAe,CAAC3H,EAA9B;AAAA,WAAlB,CAAX;AACD,SArF0C,CAuF3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAIqG,UAAU,IAAI,CAACoB,gBAAf,IAAmC,CAACC,yBAAxC,EAAmE;AACjE,cAAIhL,KAAK,CAACkD,QAAV,EAAoB;AAClB,kBAAKrD,QAAL,CAAc,UAAAgI,SAAS;AAAA,qBAAK;AAC1BxE,gBAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEfsG,UAAU,CAAErG,EAFG,EAEE,KAFF;AADQ,eAAL;AAAA,aAAvB;AAMD,WAPD,MAOO;AACL,kBAAKzD,QAAL,CAAc,UAAAgI,SAAS;AAAA,qBAAK;AAC1BxE,gBAAAA,kBAAkB,sBAAKsG,UAAU,CAAErG,EAAjB,EAAsB,IAAtB;AADQ,eAAL;AAAA,aAAvB;AAGD;AACF;;AAED,YAAIU,eAAe,KAAK,IAAxB,EAA8B;AAC5B;AACA,gBAAKnE,QAAL,CAAc;AAAEwD,YAAAA,kBAAkB,EAAE;AAAtB,WAAd;;AACA;AACD;;AAED,YAAI,CAACgI,aAAL,EAAoB;AAClB,gBAAKxL,QAAL,CAAc,UAAAgI,SAAS;AAAA,mBAAK;AAC1BxE,cAAAA,kBAAkB,oBACbwE,SAAS,CAACxE,kBADG,sBAEfW,eAAe,CAACV,EAFD,EAEM,IAFN;AADQ,aAAL;AAAA,WAAvB;AAMD;;AAED,YACEgB,WAAW,KAAK,WAAhB,IACAxK,qBAAqB,CAACoD,QAAD,EAAW,MAAKgD,KAAhB,CAFvB,EAGE;AACA5C,UAAAA,OAAO,CAACsC,eAAR;AACD;;AAED,YAAI,CAACyL,aAAL,EAAoB;AAClBxQ,UAAAA,WAAW;;AACX,gBAAKgF,QAAL,CAAc;AACZmE,YAAAA,eAAe,EAAE,IADL;AAEZM,YAAAA,WAAW,EAAE;AAFD,WAAd;AAID,SAND,MAMO;AACL,gBAAKzE,QAAL,CAAc;AACZmE,YAAAA,eAAe,EAAE;AADL,WAAd;AAGD;AACF,OA/ID;;AAiJAjG,MAAAA,cAAa,GAAG8M,WAAhB;AAEA7N,MAAAA,MAAM,CAACsN,gBAAP,CAAwB,aAAxB,EAAuCH,aAAvC;AACAnN,MAAAA,MAAM,CAACsN,gBAAP,CAAwB,WAAxB,EAAqCO,WAArC;AACD,KA9rDuB;;AAAA,UAgsDhB8B,WAhsDgB,GAgsDF,UAAC3M,KAAD,EAAuB;AAC3CA,MAAAA,KAAK,CAACI,cAAN;AAD2C,UAEnC+H,MAFmC,GAEhBnI,KAFgB,CAEnCmI,MAFmC;AAAA,UAE3BC,MAF2B,GAEhBpI,KAFgB,CAE3BoI,MAF2B,EAI3C;;AACA,UAAIpI,KAAK,CAAC+D,OAAN,IAAiB/D,KAAK,CAAC6D,OAA3B,EAAoC;AAClC,YAAM+I,IAAI,GAAGC,IAAI,CAACD,IAAL,CAAUxE,MAAV,CAAb;AACA,YAAM0E,QAAQ,GAAG,EAAjB;AACA,YAAIC,KAAK,GAAGF,IAAI,CAACG,GAAL,CAAS5E,MAAT,CAAZ;;AACA,YAAI2E,KAAK,GAAGD,QAAZ,EAAsB;AACpBC,UAAAA,KAAK,GAAGD,QAAR;AACD;;AACDC,QAAAA,KAAK,IAAIH,IAAT;;AACA,cAAK/M,QAAL,CAAc;AAAA,cAAG2F,IAAH,SAAGA,IAAH;AAAA,iBAAe;AAC3BA,YAAAA,IAAI,EAAE5L,iBAAiB,CAAC4L,IAAI,GAAGuH,KAAK,GAAG,GAAhB;AADI,WAAf;AAAA,SAAd;;AAGA;AACD;;AAED,YAAKlN,QAAL,CAAc;AAAA,YAAG2F,IAAH,SAAGA,IAAH;AAAA,YAASiD,OAAT,SAASA,OAAT;AAAA,YAAkBC,OAAlB,SAAkBA,OAAlB;AAAA,eAAiC;AAC7CD,UAAAA,OAAO,EAAE3M,eAAe,CAAC2M,OAAO,GAAGN,MAAM,GAAG3C,IAApB,CADqB;AAE7CkD,UAAAA,OAAO,EAAE5M,eAAe,CAAC4M,OAAO,GAAGN,MAAM,GAAG5C,IAApB;AAFqB,SAAjC;AAAA,OAAd;AAID,KAvtDuB;;AAAA,UAytDhBZ,oBAztDgB,GAytDO,UAC7BqI,iBAD6B,EAE1B;AAAA,6BAC8B/T,eAAe,CAAC+T,iBAAD,CAD7C;AAAA;AAAA,UACIC,IADJ;AAAA,UACUC,IADV;AAAA,UACgBC,IADhB;AAAA,UACsBC,IADtB;;AAGH,UAAMC,eAAe,GAAG3S,QAAQ,CAACuS,IAAD,EAAOE,IAAP,CAAR,GAAuB,CAA/C;AACA,UAAMG,eAAe,GAAG5S,QAAQ,CAACwS,IAAD,EAAOE,IAAP,CAAR,GAAuB,CAA/C;;AAJG,oCAMcvS,2BAA2B,CAC1C;AAAEgK,QAAAA,OAAO,EAAEvH,OAAX;AAAoBwH,QAAAA,OAAO,EAAEvH;AAA7B,OAD0C,EAE1C,MAAK0C,KAFqC,EAG1C,MAAKlB,MAHqC,CANzC;AAAA,UAMK2D,CANL,2BAMKA,CANL;AAAA,UAMQC,CANR,2BAMQA,CANR;;AAYH,UAAM+H,EAAE,GAAGhI,CAAC,GAAG2K,eAAf;AACA,UAAM1C,EAAE,GAAGhI,CAAC,GAAG2K,eAAf;AAEA,UAAMC,WAAW,GAAGP,iBAAiB,CAAC9J,GAAlB,CAAsB,UAAA8J,iBAAiB,EAAI;AAC7D,YAAMQ,SAAS,GAAG5U,gBAAgB,CAACoU,iBAAD,CAAlC;AACAQ,QAAAA,SAAS,CAAC9K,CAAV,IAAegI,EAAE,GAAGuC,IAApB;AACAO,QAAAA,SAAS,CAAC7K,CAAV,IAAegI,EAAE,GAAGuC,IAApB;AACA,eAAOM,SAAP;AACD,OALmB,CAApB;AAOAvQ,MAAAA,QAAQ,gCAAOA,QAAP,sBAAoBsQ,WAApB,EAAR;AACAlQ,MAAAA,OAAO,CAACsC,eAAR;;AACA,YAAKC,QAAL,CAAc;AACZwD,QAAAA,kBAAkB,EAAElG,MAAM,CAACuP,WAAP,CAClBc,WAAW,CAACrK,GAAZ,CAAgB,UAAAV,OAAO;AAAA,iBAAI,CAACA,OAAO,CAACa,EAAT,EAAa,IAAb,CAAJ;AAAA,SAAvB,CADkB;AADR,OAAd;AAKD,KAxvDuB;;AAAA,UAqxDhB0E,WArxDgB,GAqxDF,UAACtG,aAAD,EAA6C;AACjE,UAAIgM,KAAK,CAAChM,aAAa,CAACiB,CAAf,CAAL,IAA0B+K,KAAK,CAAChM,aAAa,CAACkB,CAAf,CAAnC,EAAsD;AACpD;AACA;AACD;;AACD,YAAK1D,MAAL,IACE,MAAK4C,mBAAL,CAAyB;AACvBX,QAAAA,IAAI,EAAE,gBADiB;AAEvBC,QAAAA,OAAO,EAAE;AACPK,UAAAA,QAAQ,EAAE,MAAKvC,MAAL,CAAYoE,EADf;AAEP5B,UAAAA,aAAa,EAAbA;AAFO;AAFc,OAAzB,CADF;AAQD,KAlyDuB;;AAAA,UAoyDhBnB,aApyDgB,GAoyDA7F,QAAQ,CAAC,YAAM;AACrCT,MAAAA,kBAAkB,CAACiD,QAAD,EAAW,MAAKgD,KAAhB,CAAlB;AACD,KAF+B,EAE7B,GAF6B,CApyDR;AAEtB,UAAKZ,aAAL,GAAqB,IAAI/D,aAAJ,CACnB,MAAKiE,gBADc,EAEnB;AAAA,aAAM,MAAKU,KAAX;AAAA,KAFmB,EAGnB;AAAA,aAAMhD,QAAN;AAAA,KAHmB,CAArB;;AAKA,UAAKoC,aAAL,CAAmBqO,WAAnB,CAA+BnS,OAA/B;;AAEA,UAAK8D,aAAL,CAAmBsO,cAAnB,CAAkC3R,gBAAgB,CAACqB,OAAD,CAAlD;;AACA,UAAKgC,aAAL,CAAmBsO,cAAnB,CAAkC1R,gBAAgB,CAACoB,OAAD,CAAlD;;AAVsB;AAWvB;;AArBH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AA0KI,oBAAIT,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,MAA7B,EAAqC;AACnCI,kBAAAA,MAAM,CAACC,cAAP,CAAsBJ,MAAM,CAACC,QAA7B,EAAuC,UAAvC,EAAmD;AACjD4Q,oBAAAA,YAAY,EAAE,IADmC;AAEjDxQ,oBAAAA,GAAG,EAAE,eAAM;AACT,6BAAO,MAAI,CAAC6C,KAAZ;AACD;AAJgD,mBAAnD;AAMD;;AAED1B,gBAAAA,QAAQ,CAAC8L,gBAAT,CAA0B,MAA1B,EAAkC,KAAKjK,MAAvC;AACA7B,gBAAAA,QAAQ,CAAC8L,gBAAT,CAA0B,OAA1B,EAAmC,KAAK/F,kBAAxC;AACA/F,gBAAAA,QAAQ,CAAC8L,gBAAT,CAA0B,KAA1B,EAAiC,KAAKvK,KAAtC;AAEAvB,gBAAAA,QAAQ,CAAC8L,gBAAT,CAA0B,SAA1B,EAAqC,KAAKzH,SAA1C,EAAqD,KAArD;AACArE,gBAAAA,QAAQ,CAAC8L,gBAAT,CAA0B,OAA1B,EAAmC,KAAKjG,OAAxC,EAAiD;AAAEkG,kBAAAA,OAAO,EAAE;AAAX,iBAAjD;AACA/L,gBAAAA,QAAQ,CAAC8L,gBAAT,CAA0B,WAA1B,EAAuC,KAAK5H,2BAA5C;AACA1F,gBAAAA,MAAM,CAACsN,gBAAP,CAAwB,QAAxB,EAAkC,KAAK/H,QAAvC,EAAiD,KAAjD;AACAvF,gBAAAA,MAAM,CAACsN,gBAAP,CAAwB,QAAxB,EAAkC,KAAKhK,QAAvC,EAAiD,KAAjD;AACAtD,gBAAAA,MAAM,CAACsN,gBAAP,CAAwB,MAAxB,EAAgC,KAAKhK,QAArC,EAA+C,KAA/C;AACAtD,gBAAAA,MAAM,CAACsN,gBAAP,CAAwB,UAAxB,EAAoC,KAAK7J,YAAzC,EAAuD,KAAvD;AACAzD,gBAAAA,MAAM,CAACsN,gBAAP,CAAwB,MAAxB,EAAgC,KAAK7J,YAArC,EAAmD,KAAnD,EA9LJ,CAgMI;;AACAjC,gBAAAA,QAAQ,CAAC8L,gBAAT,CACE,cADF,EAEE,KAAK/E,cAFP,EAGE,KAHF;AAKA/G,gBAAAA,QAAQ,CAAC8L,gBAAT,CACE,eADF,EAEE,KAAK7E,eAFP,EAGE,KAHF;AAKAjH,gBAAAA,QAAQ,CAAC8L,gBAAT,CAA0B,YAA1B,EAAwC,KAAK3E,YAA7C,EAAkE,KAAlE;AAEMmI,gBAAAA,YA7MV,GA6MyB,IAAIC,eAAJ,CAAoB/Q,MAAM,CAAC4D,QAAP,CAAgBoN,MAApC,CA7MzB;AA8MU1K,gBAAAA,EA9MV,GA8MewK,YAAY,CAACzQ,GAAb,CAAiB,IAAjB,CA9Mf;;AAAA,qBAgNQiG,EAhNR;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAkN0BpJ,SAAS,CAACoJ,EAAD,CAlNnC;;AAAA;AAkNY2K,gBAAAA,MAlNZ;AAmNM,qBAAKzO,gBAAL,CAAsByO,MAAtB;;AAnNN;AAsNUC,gBAAAA,SAtNV,GAsNsBlR,MAAM,CAAC4D,QAAP,CAAgBuN,IAAhB,CAAqBC,KAArB,CAChB,mCADgB,CAtNtB;;AAAA,qBAyNQF,SAzNR;AAAA;AAAA;AAAA;;AAAA;AAAA,uBA0N0BhU,SAAS,CAACgU,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAxB,CA1NnC;;AAAA;AA0NYD,gBAAAA,OA1NZ;AA2NM,qBAAKzO,gBAAL,CAAsByO,OAAtB;AA3NN;;AAAA;AA+NUtN,gBAAAA,SA/NV,GA+NsB/D,wBAAwB,CAACI,MAAM,CAAC4D,QAAP,CAAgBC,IAAjB,CA/N9C;;AAAA,qBAgOQF,SAhOR;AAAA;AAAA;AAAA;;AAiOM,qBAAKD,sBAAL;AAjON;;AAAA;AAAA;AAAA,uBAoOwBxG,SAAS,CAAC,IAAD,CApOjC;;AAAA;AAoOU+T,gBAAAA,KApOV;AAqOI,qBAAKzO,gBAAL,CAAsByO,KAAtB;;AArOJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,2CAwOgC;AAC5B,WAAKtO,SAAL,GAAiB,IAAjB;AACAnB,MAAAA,QAAQ,CAAC6L,mBAAT,CAA6B,MAA7B,EAAqC,KAAKhK,MAA1C;AACA7B,MAAAA,QAAQ,CAAC6L,mBAAT,CAA6B,OAA7B,EAAsC,KAAK9F,kBAA3C;AACA/F,MAAAA,QAAQ,CAAC6L,mBAAT,CAA6B,KAA7B,EAAoC,KAAKtK,KAAzC;AAEAvB,MAAAA,QAAQ,CAAC6L,mBAAT,CAA6B,SAA7B,EAAwC,KAAKxH,SAA7C,EAAwD,KAAxD;AACArE,MAAAA,QAAQ,CAAC6L,mBAAT,CACE,WADF,EAEE,KAAK3H,2BAFP,EAGE,KAHF;AAKAlE,MAAAA,QAAQ,CAAC6L,mBAAT,CAA6B,OAA7B,EAAsC,KAAKhG,OAA3C;AACArH,MAAAA,MAAM,CAACqN,mBAAP,CAA2B,QAA3B,EAAqC,KAAK9H,QAA1C,EAAoD,KAApD;AACAvF,MAAAA,MAAM,CAACqN,mBAAP,CAA2B,QAA3B,EAAqC,KAAK/J,QAA1C,EAAoD,KAApD;AACAtD,MAAAA,MAAM,CAACqN,mBAAP,CAA2B,MAA3B,EAAmC,KAAK/J,QAAxC,EAAkD,KAAlD;AACAtD,MAAAA,MAAM,CAACqN,mBAAP,CAA2B,UAA3B,EAAuC,KAAK5J,YAA5C,EAA0D,KAA1D;AACAzD,MAAAA,MAAM,CAACqN,mBAAP,CAA2B,MAA3B,EAAmC,KAAK5J,YAAxC,EAAsD,KAAtD;AAEAjC,MAAAA,QAAQ,CAAC6L,mBAAT,CACE,cADF,EAEE,KAAK9E,cAFP,EAGE,KAHF;AAKA/G,MAAAA,QAAQ,CAAC6L,mBAAT,CACE,eADF,EAEE,KAAK5E,eAFP,EAGE,KAHF;AAKAjH,MAAAA,QAAQ,CAAC6L,mBAAT,CAA6B,YAA7B,EAA2C,KAAK1E,YAAhD,EAAqE,KAArE;AACD;AAtQH;AAAA;AAAA,oCAwY0BrB,WAxY1B,EAwYgE;AAC5D,UAAI,CAAC7G,cAAL,EAAqB;AACnBa,QAAAA,iBAAiB,CAACgG,WAAD,CAAjB;AACD;;AACD,UAAI7J,UAAU,CAAC+D,QAAQ,CAACgG,aAAV,CAAd,EAAwC;AACtChG,QAAAA,QAAQ,CAACgG,aAAT,CAAuBkG,IAAvB;AACD;;AACD,UAAIpG,WAAW,KAAK,WAApB,EAAiC;AAC/B,aAAKzE,QAAL,CAAc;AAAEyE,UAAAA,WAAW,EAAXA,WAAF;AAAejB,UAAAA,kBAAkB,EAAE;AAAnC,SAAd;AACD,OAFD,MAEO;AACL,aAAKxD,QAAL,CAAc;AAAEyE,UAAAA,WAAW,EAAXA;AAAF,SAAd;AACD;AACF;AApZH;AAAA;AAAA,6BAmbkB;AAAA;;AACd,UAAM+J,cAAc,GAAGrR,MAAM,CAACsR,UAA9B;AACA,UAAMC,eAAe,GAAGvR,MAAM,CAACwR,WAA/B;AAEA,UAAMC,WAAW,GAAGzR,MAAM,CAAC0R,gBAA3B;AAEA,UAAMC,WAAW,GAAGN,cAAc,GAAGI,WAArC;AACA,UAAMG,YAAY,GAAGL,eAAe,GAAGE,WAAvC;AAEA,aACE;AAAK,QAAA,SAAS,EAAC,WAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACE,oBAAC,OAAD;AACE,QAAA,MAAM,EAAE,KAAKzP,MADf;AAEE,QAAA,QAAQ,EAAE,KAAKkB,KAFjB;AAGE,QAAA,WAAW,EAAE,KAAK0F,WAHpB;AAIE,QAAA,aAAa,EAAE,KAAKtG,aAJtB;AAKE,QAAA,QAAQ,EAAEpC,QALZ;AAME,QAAA,WAAW,EAAE,KAAK4I,WANpB;AAOE,QAAA,QAAQ,EAAEnK,WAAW,EAPvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QADF,EAUE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SACE;AACE,QAAA,EAAE,EAAC,QADL;AAEE,QAAA,KAAK,EAAE;AACL+K,UAAAA,KAAK,EAAE2H,cADF;AAELzH,UAAAA,MAAM,EAAE2H;AAFH,SAFT;AAME,QAAA,KAAK,EAAEI,WANT;AAOE,QAAA,MAAM,EAAEC,YAPV;AAQE,QAAA,GAAG,EAAE,aAAA5P,MAAM,EAAI;AACb;AACA,cAAIA,MAAM,KAAK,IAAf,EAAqB;AAAA;;AACnB,YAAA,MAAI,CAACA,MAAL,GAAcA,MAAd;AACA,YAAA,MAAI,CAACC,EAAL,GAAUvG,KAAK,CAACsG,MAAN,CAAa,MAAI,CAACA,MAAlB,CAAV;;AAEA,YAAA,MAAI,CAACA,MAAL,CAAYsL,gBAAZ,CAA6B,OAA7B,EAAsC,MAAI,CAACqC,WAA3C,EAAwD;AACtDpC,cAAAA,OAAO,EAAE;AAD6C,aAAxD;;AAIA,qCAAA,MAAI,CAACvL,MAAL,CACG6P,UADH,CACc,IADd,iFAEIC,YAFJ,CAEiBL,WAFjB,EAE8B,CAF9B,EAEiC,CAFjC,EAEoCA,WAFpC,EAEiD,CAFjD,EAEoD,CAFpD;AAGD,WAXD,MAWO;AAAA;;AACL,6BAAA,MAAI,CAACzP,MAAL,gEAAaqL,mBAAb,CAAiC,OAAjC,EAA0C,MAAI,CAACsC,WAA/C;AACD;AACF,SAxBH;AAyBE,QAAA,aAAa,EAAE,uBAAA3M,KAAK,EAAI;AACtBA,UAAAA,KAAK,CAACI,cAAN;;AADsB,wCAGLtF,2BAA2B,CAC1CkF,KAD0C,EAE1C,MAAI,CAACE,KAFqC,EAG1C,MAAI,CAAClB,MAHqC,CAHtB;AAAA,cAGd2D,CAHc,2BAGdA,CAHc;AAAA,cAGXC,CAHW,2BAGXA,CAHW;;AAStB,cAAMH,OAAO,GAAGhJ,oBAAoB,CAClCyD,QADkC,EAElC,MAAI,CAACgD,KAF6B,EAGlCyC,CAHkC,EAIlCC,CAJkC,EAKlC,MAAI,CAAC1C,KAAL,CAAWsF,IALuB,CAApC;;AAOA,cAAI,CAAC/C,OAAL,EAAc;AACZpH,YAAAA,WAAW,CAAC+P,IAAZ,CAAiB;AACf2D,cAAAA,OAAO,GACLC,SAAS,CAACC,SAAV,IAAuB;AACrBC,gBAAAA,KAAK,EAAExT,CAAC,CAAC,cAAD,CADa;AAErByT,gBAAAA,MAAM,EAAE;AAAA,yBAAM,MAAI,CAAC5K,kBAAL,CAAwB,IAAxB,CAAN;AAAA;AAFa,eADlB,4BAKF,MAAI,CAACjF,aAAL,CAAmB8P,mBAAnB,CAAuC,UAAAD,MAAM;AAAA,uBAC9C,MAAI,CAAC5P,iBAAL,CAAuBoE,QAAvB,CAAgCwL,MAAM,CAACE,IAAvC,CAD8C;AAAA,eAA7C,CALE,EADQ;AAUfC,cAAAA,GAAG,EAAEtP,KAAK,CAAC+E,OAVI;AAWfwK,cAAAA,IAAI,EAAEvP,KAAK,CAAC8E;AAXG,aAAjB;AAaA;AACD;;AAED,cAAI,CAAC,MAAI,CAAC5E,KAAL,CAAWmD,kBAAX,CAA8BZ,OAAO,CAACa,EAAtC,CAAL,EAAgD;AAC9C,YAAA,MAAI,CAACzD,QAAL,CAAc;AAAEwD,cAAAA,kBAAkB,sBAAKZ,OAAO,CAACa,EAAb,EAAkB,IAAlB;AAApB,aAAd;AACD;;AAEDjI,UAAAA,WAAW,CAAC+P,IAAZ,CAAiB;AACf2D,YAAAA,OAAO,GACLC,SAAS,CAACC,SAAV,IAAuB;AACrBC,cAAAA,KAAK,EAAExT,CAAC,CAAC,aAAD,CADa;AAErByT,cAAAA,MAAM,EAAE,MAAI,CAACvT;AAFQ,aADlB,EAKLoT,SAAS,CAACC,SAAV,IAAuB;AACrBC,cAAAA,KAAK,EAAExT,CAAC,CAAC,cAAD,CADa;AAErByT,cAAAA,MAAM,EAAE;AAAA,uBAAM,MAAI,CAAC5K,kBAAL,CAAwB,IAAxB,CAAN;AAAA;AAFa,aALlB,4BASF,MAAI,CAACjF,aAAL,CAAmB8P,mBAAnB,CACD,UAAAD,MAAM;AAAA,qBAAI,CAAC,MAAI,CAAC5P,iBAAL,CAAuBoE,QAAvB,CAAgCwL,MAAM,CAACE,IAAvC,CAAL;AAAA,aADL,CATE,EADQ;AAcfC,YAAAA,GAAG,EAAEtP,KAAK,CAAC+E,OAdI;AAefwK,YAAAA,IAAI,EAAEvP,KAAK,CAAC8E;AAfG,WAAjB;AAiBD,SA/EH;AAgFE,QAAA,aAAa,EAAE,KAAK8E,uBAhFtB;AAiFE,QAAA,aAAa,EAAE,KAAKzD,uBAjFtB;AAkFE,QAAA,aAAa,EAAE,KAAK4B,uBAlFtB;AAmFE,QAAA,WAAW,EAAE,KAAK/B,aAnFpB;AAoFE,QAAA,eAAe,EAAE,KAAKA,aApFxB;AAqFE,QAAA,MAAM,EAAE,gBAAAhG,KAAK,EAAI;AACf,cAAMwP,IAAI,GAAGxP,KAAK,CAACyP,YAAN,CAAmBC,KAAnB,CAAyB,CAAzB,CAAb;;AACA,cACE,CAAAF,IAAI,SAAJ,IAAAA,IAAI,WAAJ,YAAAA,IAAI,CAAErO,IAAN,MAAe,kBAAf,KACAqO,IADA,aACAA,IADA,uBACAA,IAAI,CAAEH,IAAN,CAAWM,QAAX,CAAoB,aAApB,CADA,CADF,EAGE;AACAxV,YAAAA,YAAY,CAACqV,IAAD,CAAZ,CACGI,IADH,CACQ;AAAA,kBAAG1S,QAAH,SAAGA,QAAH;AAAA,kBAAa4C,QAAb,SAAaA,QAAb;AAAA,qBACJ,MAAI,CAACN,gBAAL,CAAsB;AAAEtC,gBAAAA,QAAQ,EAARA,QAAF;AAAY4C,gBAAAA,QAAQ,EAARA;AAAZ,eAAtB,CADI;AAAA,aADR,EAIG+P,KAJH,CAIS,UAAAC,KAAK;AAAA,qBAAIC,OAAO,CAACD,KAAR,CAAcA,KAAd,CAAJ;AAAA,aAJd;AAKD;AACF,SAjGH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAmGGpU,CAAC,CAAC,sBAAD,CAnGJ,CADF,CAVF,CADF;AAoHD;AAhjBH;AAAA;AAAA,0DAowDgDiH,CApwDhD,EAowD2DC,CApwD3D,EAowDsE;AAClE,UAAMoN,oBAAoB,GAAGrW,4BAA4B,CAACuD,QAAD,EAAWyF,CAAX,EAAcC,CAAd,CAAzD;;AACA,UAAIoN,oBAAJ,EAA0B;AACxB,YAAM7I,cAAc,GAClB6I,oBAAoB,CAACrN,CAArB,GAAyBqN,oBAAoB,CAACtJ,KAArB,GAA6B,CADxD;AAEA,YAAMU,cAAc,GAClB4I,oBAAoB,CAACpN,CAArB,GAAyBoN,oBAAoB,CAACpJ,MAArB,GAA8B,CADzD;AAEA,YAAMqJ,gBAAgB,GAAGpD,IAAI,CAACqD,KAAL,CACvBvN,CAAC,GAAGwE,cADmB,EAEvBvE,CAAC,GAAGwE,cAFmB,CAAzB;AAIA,YAAM+I,iBAAiB,GACrBF,gBAAgB,GAAGzT,6BADrB;;AAEA,YAAI2T,iBAAJ,EAAuB;AACrB,cAAM9I,QAAQ,GACZ,KAAKnH,KAAL,CAAWuI,OAAX,GACAuH,oBAAoB,CAACrN,CADrB,GAEAqN,oBAAoB,CAACtJ,KAArB,GAA6B,CAH/B;AAIA,cAAMY,QAAQ,GACZ,KAAKpH,KAAL,CAAWwI,OAAX,GACAsH,oBAAoB,CAACpN,CADrB,GAEAoN,oBAAoB,CAACpJ,MAArB,GAA8B,CAHhC;AAIA,iBAAO;AAAES,YAAAA,QAAQ,EAARA,QAAF;AAAYC,YAAAA,QAAQ,EAARA,QAAZ;AAAsBH,YAAAA,cAAc,EAAdA,cAAtB;AAAsCC,YAAAA,cAAc,EAAdA;AAAtC,WAAP;AACD;AACF;AACF;AA7xDH;AAAA;AAAA,yCAkzDuB;AACnB,UAAI,KAAKlH,KAAL,CAAWkQ,eAAX,IAA8B,CAAC,KAAKlR,MAAxC,EAAgD;AAC9C,aAAKwB,sBAAL;AACD;;AACD,UAAM2P,qBAEL,GAAG,EAFJ;;AAGA,WAAK,IAAMC,QAAX,IAAuB,KAAKpQ,KAAL,CAAWyB,cAAlC,EAAkD;AAChD,YAAM4O,kBAAkB,GAAG,KAAKrQ,KAAL,CAAWyB,cAAX,CAA0B2O,QAA1B,CAA3B;AACAD,QAAAA,qBAAqB,CAACC,QAAD,CAArB,GAAkCvV,2BAA2B,CAC3D;AACE8L,UAAAA,MAAM,EAAE0J,kBAAkB,CAAC5N,CAD7B;AAEEmE,UAAAA,MAAM,EAAEyJ,kBAAkB,CAAC3N;AAF7B,SAD2D,EAK3D,KAAK1C,KALsD,EAM3D,KAAKlB,MANsD,CAA7D;AAQD;;AAjBkB,yBAkB8B1E,WAAW,CAC1D4C,QAD0D,EAE1D,KAAKgD,KAFqD,EAG1D,KAAKA,KAAL,CAAWsL,gBAH+C,EAI1D,KAAKvM,EAJqD,EAK1D,KAAKD,MALqD,EAM1D;AACEyJ,QAAAA,OAAO,EAAE,KAAKvI,KAAL,CAAWuI,OADtB;AAEEC,QAAAA,OAAO,EAAE,KAAKxI,KAAL,CAAWwI,OAFtB;AAGE8H,QAAAA,mBAAmB,EAAE,KAAKtQ,KAAL,CAAWsQ,mBAHlC;AAIEhL,QAAAA,IAAI,EAAE,KAAKtF,KAAL,CAAWsF,IAJnB;AAKEiL,QAAAA,2BAA2B,EAAEJ;AAL/B,OAN0D,EAa1D;AACEK,QAAAA,mBAAmB,EAAE;AADvB,OAb0D,CAlBzC;AAAA,UAkBXC,wBAlBW,gBAkBXA,wBAlBW;AAAA,UAkBeC,UAlBf,gBAkBeA,UAlBf;;AAmCnB,UAAIA,UAAJ,EAAgB;AACdhT,QAAAA,iBAAiB,GAAGgT,UAApB;AACD;;AACD,UAAMC,eAAe,GAAG,CAACF,wBAAD,IAA6BzT,QAAQ,CAACiM,MAAT,GAAkB,CAAvE;;AACA,UAAI,KAAKjJ,KAAL,CAAW2Q,eAAX,KAA+BA,eAAnC,EAAoD;AAClD,aAAKhR,QAAL,CAAc;AAAEgR,UAAAA,eAAe,EAAEA;AAAnB,SAAd;AACD;;AACD,WAAKtQ,aAAL;;AACA,UAAIjD,OAAO,CAACwT,WAAR,EAAJ,EAA2B;AACzB,aAAKhP,mBAAL,CAAyB;AACvBX,UAAAA,IAAI,EAAE,cADiB;AAEvBC,UAAAA,OAAO,EAAE;AACPlE,YAAAA,QAAQ,EAARA,QADO;AAEP4C,YAAAA,QAAQ,EAAE,KAAKI;AAFR;AAFc,SAAzB;AAOA5C,QAAAA,OAAO,CAACyT,SAAR,CAAkB,KAAK7Q,KAAvB,EAA8BhD,QAA9B;AACAI,QAAAA,OAAO,CAAC0T,aAAR;AACD;AACF;AAx2DH;;AAAA;AAAA,EAAyBxY,KAAK,CAACyY,SAA/B","sourcesContent":["import React from \"react\";\n\nimport socketIOClient from \"socket.io-client\";\nimport rough from \"roughjs/bin/rough\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Point } from \"roughjs/bin/geometry\";\n\nimport {\n  newElement,\n  newTextElement,\n  duplicateElement,\n  resizeTest,\n  normalizeResizeHandle,\n  isInvisiblySmallElement,\n  isTextElement,\n  textWysiwyg,\n  getCommonBounds,\n  getCursorForResizingElement,\n  getPerfectElementSize,\n  normalizeDimensions,\n} from \"../element\";\nimport {\n  deleteSelectedElements,\n  getElementsWithinSelection,\n  isOverScrollBars,\n  getElementAtPosition,\n  createScene,\n  getElementContainingPosition,\n  getNormalizedZoom,\n  getSelectedElements,\n  isSomeElementSelected,\n} from \"../scene\";\nimport {\n  decryptAESGEM,\n  encryptAESGEM,\n  saveToLocalStorage,\n  loadScene,\n  loadFromBlob,\n  SOCKET_SERVER,\n  SocketUpdateData,\n} from \"../data\";\nimport { restore } from \"../data/restore\";\n\nimport { renderScene } from \"../renderer\";\nimport { AppState, GestureEvent, Gesture } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\n\nimport {\n  isWritableElement,\n  isInputLike,\n  isToolIcon,\n  debounce,\n  distance,\n  distance2d,\n  resetCursor,\n  viewportCoordsToSceneCoords,\n  sceneCoordsToViewportCoords,\n} from \"../utils\";\nimport { KEYS, isArrowKey } from \"../keys\";\n\nimport { findShapeByKey, shapesShortcutKeys } from \"../shapes\";\nimport { createHistory } from \"../history\";\n\nimport ContextMenu from \"./ContextMenu\";\n\nimport { getElementWithResizeHandler } from \"../element/resizeTest\";\nimport { ActionManager } from \"../actions/manager\";\nimport \"../actions\";\nimport { actions } from \"../actions/register\";\n\nimport { ActionResult } from \"../actions/types\";\nimport { getDefaultAppState } from \"../appState\";\nimport { t, getLanguage } from \"../i18n\";\n\nimport { copyToAppClipboard, getClipboardContent } from \"../clipboard\";\nimport { normalizeScroll } from \"../scene\";\nimport { getCenter, getDistance } from \"../gesture\";\nimport { createUndoAction, createRedoAction } from \"../actions/actionHistory\";\nimport {\n  CURSOR_TYPE,\n  ELEMENT_SHIFT_TRANSLATE_AMOUNT,\n  ELEMENT_TRANSLATE_AMOUNT,\n  POINTER_BUTTON,\n  DRAGGING_THRESHOLD,\n  TEXT_TO_CENTER_SNAP_THRESHOLD,\n} from \"../constants\";\nimport { LayerUI } from \"./LayerUI\";\nimport { ScrollBars } from \"../scene/types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { generateCollaborationLink, getCollaborationLinkData } from \"../data\";\n\n// -----------------------------------------------------------------------------\n// TEST HOOKS\n// -----------------------------------------------------------------------------\n\ndeclare global {\n  interface Window {\n    __TEST__: {\n      elements: typeof elements;\n      appState: AppState;\n    };\n    // TEMPORARY until we have a UI to support this\n    generateCollaborationLink: () => Promise<string>;\n  }\n}\n\nif (process.env.NODE_ENV === \"test\") {\n  window.__TEST__ = {} as Window[\"__TEST__\"];\n}\nwindow.generateCollaborationLink = generateCollaborationLink;\n\n// -----------------------------------------------------------------------------\n\nlet { elements } = createScene();\n\nif (process.env.NODE_ENV === \"test\") {\n  Object.defineProperty(window.__TEST__, \"elements\", {\n    get() {\n      return elements;\n    },\n  });\n}\n\nconst { history } = createHistory();\n\nlet cursorX = 0;\nlet cursorY = 0;\nlet isHoldingSpace: boolean = false;\nlet isPanning: boolean = false;\nlet isDraggingScrollBar: boolean = false;\nlet currentScrollBars: ScrollBars = { horizontal: null, vertical: null };\n\nlet lastPointerUp: ((event: any) => void) | null = null;\nconst gesture: Gesture = {\n  pointers: new Map(),\n  lastCenter: null,\n  initialDistance: null,\n  initialScale: null,\n};\n\nfunction setCursorForShape(shape: string) {\n  if (shape === \"selection\") {\n    resetCursor();\n  } else {\n    document.documentElement.style.cursor =\n      shape === \"text\" ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR;\n  }\n}\n\nexport class App extends React.Component<any, AppState> {\n  canvas: HTMLCanvasElement | null = null;\n  rc: RoughCanvas | null = null;\n  socket: SocketIOClient.Socket | null = null;\n  socketInitialized: boolean = false; // we don't want the socket to emit any updates until it is fully initalized\n  roomID: string | null = null;\n  roomKey: string | null = null;\n\n  actionManager: ActionManager;\n  canvasOnlyActions = [\"selectAll\"];\n  constructor(props: any) {\n    super(props);\n    this.actionManager = new ActionManager(\n      this.syncActionResult,\n      () => this.state,\n      () => elements,\n    );\n    this.actionManager.registerAll(actions);\n\n    this.actionManager.registerAction(createUndoAction(history));\n    this.actionManager.registerAction(createRedoAction(history));\n  }\n\n  private syncActionResult = (\n    res: ActionResult,\n    commitToHistory: boolean = true,\n  ) => {\n    if (this.unmounted) {\n      return;\n    }\n    if (res.elements) {\n      elements = res.elements;\n      if (commitToHistory) {\n        history.resumeRecording();\n      }\n      this.setState({});\n    }\n\n    if (res.appState) {\n      if (commitToHistory) {\n        history.resumeRecording();\n      }\n      this.setState({ ...res.appState });\n    }\n  };\n\n  private onCut = (event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    copyToAppClipboard(elements, this.state);\n    const { elements: nextElements, appState } = deleteSelectedElements(\n      elements,\n      this.state,\n    );\n    elements = nextElements;\n    history.resumeRecording();\n    this.setState({ ...appState });\n    event.preventDefault();\n  };\n  private onCopy = (event: ClipboardEvent) => {\n    if (isWritableElement(event.target)) {\n      return;\n    }\n    copyToAppClipboard(elements, this.state);\n    event.preventDefault();\n  };\n\n  private onUnload = () => {\n    isHoldingSpace = false;\n    this.saveDebounced();\n    this.saveDebounced.flush();\n  };\n\n  private disableEvent: EventHandlerNonNull = event => {\n    event.preventDefault();\n  };\n\n  private initializeSocketClient = () => {\n    if (this.socket) {\n      return;\n    }\n    const roomMatch = getCollaborationLinkData(window.location.href);\n    if (roomMatch) {\n      this.socket = socketIOClient(SOCKET_SERVER);\n      this.roomID = roomMatch[1];\n      this.roomKey = roomMatch[2];\n      this.socket.on(\"init-room\", () => {\n        this.socket && this.socket.emit(\"join-room\", this.roomID);\n      });\n      this.socket.on(\n        \"client-broadcast\",\n        async (encryptedData: ArrayBuffer, iv: Uint8Array) => {\n          if (!this.roomKey) {\n            return;\n          }\n          const decryptedData = await decryptAESGEM(\n            encryptedData,\n            this.roomKey,\n            iv,\n          );\n\n          switch (decryptedData.type) {\n            case \"INVALID_RESPONSE\":\n              return;\n            case \"SCENE_UPDATE\":\n              const {\n                elements: sceneElements,\n                appState: sceneAppState,\n              } = decryptedData.payload;\n              const restoredState = restore(\n                sceneElements || [],\n                sceneAppState || getDefaultAppState(),\n                { scrollToContent: true },\n              );\n              elements = restoredState.elements;\n              this.setState({});\n              if (this.socketInitialized === false) {\n                this.socketInitialized = true;\n              }\n              break;\n            case \"MOUSE_LOCATION\":\n              const { socketID, pointerCoords } = decryptedData.payload;\n              this.setState({\n                remotePointers: {\n                  ...this.state.remotePointers,\n                  [socketID]: pointerCoords,\n                },\n              });\n              break;\n          }\n        },\n      );\n      this.socket.on(\"first-in-room\", () => {\n        if (this.socket) {\n          this.socket.off(\"first-in-room\");\n        }\n        this.socketInitialized = true;\n      });\n      this.socket.on(\"room-user-count\", (collaboratorCount: number) => {\n        this.setState({ collaboratorCount });\n      });\n      this.socket.on(\"new-user\", async (socketID: string) => {\n        this.broadcastSocketData({\n          type: \"SCENE_UPDATE\",\n          payload: {\n            elements,\n            appState: this.state,\n          },\n        });\n      });\n    }\n  };\n\n  private broadcastSocketData = async (data: SocketUpdateData) => {\n    if (this.socketInitialized && this.socket && this.roomID && this.roomKey) {\n      const json = JSON.stringify(data);\n      const encoded = new TextEncoder().encode(json);\n      const encrypted = await encryptAESGEM(encoded, this.roomKey);\n      this.socket.emit(\n        \"server-broadcast\",\n        this.roomID,\n        encrypted.data,\n        encrypted.iv,\n      );\n    }\n  };\n\n  private unmounted = false;\n  public async componentDidMount() {\n    if (process.env.NODE_ENV === \"test\") {\n      Object.defineProperty(window.__TEST__, \"appState\", {\n        configurable: true,\n        get: () => {\n          return this.state;\n        },\n      });\n    }\n\n    document.addEventListener(\"copy\", this.onCopy);\n    document.addEventListener(\"paste\", this.pasteFromClipboard);\n    document.addEventListener(\"cut\", this.onCut);\n\n    document.addEventListener(\"keydown\", this.onKeyDown, false);\n    document.addEventListener(\"keyup\", this.onKeyUp, { passive: true });\n    document.addEventListener(\"mousemove\", this.updateCurrentCursorPosition);\n    window.addEventListener(\"resize\", this.onResize, false);\n    window.addEventListener(\"unload\", this.onUnload, false);\n    window.addEventListener(\"blur\", this.onUnload, false);\n    window.addEventListener(\"dragover\", this.disableEvent, false);\n    window.addEventListener(\"drop\", this.disableEvent, false);\n\n    // Safari-only desktop pinch zoom\n    document.addEventListener(\n      \"gesturestart\",\n      this.onGestureStart as any,\n      false,\n    );\n    document.addEventListener(\n      \"gesturechange\",\n      this.onGestureChange as any,\n      false,\n    );\n    document.addEventListener(\"gestureend\", this.onGestureEnd as any, false);\n\n    const searchParams = new URLSearchParams(window.location.search);\n    const id = searchParams.get(\"id\");\n\n    if (id) {\n      // Backwards compatibility with legacy url format\n      const scene = await loadScene(id);\n      this.syncActionResult(scene);\n    }\n\n    const jsonMatch = window.location.hash.match(\n      /^#json=([0-9]+),([a-zA-Z0-9_-]+)$/,\n    );\n    if (jsonMatch) {\n      const scene = await loadScene(jsonMatch[1], jsonMatch[2]);\n      this.syncActionResult(scene);\n      return;\n    }\n\n    const roomMatch = getCollaborationLinkData(window.location.href);\n    if (roomMatch) {\n      this.initializeSocketClient();\n      return;\n    }\n    const scene = await loadScene(null);\n    this.syncActionResult(scene);\n  }\n\n  public componentWillUnmount() {\n    this.unmounted = true;\n    document.removeEventListener(\"copy\", this.onCopy);\n    document.removeEventListener(\"paste\", this.pasteFromClipboard);\n    document.removeEventListener(\"cut\", this.onCut);\n\n    document.removeEventListener(\"keydown\", this.onKeyDown, false);\n    document.removeEventListener(\n      \"mousemove\",\n      this.updateCurrentCursorPosition,\n      false,\n    );\n    document.removeEventListener(\"keyup\", this.onKeyUp);\n    window.removeEventListener(\"resize\", this.onResize, false);\n    window.removeEventListener(\"unload\", this.onUnload, false);\n    window.removeEventListener(\"blur\", this.onUnload, false);\n    window.removeEventListener(\"dragover\", this.disableEvent, false);\n    window.removeEventListener(\"drop\", this.disableEvent, false);\n\n    document.removeEventListener(\n      \"gesturestart\",\n      this.onGestureStart as any,\n      false,\n    );\n    document.removeEventListener(\n      \"gesturechange\",\n      this.onGestureChange as any,\n      false,\n    );\n    document.removeEventListener(\"gestureend\", this.onGestureEnd as any, false);\n  }\n\n  public state: AppState = getDefaultAppState();\n\n  private onResize = () => {\n    elements.forEach(element => invalidateShapeForElement(element));\n    this.setState({});\n  };\n\n  private updateCurrentCursorPosition = (event: MouseEvent) => {\n    cursorX = event.x;\n    cursorY = event.y;\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    if (\n      (isWritableElement(event.target) && event.key !== KEYS.ESCAPE) ||\n      // case: using arrows to move between buttons\n      (isArrowKey(event.key) && isInputLike(event.target))\n    ) {\n      return;\n    }\n\n    if (this.actionManager.handleKeyDown(event)) {\n      return;\n    }\n\n    const shape = findShapeByKey(event.key);\n\n    if (isArrowKey(event.key)) {\n      const step = event.shiftKey\n        ? ELEMENT_SHIFT_TRANSLATE_AMOUNT\n        : ELEMENT_TRANSLATE_AMOUNT;\n      elements = elements.map(el => {\n        if (this.state.selectedElementIds[el.id]) {\n          const element = { ...el };\n          if (event.key === KEYS.ARROW_LEFT) {\n            element.x -= step;\n          } else if (event.key === KEYS.ARROW_RIGHT) {\n            element.x += step;\n          } else if (event.key === KEYS.ARROW_UP) {\n            element.y -= step;\n          } else if (event.key === KEYS.ARROW_DOWN) {\n            element.y += step;\n          }\n          return element;\n        }\n        return el;\n      });\n      this.setState({});\n      event.preventDefault();\n    } else if (\n      shapesShortcutKeys.includes(event.key.toLowerCase()) &&\n      !event.ctrlKey &&\n      !event.altKey &&\n      !event.metaKey &&\n      this.state.draggingElement === null\n    ) {\n      this.selectShapeTool(shape);\n    } else if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {\n      isHoldingSpace = true;\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n    }\n  };\n\n  private onKeyUp = (event: KeyboardEvent) => {\n    if (event.key === KEYS.SPACE) {\n      if (this.state.elementType === \"selection\") {\n        resetCursor();\n      } else {\n        document.documentElement.style.cursor =\n          this.state.elementType === \"text\"\n            ? CURSOR_TYPE.TEXT\n            : CURSOR_TYPE.CROSSHAIR;\n        this.setState({ selectedElementIds: {} });\n      }\n      isHoldingSpace = false;\n    }\n  };\n\n  private copyToAppClipboard = () => {\n    copyToAppClipboard(elements, this.state);\n  };\n\n  private pasteFromClipboard = async (event: ClipboardEvent | null) => {\n    // #686\n    const target = document.activeElement;\n    const elementUnderCursor = document.elementFromPoint(cursorX, cursorY);\n    if (\n      // if no ClipboardEvent supplied, assume we're pasting via contextMenu\n      //  thus these checks don't make sense\n      !event ||\n      (elementUnderCursor instanceof HTMLCanvasElement &&\n        !isWritableElement(target))\n    ) {\n      const data = await getClipboardContent(event);\n      if (data.elements) {\n        this.addElementsFromPaste(data.elements);\n      } else if (data.text) {\n        const { x, y } = viewportCoordsToSceneCoords(\n          { clientX: cursorX, clientY: cursorY },\n          this.state,\n          this.canvas,\n        );\n\n        const element = newTextElement(\n          newElement(\n            \"text\",\n            x,\n            y,\n            this.state.currentItemStrokeColor,\n            this.state.currentItemBackgroundColor,\n            this.state.currentItemFillStyle,\n            this.state.currentItemStrokeWidth,\n            this.state.currentItemRoughness,\n            this.state.currentItemOpacity,\n          ),\n          data.text,\n          this.state.currentItemFont,\n        );\n\n        elements = [...elements, element];\n        this.setState({ selectedElementIds: { [element.id]: true } });\n        history.resumeRecording();\n      }\n      this.selectShapeTool(\"selection\");\n      event?.preventDefault();\n    }\n  };\n\n  private selectShapeTool(elementType: AppState[\"elementType\"]) {\n    if (!isHoldingSpace) {\n      setCursorForShape(elementType);\n    }\n    if (isToolIcon(document.activeElement)) {\n      document.activeElement.blur();\n    }\n    if (elementType !== \"selection\") {\n      this.setState({ elementType, selectedElementIds: {} });\n    } else {\n      this.setState({ elementType });\n    }\n  }\n\n  private onGestureStart = (event: GestureEvent) => {\n    event.preventDefault();\n    gesture.initialScale = this.state.zoom;\n  };\n  private onGestureChange = (event: GestureEvent) => {\n    event.preventDefault();\n\n    this.setState({\n      zoom: getNormalizedZoom(gesture.initialScale! * event.scale),\n    });\n  };\n  private onGestureEnd = (event: GestureEvent) => {\n    event.preventDefault();\n    gesture.initialScale = null;\n  };\n\n  setAppState = (obj: any) => {\n    this.setState(obj);\n  };\n\n  setElements = (elements_: readonly ExcalidrawElement[]) => {\n    elements = elements_;\n    this.setState({});\n  };\n\n  removePointer = (event: React.PointerEvent<HTMLElement>) => {\n    gesture.pointers.delete(event.pointerId);\n  };\n\n  public render() {\n    const canvasDOMWidth = window.innerWidth;\n    const canvasDOMHeight = window.innerHeight;\n\n    const canvasScale = window.devicePixelRatio;\n\n    const canvasWidth = canvasDOMWidth * canvasScale;\n    const canvasHeight = canvasDOMHeight * canvasScale;\n\n    return (\n      <div className=\"container\">\n        <LayerUI\n          canvas={this.canvas}\n          appState={this.state}\n          setAppState={this.setAppState}\n          actionManager={this.actionManager}\n          elements={elements}\n          setElements={this.setElements}\n          language={getLanguage()}\n        />\n        <main>\n          <canvas\n            id=\"canvas\"\n            style={{\n              width: canvasDOMWidth,\n              height: canvasDOMHeight,\n            }}\n            width={canvasWidth}\n            height={canvasHeight}\n            ref={canvas => {\n              // canvas is null when unmounting\n              if (canvas !== null) {\n                this.canvas = canvas;\n                this.rc = rough.canvas(this.canvas);\n\n                this.canvas.addEventListener(\"wheel\", this.handleWheel, {\n                  passive: false,\n                });\n\n                this.canvas\n                  .getContext(\"2d\")\n                  ?.setTransform(canvasScale, 0, 0, canvasScale, 0, 0);\n              } else {\n                this.canvas?.removeEventListener(\"wheel\", this.handleWheel);\n              }\n            }}\n            onContextMenu={event => {\n              event.preventDefault();\n\n              const { x, y } = viewportCoordsToSceneCoords(\n                event,\n                this.state,\n                this.canvas,\n              );\n\n              const element = getElementAtPosition(\n                elements,\n                this.state,\n                x,\n                y,\n                this.state.zoom,\n              );\n              if (!element) {\n                ContextMenu.push({\n                  options: [\n                    navigator.clipboard && {\n                      label: t(\"labels.paste\"),\n                      action: () => this.pasteFromClipboard(null),\n                    },\n                    ...this.actionManager.getContextMenuItems(action =>\n                      this.canvasOnlyActions.includes(action.name),\n                    ),\n                  ],\n                  top: event.clientY,\n                  left: event.clientX,\n                });\n                return;\n              }\n\n              if (!this.state.selectedElementIds[element.id]) {\n                this.setState({ selectedElementIds: { [element.id]: true } });\n              }\n\n              ContextMenu.push({\n                options: [\n                  navigator.clipboard && {\n                    label: t(\"labels.copy\"),\n                    action: this.copyToAppClipboard,\n                  },\n                  navigator.clipboard && {\n                    label: t(\"labels.paste\"),\n                    action: () => this.pasteFromClipboard(null),\n                  },\n                  ...this.actionManager.getContextMenuItems(\n                    action => !this.canvasOnlyActions.includes(action.name),\n                  ),\n                ],\n                top: event.clientY,\n                left: event.clientX,\n              });\n            }}\n            onPointerDown={this.handleCanvasPointerDown}\n            onDoubleClick={this.handleCanvasDoubleClick}\n            onPointerMove={this.handleCanvasPointerMove}\n            onPointerUp={this.removePointer}\n            onPointerCancel={this.removePointer}\n            onDrop={event => {\n              const file = event.dataTransfer.files[0];\n              if (\n                file?.type === \"application/json\" ||\n                file?.name.endsWith(\".excalidraw\")\n              ) {\n                loadFromBlob(file)\n                  .then(({ elements, appState }) =>\n                    this.syncActionResult({ elements, appState }),\n                  )\n                  .catch(error => console.error(error));\n              }\n            }}\n          >\n            {t(\"labels.drawingCanvas\")}\n          </canvas>\n        </main>\n      </div>\n    );\n  }\n\n  private handleCanvasDoubleClick = (\n    event: React.MouseEvent<HTMLCanvasElement>,\n  ) => {\n    resetCursor();\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n    );\n\n    const elementAtPosition = getElementAtPosition(\n      elements,\n      this.state,\n      x,\n      y,\n      this.state.zoom,\n    );\n\n    const element =\n      elementAtPosition && isTextElement(elementAtPosition)\n        ? elementAtPosition\n        : newTextElement(\n            newElement(\n              \"text\",\n              x,\n              y,\n              this.state.currentItemStrokeColor,\n              this.state.currentItemBackgroundColor,\n              this.state.currentItemFillStyle,\n              this.state.currentItemStrokeWidth,\n              this.state.currentItemRoughness,\n              this.state.currentItemOpacity,\n            ),\n            \"\", // default text\n            this.state.currentItemFont, // default font\n          );\n\n    this.setState({ editingElement: element });\n\n    let textX = event.clientX;\n    let textY = event.clientY;\n\n    if (elementAtPosition && isTextElement(elementAtPosition)) {\n      elements = elements.filter(\n        element => element.id !== elementAtPosition.id,\n      );\n      this.setState({});\n\n      const centerElementX = elementAtPosition.x + elementAtPosition.width / 2;\n      const centerElementY = elementAtPosition.y + elementAtPosition.height / 2;\n\n      const {\n        x: centerElementXInViewport,\n        y: centerElementYInViewport,\n      } = sceneCoordsToViewportCoords(\n        { sceneX: centerElementX, sceneY: centerElementY },\n        this.state,\n        this.canvas,\n      );\n\n      textX = centerElementXInViewport;\n      textY = centerElementYInViewport;\n\n      // x and y will change after calling newTextElement function\n      element.x = centerElementX;\n      element.y = centerElementY;\n    } else if (!event.altKey) {\n      const snappedToCenterPosition = this.getTextWysiwygSnappedToCenterPosition(\n        x,\n        y,\n      );\n\n      if (snappedToCenterPosition) {\n        element.x = snappedToCenterPosition.elementCenterX;\n        element.y = snappedToCenterPosition.elementCenterY;\n        textX = snappedToCenterPosition.wysiwygX;\n        textY = snappedToCenterPosition.wysiwygY;\n      }\n    }\n\n    const resetSelection = () => {\n      this.setState({\n        draggingElement: null,\n        editingElement: null,\n      });\n    };\n\n    textWysiwyg({\n      initText: element.text,\n      x: textX,\n      y: textY,\n      strokeColor: element.strokeColor,\n      font: element.font,\n      opacity: this.state.currentItemOpacity,\n      zoom: this.state.zoom,\n      onSubmit: text => {\n        if (text) {\n          elements = [\n            ...elements,\n            {\n              // we need to recreate the element to update dimensions &\n              //  position\n              ...newTextElement(element, text, element.font),\n            },\n          ];\n        }\n        this.setState(prevState => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [element.id]: true,\n          },\n        }));\n        history.resumeRecording();\n        resetSelection();\n      },\n      onCancel: () => {\n        resetSelection();\n      },\n    });\n  };\n\n  private handleCanvasPointerMove = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    const pointerCoords = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n    );\n    this.savePointer(pointerCoords);\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      const center = getCenter(gesture.pointers);\n      const deltaX = center.x - gesture.lastCenter!.x;\n      const deltaY = center.y - gesture.lastCenter!.y;\n      gesture.lastCenter = center;\n\n      const distance = getDistance(Array.from(gesture.pointers.values()));\n      const scaleFactor = distance / gesture.initialDistance!;\n\n      this.setState({\n        scrollX: normalizeScroll(this.state.scrollX + deltaX / this.state.zoom),\n        scrollY: normalizeScroll(this.state.scrollY + deltaY / this.state.zoom),\n        zoom: getNormalizedZoom(gesture.initialScale! * scaleFactor),\n      });\n    } else {\n      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;\n    }\n\n    if (isHoldingSpace || isPanning || isDraggingScrollBar) {\n      return;\n    }\n    const {\n      isOverHorizontalScrollBar,\n      isOverVerticalScrollBar,\n    } = isOverScrollBars(currentScrollBars, event.clientX, event.clientY);\n    const isOverScrollBar =\n      isOverVerticalScrollBar || isOverHorizontalScrollBar;\n    if (!this.state.draggingElement && !this.state.multiElement) {\n      if (isOverScrollBar) {\n        resetCursor();\n      } else {\n        setCursorForShape(this.state.elementType);\n      }\n    }\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n    );\n    if (this.state.multiElement) {\n      const { multiElement } = this.state;\n      const originX = multiElement.x;\n      const originY = multiElement.y;\n      const points = multiElement.points;\n      const pnt = points[points.length - 1];\n      pnt[0] = x - originX;\n      pnt[1] = y - originY;\n      invalidateShapeForElement(multiElement);\n      this.setState({});\n      return;\n    }\n\n    const hasDeselectedButton = Boolean(event.buttons);\n    if (hasDeselectedButton || this.state.elementType !== \"selection\") {\n      return;\n    }\n\n    const selectedElements = getSelectedElements(elements, this.state);\n    if (selectedElements.length === 1 && !isOverScrollBar) {\n      const resizeElement = getElementWithResizeHandler(\n        elements,\n        this.state,\n        { x, y },\n        this.state.zoom,\n        event.pointerType,\n      );\n      if (resizeElement && resizeElement.resizeHandle) {\n        document.documentElement.style.cursor = getCursorForResizingElement(\n          resizeElement,\n        );\n        return;\n      }\n    }\n    const hitElement = getElementAtPosition(\n      elements,\n      this.state,\n      x,\n      y,\n      this.state.zoom,\n    );\n    document.documentElement.style.cursor =\n      hitElement && !isOverScrollBar ? \"move\" : \"\";\n  };\n\n  private handleCanvasPointerDown = (\n    event: React.PointerEvent<HTMLCanvasElement>,\n  ) => {\n    if (lastPointerUp !== null) {\n      // Unfortunately, sometimes we don't get a pointerup after a pointerdown,\n      // this can happen when a contextual menu or alert is triggered. In order to avoid\n      // being in a weird state, we clean up on the next pointerdown\n      lastPointerUp(event);\n    }\n\n    if (isPanning) {\n      return;\n    }\n\n    this.setState({ lastPointerDownWith: event.pointerType });\n\n    // pan canvas on wheel button drag or space+drag\n    if (\n      gesture.pointers.size === 0 &&\n      (event.button === POINTER_BUTTON.WHEEL ||\n        (event.button === POINTER_BUTTON.MAIN && isHoldingSpace))\n    ) {\n      isPanning = true;\n      document.documentElement.style.cursor = CURSOR_TYPE.GRABBING;\n      let { clientX: lastX, clientY: lastY } = event;\n      const onPointerMove = (event: PointerEvent) => {\n        const deltaX = lastX - event.clientX;\n        const deltaY = lastY - event.clientY;\n        lastX = event.clientX;\n        lastY = event.clientY;\n\n        this.setState({\n          scrollX: normalizeScroll(\n            this.state.scrollX - deltaX / this.state.zoom,\n          ),\n          scrollY: normalizeScroll(\n            this.state.scrollY - deltaY / this.state.zoom,\n          ),\n        });\n      };\n      const teardown = (lastPointerUp = () => {\n        lastPointerUp = null;\n        isPanning = false;\n        if (!isHoldingSpace) {\n          setCursorForShape(this.state.elementType);\n        }\n        window.removeEventListener(\"pointermove\", onPointerMove);\n        window.removeEventListener(\"pointerup\", teardown);\n        window.removeEventListener(\"blur\", teardown);\n      });\n      window.addEventListener(\"blur\", teardown);\n      window.addEventListener(\"pointermove\", onPointerMove, {\n        passive: true,\n      });\n      window.addEventListener(\"pointerup\", teardown);\n      return;\n    }\n\n    // only handle left mouse button or touch\n    if (\n      event.button !== POINTER_BUTTON.MAIN &&\n      event.button !== POINTER_BUTTON.TOUCH\n    ) {\n      return;\n    }\n\n    gesture.pointers.set(event.pointerId, {\n      x: event.clientX,\n      y: event.clientY,\n    });\n\n    if (gesture.pointers.size === 2) {\n      gesture.lastCenter = getCenter(gesture.pointers);\n      gesture.initialScale = this.state.zoom;\n      gesture.initialDistance = getDistance(\n        Array.from(gesture.pointers.values()),\n      );\n    }\n\n    // fixes pointermove causing selection of UI texts #32\n    event.preventDefault();\n    // Preventing the event above disables default behavior\n    //  of defocusing potentially focused element, which is what we\n    //  want when clicking inside the canvas.\n    if (document.activeElement instanceof HTMLElement) {\n      document.activeElement.blur();\n    }\n\n    // don't select while panning\n    if (gesture.pointers.size > 1) {\n      return;\n    }\n\n    // Handle scrollbars dragging\n    const {\n      isOverHorizontalScrollBar,\n      isOverVerticalScrollBar,\n    } = isOverScrollBars(currentScrollBars, event.clientX, event.clientY);\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      event,\n      this.state,\n      this.canvas,\n    );\n    let lastX = x;\n    let lastY = y;\n\n    if (\n      (isOverHorizontalScrollBar || isOverVerticalScrollBar) &&\n      !this.state.multiElement\n    ) {\n      isDraggingScrollBar = true;\n      lastX = event.clientX;\n      lastY = event.clientY;\n      const onPointerMove = (event: PointerEvent) => {\n        const target = event.target;\n        if (!(target instanceof HTMLElement)) {\n          return;\n        }\n\n        if (isOverHorizontalScrollBar) {\n          const x = event.clientX;\n          const dx = x - lastX;\n          this.setState({\n            scrollX: normalizeScroll(this.state.scrollX - dx / this.state.zoom),\n          });\n          lastX = x;\n          return;\n        }\n\n        if (isOverVerticalScrollBar) {\n          const y = event.clientY;\n          const dy = y - lastY;\n          this.setState({\n            scrollY: normalizeScroll(this.state.scrollY - dy / this.state.zoom),\n          });\n          lastY = y;\n        }\n      };\n\n      const onPointerUp = () => {\n        isDraggingScrollBar = false;\n        setCursorForShape(this.state.elementType);\n        lastPointerUp = null;\n        window.removeEventListener(\"pointermove\", onPointerMove);\n        window.removeEventListener(\"pointerup\", onPointerUp);\n      };\n\n      lastPointerUp = onPointerUp;\n\n      window.addEventListener(\"pointermove\", onPointerMove);\n      window.addEventListener(\"pointerup\", onPointerUp);\n      return;\n    }\n\n    const originX = x;\n    const originY = y;\n\n    let element = newElement(\n      this.state.elementType,\n      x,\n      y,\n      this.state.currentItemStrokeColor,\n      this.state.currentItemBackgroundColor,\n      this.state.currentItemFillStyle,\n      this.state.currentItemStrokeWidth,\n      this.state.currentItemRoughness,\n      this.state.currentItemOpacity,\n    );\n\n    if (isTextElement(element)) {\n      element = newTextElement(element, \"\", this.state.currentItemFont);\n    }\n\n    type ResizeTestType = ReturnType<typeof resizeTest>;\n    let resizeHandle: ResizeTestType = false;\n    let isResizingElements = false;\n    let draggingOccurred = false;\n    let hitElement: ExcalidrawElement | null = null;\n    let elementIsAddedToSelection = false;\n    if (this.state.elementType === \"selection\") {\n      const resizeElement = getElementWithResizeHandler(\n        elements,\n        this.state,\n        { x, y },\n        this.state.zoom,\n        event.pointerType,\n      );\n\n      const selectedElements = getSelectedElements(elements, this.state);\n      if (selectedElements.length === 1 && resizeElement) {\n        this.setState({\n          resizingElement: resizeElement ? resizeElement.element : null,\n        });\n\n        resizeHandle = resizeElement.resizeHandle;\n        document.documentElement.style.cursor = getCursorForResizingElement(\n          resizeElement,\n        );\n        isResizingElements = true;\n      } else {\n        hitElement = getElementAtPosition(\n          elements,\n          this.state,\n          x,\n          y,\n          this.state.zoom,\n        );\n        // clear selection if shift is not clicked\n        if (\n          !(hitElement && this.state.selectedElementIds[hitElement.id]) &&\n          !event.shiftKey\n        ) {\n          this.setState({ selectedElementIds: {} });\n        }\n\n        // If we click on something\n        if (hitElement) {\n          // deselect if item is selected\n          // if shift is not clicked, this will always return true\n          // otherwise, it will trigger selection based on current\n          // state of the box\n          if (!this.state.selectedElementIds[hitElement.id]) {\n            this.setState(prevState => ({\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [hitElement!.id]: true,\n              },\n            }));\n            elements = elements.slice();\n            elementIsAddedToSelection = true;\n          }\n\n          // We duplicate the selected element if alt is pressed on pointer down\n          if (event.altKey) {\n            // Move the currently selected elements to the top of the z index stack, and\n            // put the duplicates where the selected elements used to be.\n            const nextElements = [];\n            const elementsToAppend = [];\n            for (const element of elements) {\n              if (this.state.selectedElementIds[element.id]) {\n                nextElements.push(duplicateElement(element));\n                elementsToAppend.push(element);\n              } else {\n                nextElements.push(element);\n              }\n            }\n            elements = [...nextElements, ...elementsToAppend];\n          }\n        }\n      }\n    } else {\n      this.setState({ selectedElementIds: {} });\n    }\n\n    if (isTextElement(element)) {\n      // if we're currently still editing text, clicking outside\n      //  should only finalize it, not create another (irrespective\n      //  of state.elementLocked)\n      if (this.state.editingElement?.type === \"text\") {\n        return;\n      }\n      if (elementIsAddedToSelection) {\n        element = hitElement!;\n      }\n      let textX = event.clientX;\n      let textY = event.clientY;\n      if (!event.altKey) {\n        const snappedToCenterPosition = this.getTextWysiwygSnappedToCenterPosition(\n          x,\n          y,\n        );\n        if (snappedToCenterPosition) {\n          element.x = snappedToCenterPosition.elementCenterX;\n          element.y = snappedToCenterPosition.elementCenterY;\n          textX = snappedToCenterPosition.wysiwygX;\n          textY = snappedToCenterPosition.wysiwygY;\n        }\n      }\n\n      const resetSelection = () => {\n        this.setState({\n          draggingElement: null,\n          editingElement: null,\n        });\n      };\n\n      textWysiwyg({\n        initText: \"\",\n        x: textX,\n        y: textY,\n        strokeColor: this.state.currentItemStrokeColor,\n        opacity: this.state.currentItemOpacity,\n        font: this.state.currentItemFont,\n        zoom: this.state.zoom,\n        onSubmit: text => {\n          if (text) {\n            elements = [\n              ...elements,\n              {\n                ...newTextElement(element, text, this.state.currentItemFont),\n              },\n            ];\n          }\n          this.setState(prevState => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [element.id]: true,\n            },\n          }));\n          if (this.state.elementLocked) {\n            setCursorForShape(this.state.elementType);\n          }\n          history.resumeRecording();\n          resetSelection();\n        },\n        onCancel: () => {\n          resetSelection();\n        },\n      });\n      resetCursor();\n      if (!this.state.elementLocked) {\n        this.setState({\n          editingElement: element,\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          editingElement: element,\n        });\n      }\n      return;\n    } else if (\n      this.state.elementType === \"arrow\" ||\n      this.state.elementType === \"line\"\n    ) {\n      if (this.state.multiElement) {\n        const { multiElement } = this.state;\n        const { x: rx, y: ry } = multiElement;\n        this.setState(prevState => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [multiElement.id]: true,\n          },\n        }));\n        multiElement.points.push([x - rx, y - ry]);\n        invalidateShapeForElement(multiElement);\n      } else {\n        this.setState(prevState => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [element.id]: false,\n          },\n        }));\n        element.points.push([0, 0]);\n        invalidateShapeForElement(element);\n        elements = [...elements, element];\n        this.setState({\n          draggingElement: element,\n        });\n      }\n    } else if (element.type === \"selection\") {\n      this.setState({\n        selectionElement: element,\n        draggingElement: element,\n      });\n    } else {\n      elements = [...elements, element];\n      this.setState({ multiElement: null, draggingElement: element });\n    }\n\n    let resizeArrowFn:\n      | ((\n          element: ExcalidrawElement,\n          p1: Point,\n          deltaX: number,\n          deltaY: number,\n          pointerX: number,\n          pointerY: number,\n          perfect: boolean,\n        ) => void)\n      | null = null;\n\n    const arrowResizeOrigin = (\n      element: ExcalidrawElement,\n      p1: Point,\n      deltaX: number,\n      deltaY: number,\n      pointerX: number,\n      pointerY: number,\n      perfect: boolean,\n    ) => {\n      if (perfect) {\n        const absPx = p1[0] + element.x;\n        const absPy = p1[1] + element.y;\n\n        const { width, height } = getPerfectElementSize(\n          element.type,\n          pointerX - element.x - p1[0],\n          pointerY - element.y - p1[1],\n        );\n\n        const dx = element.x + width + p1[0];\n        const dy = element.y + height + p1[1];\n        element.x = dx;\n        element.y = dy;\n        p1[0] = absPx - element.x;\n        p1[1] = absPy - element.y;\n      } else {\n        element.x += deltaX;\n        element.y += deltaY;\n        p1[0] -= deltaX;\n        p1[1] -= deltaY;\n      }\n    };\n\n    const arrowResizeEnd = (\n      element: ExcalidrawElement,\n      p1: Point,\n      deltaX: number,\n      deltaY: number,\n      pointerX: number,\n      pointerY: number,\n      perfect: boolean,\n    ) => {\n      if (perfect) {\n        const { width, height } = getPerfectElementSize(\n          element.type,\n          pointerX - element.x,\n          pointerY - element.y,\n        );\n        p1[0] = width;\n        p1[1] = height;\n      } else {\n        p1[0] += deltaX;\n        p1[1] += deltaY;\n      }\n    };\n\n    const onPointerMove = (event: PointerEvent) => {\n      const target = event.target;\n      if (!(target instanceof HTMLElement)) {\n        return;\n      }\n\n      if (isOverHorizontalScrollBar) {\n        const x = event.clientX;\n        const dx = x - lastX;\n        this.setState({\n          scrollX: normalizeScroll(this.state.scrollX - dx / this.state.zoom),\n        });\n        lastX = x;\n        return;\n      }\n\n      if (isOverVerticalScrollBar) {\n        const y = event.clientY;\n        const dy = y - lastY;\n        this.setState({\n          scrollY: normalizeScroll(this.state.scrollY - dy / this.state.zoom),\n        });\n        lastY = y;\n        return;\n      }\n\n      // for arrows, don't start dragging until a given threshold\n      //  to ensure we don't create a 2-point arrow by mistake when\n      //  user clicks mouse in a way that it moves a tiny bit (thus\n      //  triggering pointermove)\n      if (\n        !draggingOccurred &&\n        (this.state.elementType === \"arrow\" ||\n          this.state.elementType === \"line\")\n      ) {\n        const { x, y } = viewportCoordsToSceneCoords(\n          event,\n          this.state,\n          this.canvas,\n        );\n        if (distance2d(x, y, originX, originY) < DRAGGING_THRESHOLD) {\n          return;\n        }\n      }\n\n      if (isResizingElements && this.state.resizingElement) {\n        this.setState({ isResizing: true });\n        const el = this.state.resizingElement;\n        const selectedElements = getSelectedElements(elements, this.state);\n        if (selectedElements.length === 1) {\n          const { x, y } = viewportCoordsToSceneCoords(\n            event,\n            this.state,\n            this.canvas,\n          );\n          const deltaX = x - lastX;\n          const deltaY = y - lastY;\n          const element = selectedElements[0];\n          const isLinear = element.type === \"line\" || element.type === \"arrow\";\n          switch (resizeHandle) {\n            case \"nw\":\n              if (isLinear && element.points.length === 2) {\n                const [, p1] = element.points;\n\n                if (!resizeArrowFn) {\n                  if (p1[0] < 0 || p1[1] < 0) {\n                    resizeArrowFn = arrowResizeEnd;\n                  } else {\n                    resizeArrowFn = arrowResizeOrigin;\n                  }\n                }\n                resizeArrowFn(\n                  element,\n                  p1,\n                  deltaX,\n                  deltaY,\n                  x,\n                  y,\n                  event.shiftKey,\n                );\n              } else {\n                element.width -= deltaX;\n                element.x += deltaX;\n\n                if (event.shiftKey) {\n                  element.y += element.height - element.width;\n                  element.height = element.width;\n                } else {\n                  element.height -= deltaY;\n                  element.y += deltaY;\n                }\n              }\n              break;\n            case \"ne\":\n              if (isLinear && element.points.length === 2) {\n                const [, p1] = element.points;\n                if (!resizeArrowFn) {\n                  if (p1[0] >= 0) {\n                    resizeArrowFn = arrowResizeEnd;\n                  } else {\n                    resizeArrowFn = arrowResizeOrigin;\n                  }\n                }\n                resizeArrowFn(\n                  element,\n                  p1,\n                  deltaX,\n                  deltaY,\n                  x,\n                  y,\n                  event.shiftKey,\n                );\n              } else {\n                element.width += deltaX;\n                if (event.shiftKey) {\n                  element.y += element.height - element.width;\n                  element.height = element.width;\n                } else {\n                  element.height -= deltaY;\n                  element.y += deltaY;\n                }\n              }\n              break;\n            case \"sw\":\n              if (isLinear && element.points.length === 2) {\n                const [, p1] = element.points;\n                if (!resizeArrowFn) {\n                  if (p1[0] <= 0) {\n                    resizeArrowFn = arrowResizeEnd;\n                  } else {\n                    resizeArrowFn = arrowResizeOrigin;\n                  }\n                }\n                resizeArrowFn(\n                  element,\n                  p1,\n                  deltaX,\n                  deltaY,\n                  x,\n                  y,\n                  event.shiftKey,\n                );\n              } else {\n                element.width -= deltaX;\n                element.x += deltaX;\n                if (event.shiftKey) {\n                  element.height = element.width;\n                } else {\n                  element.height += deltaY;\n                }\n              }\n              break;\n            case \"se\":\n              if (isLinear && element.points.length === 2) {\n                const [, p1] = element.points;\n                if (!resizeArrowFn) {\n                  if (p1[0] > 0 || p1[1] > 0) {\n                    resizeArrowFn = arrowResizeEnd;\n                  } else {\n                    resizeArrowFn = arrowResizeOrigin;\n                  }\n                }\n                resizeArrowFn(\n                  element,\n                  p1,\n                  deltaX,\n                  deltaY,\n                  x,\n                  y,\n                  event.shiftKey,\n                );\n              } else {\n                if (event.shiftKey) {\n                  element.width += deltaX;\n                  element.height = element.width;\n                } else {\n                  element.width += deltaX;\n                  element.height += deltaY;\n                }\n              }\n              break;\n            case \"n\": {\n              element.height -= deltaY;\n              element.y += deltaY;\n\n              if (element.points.length > 0) {\n                const len = element.points.length;\n\n                const points = [...element.points].sort((a, b) => a[1] - b[1]);\n\n                for (let i = 1; i < points.length; ++i) {\n                  const pnt = points[i];\n                  pnt[1] -= deltaY / (len - i);\n                }\n              }\n              break;\n            }\n            case \"w\": {\n              element.width -= deltaX;\n              element.x += deltaX;\n\n              if (element.points.length > 0) {\n                const len = element.points.length;\n                const points = [...element.points].sort((a, b) => a[0] - b[0]);\n\n                for (let i = 0; i < points.length; ++i) {\n                  const pnt = points[i];\n                  pnt[0] -= deltaX / (len - i);\n                }\n              }\n              break;\n            }\n            case \"s\": {\n              element.height += deltaY;\n              if (element.points.length > 0) {\n                const len = element.points.length;\n                const points = [...element.points].sort((a, b) => a[1] - b[1]);\n\n                for (let i = 1; i < points.length; ++i) {\n                  const pnt = points[i];\n                  pnt[1] += deltaY / (len - i);\n                }\n              }\n              break;\n            }\n            case \"e\": {\n              element.width += deltaX;\n              if (element.points.length > 0) {\n                const len = element.points.length;\n                const points = [...element.points].sort((a, b) => a[0] - b[0]);\n\n                for (let i = 1; i < points.length; ++i) {\n                  const pnt = points[i];\n                  pnt[0] += deltaX / (len - i);\n                }\n              }\n              break;\n            }\n          }\n\n          if (resizeHandle) {\n            resizeHandle = normalizeResizeHandle(element, resizeHandle);\n          }\n          normalizeDimensions(element);\n\n          document.documentElement.style.cursor = getCursorForResizingElement({\n            element,\n            resizeHandle,\n          });\n          el.x = element.x;\n          el.y = element.y;\n          invalidateShapeForElement(el);\n\n          lastX = x;\n          lastY = y;\n          this.setState({});\n          return;\n        }\n      }\n\n      if (hitElement && this.state.selectedElementIds[hitElement.id]) {\n        // Marking that click was used for dragging to check\n        // if elements should be deselected on pointerup\n        draggingOccurred = true;\n        const selectedElements = getSelectedElements(elements, this.state);\n        if (selectedElements.length > 0) {\n          const { x, y } = viewportCoordsToSceneCoords(\n            event,\n            this.state,\n            this.canvas,\n          );\n\n          selectedElements.forEach(element => {\n            element.x += x - lastX;\n            element.y += y - lastY;\n          });\n          lastX = x;\n          lastY = y;\n          this.setState({});\n          return;\n        }\n      }\n\n      // It is very important to read this.state within each move event,\n      // otherwise we would read a stale one!\n      const draggingElement = this.state.draggingElement;\n      if (!draggingElement) {\n        return;\n      }\n\n      const { x, y } = viewportCoordsToSceneCoords(\n        event,\n        this.state,\n        this.canvas,\n      );\n\n      let width = distance(originX, x);\n      let height = distance(originY, y);\n\n      const isLinear =\n        this.state.elementType === \"line\" || this.state.elementType === \"arrow\";\n\n      if (isLinear) {\n        draggingOccurred = true;\n        const points = draggingElement.points;\n        let dx = x - draggingElement.x;\n        let dy = y - draggingElement.y;\n\n        if (event.shiftKey && points.length === 2) {\n          ({ width: dx, height: dy } = getPerfectElementSize(\n            this.state.elementType,\n            dx,\n            dy,\n          ));\n        }\n\n        if (points.length === 1) {\n          points.push([dx, dy]);\n        } else if (points.length > 1) {\n          const pnt = points[points.length - 1];\n          pnt[0] = dx;\n          pnt[1] = dy;\n        }\n      } else {\n        if (event.shiftKey) {\n          ({ width, height } = getPerfectElementSize(\n            this.state.elementType,\n            width,\n            y < originY ? -height : height,\n          ));\n\n          if (height < 0) {\n            height = -height;\n          }\n        }\n\n        draggingElement.x = x < originX ? originX - width : originX;\n        draggingElement.y = y < originY ? originY - height : originY;\n\n        draggingElement.width = width;\n        draggingElement.height = height;\n      }\n\n      invalidateShapeForElement(draggingElement);\n\n      if (this.state.elementType === \"selection\") {\n        if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {\n          this.setState({ selectedElementIds: {} });\n        }\n        const elementsWithinSelection = getElementsWithinSelection(\n          elements,\n          draggingElement,\n        );\n        this.setState(prevState => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            ...Object.fromEntries(\n              elementsWithinSelection.map(element => [element.id, true]),\n            ),\n          },\n        }));\n      }\n      this.setState({});\n    };\n\n    const onPointerUp = (event: PointerEvent) => {\n      const {\n        draggingElement,\n        resizingElement,\n        multiElement,\n        elementType,\n        elementLocked,\n      } = this.state;\n\n      this.setState({\n        isResizing: false,\n        resizingElement: null,\n        selectionElement: null,\n      });\n\n      resizeArrowFn = null;\n      lastPointerUp = null;\n      window.removeEventListener(\"pointermove\", onPointerMove);\n      window.removeEventListener(\"pointerup\", onPointerUp);\n\n      if (elementType === \"arrow\" || elementType === \"line\") {\n        if (draggingElement!.points.length > 1) {\n          history.resumeRecording();\n          this.setState({});\n        }\n        if (!draggingOccurred && draggingElement && !multiElement) {\n          const { x, y } = viewportCoordsToSceneCoords(\n            event,\n            this.state,\n            this.canvas,\n          );\n          draggingElement.points.push([\n            x - draggingElement.x,\n            y - draggingElement.y,\n          ]);\n          invalidateShapeForElement(draggingElement);\n          this.setState({ multiElement: this.state.draggingElement });\n        } else if (draggingOccurred && !multiElement) {\n          if (!elementLocked) {\n            resetCursor();\n            this.setState(prevState => ({\n              draggingElement: null,\n              elementType: \"selection\",\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          } else {\n            this.setState(prevState => ({\n              draggingElement: null,\n              selectedElementIds: {\n                ...prevState.selectedElementIds,\n                [this.state.draggingElement!.id]: true,\n              },\n            }));\n          }\n        }\n        return;\n      }\n\n      if (\n        elementType !== \"selection\" &&\n        draggingElement &&\n        isInvisiblySmallElement(draggingElement)\n      ) {\n        // remove invisible element which was added in onPointerDown\n        elements = elements.slice(0, -1);\n        this.setState({\n          draggingElement: null,\n        });\n        return;\n      }\n\n      if (normalizeDimensions(draggingElement)) {\n        this.setState({});\n      }\n\n      if (resizingElement) {\n        history.resumeRecording();\n        this.setState({});\n      }\n\n      if (resizingElement && isInvisiblySmallElement(resizingElement)) {\n        elements = elements.filter(el => el.id !== resizingElement.id);\n      }\n\n      // If click occurred on already selected element\n      // it is needed to remove selection from other elements\n      // or if SHIFT or META key pressed remove selection\n      // from hitted element\n      //\n      // If click occurred and elements were dragged or some element\n      // was added to selection (on pointerdown phase) we need to keep\n      // selection unchanged\n      if (hitElement && !draggingOccurred && !elementIsAddedToSelection) {\n        if (event.shiftKey) {\n          this.setState(prevState => ({\n            selectedElementIds: {\n              ...prevState.selectedElementIds,\n              [hitElement!.id]: false,\n            },\n          }));\n        } else {\n          this.setState(prevState => ({\n            selectedElementIds: { [hitElement!.id]: true },\n          }));\n        }\n      }\n\n      if (draggingElement === null) {\n        // if no element is clicked, clear the selection and redraw\n        this.setState({ selectedElementIds: {} });\n        return;\n      }\n\n      if (!elementLocked) {\n        this.setState(prevState => ({\n          selectedElementIds: {\n            ...prevState.selectedElementIds,\n            [draggingElement.id]: true,\n          },\n        }));\n      }\n\n      if (\n        elementType !== \"selection\" ||\n        isSomeElementSelected(elements, this.state)\n      ) {\n        history.resumeRecording();\n      }\n\n      if (!elementLocked) {\n        resetCursor();\n        this.setState({\n          draggingElement: null,\n          elementType: \"selection\",\n        });\n      } else {\n        this.setState({\n          draggingElement: null,\n        });\n      }\n    };\n\n    lastPointerUp = onPointerUp;\n\n    window.addEventListener(\"pointermove\", onPointerMove);\n    window.addEventListener(\"pointerup\", onPointerUp);\n  };\n\n  private handleWheel = (event: WheelEvent) => {\n    event.preventDefault();\n    const { deltaX, deltaY } = event;\n\n    // note that event.ctrlKey is necessary to handle pinch zooming\n    if (event.metaKey || event.ctrlKey) {\n      const sign = Math.sign(deltaY);\n      const MAX_STEP = 10;\n      let delta = Math.abs(deltaY);\n      if (delta > MAX_STEP) {\n        delta = MAX_STEP;\n      }\n      delta *= sign;\n      this.setState(({ zoom }) => ({\n        zoom: getNormalizedZoom(zoom - delta / 100),\n      }));\n      return;\n    }\n\n    this.setState(({ zoom, scrollX, scrollY }) => ({\n      scrollX: normalizeScroll(scrollX - deltaX / zoom),\n      scrollY: normalizeScroll(scrollY - deltaY / zoom),\n    }));\n  };\n\n  private addElementsFromPaste = (\n    clipboardElements: readonly ExcalidrawElement[],\n  ) => {\n    const [minX, minY, maxX, maxY] = getCommonBounds(clipboardElements);\n\n    const elementsCenterX = distance(minX, maxX) / 2;\n    const elementsCenterY = distance(minY, maxY) / 2;\n\n    const { x, y } = viewportCoordsToSceneCoords(\n      { clientX: cursorX, clientY: cursorY },\n      this.state,\n      this.canvas,\n    );\n\n    const dx = x - elementsCenterX;\n    const dy = y - elementsCenterY;\n\n    const newElements = clipboardElements.map(clipboardElements => {\n      const duplicate = duplicateElement(clipboardElements);\n      duplicate.x += dx - minX;\n      duplicate.y += dy - minY;\n      return duplicate;\n    });\n\n    elements = [...elements, ...newElements];\n    history.resumeRecording();\n    this.setState({\n      selectedElementIds: Object.fromEntries(\n        newElements.map(element => [element.id, true]),\n      ),\n    });\n  };\n\n  private getTextWysiwygSnappedToCenterPosition(x: number, y: number) {\n    const elementClickedInside = getElementContainingPosition(elements, x, y);\n    if (elementClickedInside) {\n      const elementCenterX =\n        elementClickedInside.x + elementClickedInside.width / 2;\n      const elementCenterY =\n        elementClickedInside.y + elementClickedInside.height / 2;\n      const distanceToCenter = Math.hypot(\n        x - elementCenterX,\n        y - elementCenterY,\n      );\n      const isSnappedToCenter =\n        distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;\n      if (isSnappedToCenter) {\n        const wysiwygX =\n          this.state.scrollX +\n          elementClickedInside.x +\n          elementClickedInside.width / 2;\n        const wysiwygY =\n          this.state.scrollY +\n          elementClickedInside.y +\n          elementClickedInside.height / 2;\n        return { wysiwygX, wysiwygY, elementCenterX, elementCenterY };\n      }\n    }\n  }\n\n  private savePointer = (pointerCoords: { x: number; y: number }) => {\n    if (isNaN(pointerCoords.x) || isNaN(pointerCoords.y)) {\n      // sometimes the pointer goes off screen\n      return;\n    }\n    this.socket &&\n      this.broadcastSocketData({\n        type: \"MOUSE_LOCATION\",\n        payload: {\n          socketID: this.socket.id,\n          pointerCoords,\n        },\n      });\n  };\n\n  private saveDebounced = debounce(() => {\n    saveToLocalStorage(elements, this.state);\n  }, 300);\n\n  componentDidUpdate() {\n    if (this.state.isCollaborating && !this.socket) {\n      this.initializeSocketClient();\n    }\n    const pointerViewportCoords: {\n      [id: string]: { x: number; y: number };\n    } = {};\n    for (const clientId in this.state.remotePointers) {\n      const remotePointerCoord = this.state.remotePointers[clientId];\n      pointerViewportCoords[clientId] = sceneCoordsToViewportCoords(\n        {\n          sceneX: remotePointerCoord.x,\n          sceneY: remotePointerCoord.y,\n        },\n        this.state,\n        this.canvas,\n      );\n    }\n    const { atLeastOneVisibleElement, scrollBars } = renderScene(\n      elements,\n      this.state,\n      this.state.selectionElement,\n      this.rc!,\n      this.canvas!,\n      {\n        scrollX: this.state.scrollX,\n        scrollY: this.state.scrollY,\n        viewBackgroundColor: this.state.viewBackgroundColor,\n        zoom: this.state.zoom,\n        remotePointerViewportCoords: pointerViewportCoords,\n      },\n      {\n        renderOptimizations: true,\n      },\n    );\n    if (scrollBars) {\n      currentScrollBars = scrollBars;\n    }\n    const scrolledOutside = !atLeastOneVisibleElement && elements.length > 0;\n    if (this.state.scrolledOutside !== scrolledOutside) {\n      this.setState({ scrolledOutside: scrolledOutside });\n    }\n    this.saveDebounced();\n    if (history.isRecording()) {\n      this.broadcastSocketData({\n        type: \"SCENE_UPDATE\",\n        payload: {\n          elements,\n          appState: this.state,\n        },\n      });\n      history.pushEntry(this.state, elements);\n      history.skipRecording();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}