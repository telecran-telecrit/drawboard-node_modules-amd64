{"ast":null,"code":"import _slicedToArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { isTextElement } from \"../element/typeChecks\";\nimport { getDiamondPoints, getArrowPoints, getElementAbsoluteCoords } from \"../element/bounds\";\nimport { SVG_NS, distance } from \"../utils\";\nimport rough from \"roughjs/bin/rough\";\nvar CANVAS_PADDING = 20;\n\nfunction generateElementCanvas(element, zoom) {\n  var canvas = document.createElement(\"canvas\");\n  var context = canvas.getContext(\"2d\");\n  var isLinear = /\\b(arrow|line)\\b/.test(element.type);\n  var canvasOffsetX = 0;\n  var canvasOffsetY = 0;\n\n  if (isLinear) {\n    var _getElementAbsoluteCo = getElementAbsoluteCoords(element),\n        _getElementAbsoluteCo2 = _slicedToArray(_getElementAbsoluteCo, 4),\n        x1 = _getElementAbsoluteCo2[0],\n        y1 = _getElementAbsoluteCo2[1],\n        x2 = _getElementAbsoluteCo2[2],\n        y2 = _getElementAbsoluteCo2[3];\n\n    canvas.width = distance(x1, x2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height = distance(y1, y2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvasOffsetX = element.x > x1 ? Math.floor(distance(element.x, x1)) * window.devicePixelRatio : 0;\n    canvasOffsetY = element.y > y1 ? Math.floor(distance(element.y, y1)) * window.devicePixelRatio : 0;\n    context.translate(canvasOffsetX * zoom, canvasOffsetY * zoom);\n  } else {\n    canvas.width = element.width * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height = element.height * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n  }\n\n  context.translate(CANVAS_PADDING, CANVAS_PADDING);\n  context.scale(window.devicePixelRatio * zoom, window.devicePixelRatio * zoom);\n  var rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(-CANVAS_PADDING, -CANVAS_PADDING);\n  return {\n    element: element,\n    canvas: canvas,\n    canvasZoom: zoom,\n    canvasOffsetX: canvasOffsetX,\n    canvasOffsetY: canvasOffsetY\n  };\n}\n\nfunction drawElementOnCanvas(element, rc, context) {\n  context.globalAlpha = element.opacity / 100;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        rc.draw(getShapeForElement(element));\n        break;\n      }\n\n    case \"arrow\":\n    case \"line\":\n      {\n        getShapeForElement(element).forEach(function (shape) {\n          return rc.draw(shape);\n        });\n        break;\n      }\n\n    default:\n      {\n        if (isTextElement(element)) {\n          var font = context.font;\n          context.font = element.font;\n          var fillStyle = context.fillStyle;\n          context.fillStyle = element.strokeColor; // Canvas does not support multiline text by default\n\n          var lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          var lineHeight = element.height / lines.length;\n          var offset = element.height - element.baseline;\n\n          for (var i = 0; i < lines.length; i++) {\n            context.fillText(lines[i], 0, (i + 1) * lineHeight - offset);\n          }\n\n          context.fillStyle = fillStyle;\n          context.font = font;\n        } else {\n          throw new Error(\"Unimplemented type \".concat(element.type));\n        }\n      }\n  }\n\n  context.globalAlpha = 1;\n}\n\nvar elementWithCanvasCache = new WeakMap();\nvar shapeCache = new WeakMap();\nexport function getShapeForElement(element) {\n  return shapeCache.get(element);\n}\nexport function invalidateShapeForElement(element) {\n  shapeCache.delete(element);\n}\n\nfunction generateElement(element, generator, sceneState) {\n  var shape = shapeCache.get(element) || null;\n\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        shape = generator.rectangle(0, 0, element.width, element.height, {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed\n        });\n        break;\n\n      case \"diamond\":\n        {\n          var _getDiamondPoints = getDiamondPoints(element),\n              _getDiamondPoints2 = _slicedToArray(_getDiamondPoints, 8),\n              topX = _getDiamondPoints2[0],\n              topY = _getDiamondPoints2[1],\n              rightX = _getDiamondPoints2[2],\n              rightY = _getDiamondPoints2[3],\n              bottomX = _getDiamondPoints2[4],\n              bottomY = _getDiamondPoints2[5],\n              leftX = _getDiamondPoints2[6],\n              leftY = _getDiamondPoints2[7];\n\n          shape = generator.polygon([[topX, topY], [rightX, rightY], [bottomX, bottomY], [leftX, leftY]], {\n            stroke: element.strokeColor,\n            fill: element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor,\n            fillStyle: element.fillStyle,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed\n          });\n          break;\n        }\n\n      case \"ellipse\":\n        shape = generator.ellipse(element.width / 2, element.height / 2, element.width, element.height, {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed,\n          curveFitting: 1\n        });\n        break;\n\n      case \"line\":\n      case \"arrow\":\n        {\n          var options = {\n            stroke: element.strokeColor,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed\n          }; // points array can be empty in the beginning, so it is important to add\n          // initial position to it\n\n          var points = element.points.length ? element.points : [[0, 0]]; // curve is always the first element\n          // this simplifies finding the curve for an element\n\n          shape = [generator.curve(points, options)]; // add lines only in arrow\n\n          if (element.type === \"arrow\") {\n            var _shape;\n\n            var _getArrowPoints = getArrowPoints(element, shape),\n                _getArrowPoints2 = _slicedToArray(_getArrowPoints, 6),\n                x2 = _getArrowPoints2[0],\n                y2 = _getArrowPoints2[1],\n                x3 = _getArrowPoints2[2],\n                y3 = _getArrowPoints2[3],\n                x4 = _getArrowPoints2[4],\n                y4 = _getArrowPoints2[5];\n\n            (_shape = shape).push.apply(_shape, [generator.line(x3, y3, x2, y2, options), generator.line(x4, y4, x2, y2, options)]);\n          }\n\n          break;\n        }\n\n      case \"text\":\n        {\n          // just to ensure we don't regenerate element.canvas on rerenders\n          shape = [];\n          break;\n        }\n    }\n\n    shapeCache.set(element, shape);\n  }\n\n  var zoom = sceneState ? sceneState.zoom : 1;\n  var prevElementWithCanvas = elementWithCanvasCache.get(element);\n\n  if (!prevElementWithCanvas || prevElementWithCanvas.canvasZoom !== zoom) {\n    var elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n\n  return prevElementWithCanvas;\n}\n\nfunction drawElementFromCanvas(elementWithCanvas, rc, context, sceneState) {\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(-CANVAS_PADDING / sceneState.zoom, -CANVAS_PADDING / sceneState.zoom);\n  context.drawImage(elementWithCanvas.canvas, Math.floor(-elementWithCanvas.canvasOffsetX + (Math.floor(elementWithCanvas.element.x) + sceneState.scrollX) * window.devicePixelRatio), Math.floor(-elementWithCanvas.canvasOffsetY + (Math.floor(elementWithCanvas.element.y) + sceneState.scrollY) * window.devicePixelRatio), elementWithCanvas.canvas.width / sceneState.zoom, elementWithCanvas.canvas.height / sceneState.zoom);\n  context.translate(CANVAS_PADDING / sceneState.zoom, CANVAS_PADDING / sceneState.zoom);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n}\n\nexport function renderElement(element, rc, context, renderOptimizations, sceneState) {\n  var generator = rc.generator;\n\n  switch (element.type) {\n    case \"selection\":\n      {\n        context.translate(element.x + sceneState.scrollX, element.y + sceneState.scrollY);\n        var fillStyle = context.fillStyle;\n        context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n        context.fillRect(0, 0, element.width, element.height);\n        context.fillStyle = fillStyle;\n        break;\n      }\n\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"text\":\n      {\n        var elementWithCanvas = generateElement(element, generator, sceneState);\n\n        if (renderOptimizations) {\n          drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n        } else {\n          var offsetX = Math.floor(element.x + sceneState.scrollX);\n          var offsetY = Math.floor(element.y + sceneState.scrollY);\n          context.translate(offsetX, offsetY);\n          drawElementOnCanvas(element, rc, context);\n          context.translate(-offsetX, -offsetY);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        throw new Error(\"Unimplemented type \".concat(element.type));\n      }\n  }\n}\nexport function renderElementToSvg(element, rsvg, svgRoot, offsetX, offsetY) {\n  var generator = rsvg.generator;\n\n  switch (element.type) {\n    case \"selection\":\n      {\n        // Since this is used only during editing experience, which is canvas based,\n        // this should not happen\n        throw new Error(\"Selection rendering is not supported for SVG\");\n      }\n\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        generateElement(element, generator);\n        var node = rsvg.draw(getShapeForElement(element));\n        var opacity = element.opacity / 100;\n\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", \"\".concat(opacity));\n          node.setAttribute(\"fill-opacity\", \"\".concat(opacity));\n        }\n\n        node.setAttribute(\"transform\", \"translate(\".concat(offsetX || 0, \" \").concat(offsetY || 0, \")\"));\n        svgRoot.appendChild(node);\n        break;\n      }\n\n    case \"line\":\n    case \"arrow\":\n      {\n        generateElement(element, generator);\n        var group = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n\n        var _opacity = element.opacity / 100;\n\n        getShapeForElement(element).forEach(function (shape) {\n          var node = rsvg.draw(shape);\n\n          if (_opacity !== 1) {\n            node.setAttribute(\"stroke-opacity\", \"\".concat(_opacity));\n            node.setAttribute(\"fill-opacity\", \"\".concat(_opacity));\n          }\n\n          node.setAttribute(\"transform\", \"translate(\".concat(offsetX || 0, \" \").concat(offsetY || 0, \")\"));\n          group.appendChild(node);\n        });\n        svgRoot.appendChild(group);\n        break;\n      }\n\n    default:\n      {\n        if (isTextElement(element)) {\n          var _opacity2 = element.opacity / 100;\n\n          var _node = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n\n          if (_opacity2 !== 1) {\n            _node.setAttribute(\"stroke-opacity\", \"\".concat(_opacity2));\n\n            _node.setAttribute(\"fill-opacity\", \"\".concat(_opacity2));\n          }\n\n          _node.setAttribute(\"transform\", \"translate(\".concat(offsetX || 0, \" \").concat(offsetY || 0, \")\"));\n\n          var lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          var lineHeight = element.height / lines.length;\n          var offset = element.height - element.baseline;\n          var fontSplit = element.font.split(\" \").filter(function (d) {\n            return !!d.trim();\n          });\n          var fontFamily = fontSplit[0];\n          var fontSize = \"20px\";\n\n          if (fontSplit.length > 1) {\n            fontFamily = fontSplit[1];\n            fontSize = fontSplit[0];\n          }\n\n          for (var i = 0; i < lines.length; i++) {\n            var text = svgRoot.ownerDocument.createElementNS(SVG_NS, \"text\");\n            text.textContent = lines[i];\n            text.setAttribute(\"x\", \"0\");\n            text.setAttribute(\"y\", \"\".concat((i + 1) * lineHeight - offset));\n            text.setAttribute(\"font-family\", fontFamily);\n            text.setAttribute(\"font-size\", fontSize);\n            text.setAttribute(\"fill\", element.strokeColor);\n\n            _node.appendChild(text);\n          }\n\n          svgRoot.appendChild(_node);\n        } else {\n          throw new Error(\"Unimplemented type \".concat(element.type));\n        }\n      }\n  }\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/renderer/renderElement.ts"],"names":["isTextElement","getDiamondPoints","getArrowPoints","getElementAbsoluteCoords","SVG_NS","distance","rough","CANVAS_PADDING","generateElementCanvas","element","zoom","canvas","document","createElement","context","getContext","isLinear","test","type","canvasOffsetX","canvasOffsetY","x1","y1","x2","y2","width","window","devicePixelRatio","height","x","Math","floor","y","translate","scale","rc","drawElementOnCanvas","canvasZoom","globalAlpha","opacity","draw","getShapeForElement","forEach","shape","font","fillStyle","strokeColor","lines","text","replace","split","lineHeight","length","offset","baseline","i","fillText","Error","elementWithCanvasCache","WeakMap","shapeCache","get","invalidateShapeForElement","delete","generateElement","generator","sceneState","rectangle","stroke","fill","backgroundColor","undefined","strokeWidth","roughness","seed","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","polygon","ellipse","curveFitting","options","points","curve","x3","y3","x4","y4","push","line","set","prevElementWithCanvas","elementWithCanvas","drawElementFromCanvas","drawImage","scrollX","scrollY","renderElement","renderOptimizations","fillRect","offsetX","offsetY","renderElementToSvg","rsvg","svgRoot","node","setAttribute","appendChild","group","ownerDocument","createElementNS","fontSplit","filter","d","trim","fontFamily","fontSize","textContent"],"mappings":"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","sourcesContent":["import { ExcalidrawElement, ExcalidrawTextElement } from \"../element/types\";\nimport { isTextElement } from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getArrowPoints,\n  getElementAbsoluteCoords,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { Point } from \"roughjs/bin/geometry\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport { SVG_NS, distance } from \"../utils\";\nimport rough from \"roughjs/bin/rough\";\n\nconst CANVAS_PADDING = 20;\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: number;\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nfunction generateElementCanvas(\n  element: ExcalidrawElement,\n  zoom: number,\n): ExcalidrawElementWithCanvas {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n\n  const isLinear = /\\b(arrow|line)\\b/.test(element.type);\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinear) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) * window.devicePixelRatio\n        : 0;\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) * window.devicePixelRatio\n        : 0;\n    context.translate(canvasOffsetX * zoom, canvasOffsetY * zoom);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n  }\n\n  context.translate(CANVAS_PADDING, CANVAS_PADDING);\n  context.scale(window.devicePixelRatio * zoom, window.devicePixelRatio * zoom);\n\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(-CANVAS_PADDING, -CANVAS_PADDING);\n  return { element, canvas, canvasZoom: zoom, canvasOffsetX, canvasOffsetY };\n}\n\nfunction drawElementOnCanvas(\n  element: ExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      (getShapeForElement(element) as Drawable[]).forEach(shape =>\n        rc.draw(shape),\n      );\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const font = context.font;\n        context.font = element.font;\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const offset = element.height - element.baseline;\n        for (let i = 0; i < lines.length; i++) {\n          context.fillText(lines[i], 0, (i + 1) * lineHeight - offset);\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n}\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport function getShapeForElement(element: ExcalidrawElement) {\n  return shapeCache.get(element);\n}\n\nexport function invalidateShapeForElement(element: ExcalidrawElement) {\n  shapeCache.delete(element);\n}\n\nfunction generateElement(\n  element: ExcalidrawElement,\n  generator: RoughGenerator,\n  sceneState?: SceneState,\n) {\n  let shape = shapeCache.get(element) || null;\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n    switch (element.type) {\n      case \"rectangle\":\n        shape = generator.rectangle(0, 0, element.width, element.height, {\n          stroke: element.strokeColor,\n          fill:\n            element.backgroundColor === \"transparent\"\n              ? undefined\n              : element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed,\n        });\n\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          {\n            stroke: element.strokeColor,\n            fill:\n              element.backgroundColor === \"transparent\"\n                ? undefined\n                : element.backgroundColor,\n            fillStyle: element.fillStyle,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed,\n          },\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          {\n            stroke: element.strokeColor,\n            fill:\n              element.backgroundColor === \"transparent\"\n                ? undefined\n                : element.backgroundColor,\n            fillStyle: element.fillStyle,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed,\n            curveFitting: 1,\n          },\n        );\n        break;\n      case \"line\":\n      case \"arrow\": {\n        const options = {\n          stroke: element.strokeColor,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed,\n        };\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points: Point[] = element.points.length\n          ? element.points\n          : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        shape = [generator.curve(points, options)];\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const [x2, y2, x3, y3, x4, y4] = getArrowPoints(element, shape);\n          shape.push(\n            ...[\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ],\n          );\n        }\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n  const zoom = sceneState ? sceneState.zoom : 1;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  if (!prevElementWithCanvas || prevElementWithCanvas.canvasZoom !== zoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n}\n\nfunction drawElementFromCanvas(\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) {\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(\n    -CANVAS_PADDING / sceneState.zoom,\n    -CANVAS_PADDING / sceneState.zoom,\n  );\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    Math.floor(\n      -elementWithCanvas.canvasOffsetX +\n        (Math.floor(elementWithCanvas.element.x) + sceneState.scrollX) *\n          window.devicePixelRatio,\n    ),\n    Math.floor(\n      -elementWithCanvas.canvasOffsetY +\n        (Math.floor(elementWithCanvas.element.y) + sceneState.scrollY) *\n          window.devicePixelRatio,\n    ),\n    elementWithCanvas.canvas!.width / sceneState.zoom,\n    elementWithCanvas.canvas!.height / sceneState.zoom,\n  );\n  context.translate(\n    CANVAS_PADDING / sceneState.zoom,\n    CANVAS_PADDING / sceneState.zoom,\n  );\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n}\n\nexport function renderElement(\n  element: ExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"text\": {\n      const elementWithCanvas = generateElement(element, generator, sceneState);\n\n      if (renderOptimizations) {\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const offsetX = Math.floor(element.x + sceneState.scrollX);\n        const offsetY = Math.floor(element.y + sceneState.scrollY);\n        context.translate(offsetX, offsetY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(-offsetX, -offsetY);\n      }\n      break;\n    }\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n}\n\nexport function renderElementToSvg(\n  element: ExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) {\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElement(element, generator);\n      const node = rsvg.draw(getShapeForElement(element) as Drawable);\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${offsetY || 0})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"arrow\": {\n      generateElement(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      (getShapeForElement(element) as Drawable[]).forEach(shape => {\n        const node = rsvg.draw(shape);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${offsetY || 0})`,\n        );\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${offsetY || 0})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const offset = element.height - element.baseline;\n        const fontSplit = element.font.split(\" \").filter(d => !!d.trim());\n        let fontFamily = fontSplit[0];\n        let fontSize = \"20px\";\n        if (fontSplit.length > 1) {\n          fontFamily = fontSplit[1];\n          fontSize = fontSplit[0];\n        }\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", \"0\");\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - offset}`);\n          text.setAttribute(\"font-family\", fontFamily);\n          text.setAttribute(\"font-size\", fontSize);\n          text.setAttribute(\"fill\", element.strokeColor);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}