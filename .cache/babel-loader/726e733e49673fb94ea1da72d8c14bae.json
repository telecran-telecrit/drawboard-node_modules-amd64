{"ast":null,"code":"import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughCanvas {\n  constructor(canvas, config) {\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.gen = new RoughGenerator(config, this.canvas);\n  }\n\n  draw(drawable) {\n    const sets = drawable.sets || [];\n    const o = drawable.options || this.getDefaultOptions();\n    const ctx = this.ctx;\n\n    for (const drawing of sets) {\n      switch (drawing.type) {\n        case 'path':\n          ctx.save();\n          ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n          ctx.lineWidth = o.strokeWidth;\n\n          this._drawToContext(ctx, drawing);\n\n          ctx.restore();\n          break;\n\n        case 'fillPath':\n          ctx.save();\n          ctx.fillStyle = o.fill || '';\n          const fillRule = drawable.shape === 'curve' || drawable.shape === 'polygon' ? 'evenodd' : 'nonzero';\n\n          this._drawToContext(ctx, drawing, fillRule);\n\n          ctx.restore();\n          break;\n\n        case 'fillSketch':\n          this.fillSketch(ctx, drawing, o);\n          break;\n\n        case 'path2Dfill':\n          {\n            this.ctx.save();\n            this.ctx.fillStyle = o.fill || '';\n            const p2d = new Path2D(drawing.path);\n            this.ctx.fill(p2d, 'evenodd');\n            this.ctx.restore();\n            break;\n          }\n\n        case 'path2Dpattern':\n          {\n            const doc = this.canvas.ownerDocument || hasDocument && document;\n\n            if (doc) {\n              const size = drawing.size;\n              const hcanvas = doc.createElement('canvas');\n              const hcontext = hcanvas.getContext('2d');\n              const bbox = this.computeBBox(drawing.path);\n\n              if (bbox && (bbox.width || bbox.height)) {\n                hcanvas.width = this.canvas.width;\n                hcanvas.height = this.canvas.height;\n                hcontext.translate(bbox.x || 0, bbox.y || 0);\n              } else {\n                hcanvas.width = size[0];\n                hcanvas.height = size[1];\n              }\n\n              this.fillSketch(hcontext, drawing, o);\n              this.ctx.save();\n              this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n              const p2d = new Path2D(drawing.path);\n              this.ctx.fill(p2d, 'evenodd');\n              this.ctx.restore();\n            } else {\n              console.error('Pattern fill fail: No defs');\n            }\n\n            break;\n          }\n      }\n    }\n  }\n\n  computeBBox(d) {\n    if (hasDocument) {\n      try {\n        const svg = document.createElementNS(SVGNS, 'svg');\n        svg.setAttribute('width', '0');\n        svg.setAttribute('height', '0');\n        const pathNode = self.document.createElementNS(SVGNS, 'path');\n        pathNode.setAttribute('d', d);\n        svg.appendChild(pathNode);\n        document.body.appendChild(svg);\n        const bbox = pathNode.getBBox();\n        document.body.removeChild(svg);\n        return bbox;\n      } catch (err) {}\n    }\n\n    return null;\n  }\n\n  fillSketch(ctx, drawing, o) {\n    let fweight = o.fillWeight;\n\n    if (fweight < 0) {\n      fweight = o.strokeWidth / 2;\n    }\n\n    ctx.save();\n    ctx.strokeStyle = o.fill || '';\n    ctx.lineWidth = fweight;\n\n    this._drawToContext(ctx, drawing);\n\n    ctx.restore();\n  }\n\n  _drawToContext(ctx, drawing, rule = 'nonzero') {\n    ctx.beginPath();\n\n    for (const item of drawing.ops) {\n      const data = item.data;\n\n      switch (item.op) {\n        case 'move':\n          ctx.moveTo(data[0], data[1]);\n          break;\n\n        case 'bcurveTo':\n          ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n          break;\n\n        case 'qcurveTo':\n          ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n          break;\n\n        case 'lineTo':\n          ctx.lineTo(data[0], data[1]);\n          break;\n      }\n    }\n\n    if (drawing.type === 'fillPath') {\n      ctx.fill(rule);\n    } else {\n      ctx.stroke();\n    }\n  }\n\n  get generator() {\n    return this.gen;\n  }\n\n  getDefaultOptions() {\n    return this.gen.defaultOptions;\n  }\n\n  line(x1, y1, x2, y2, options) {\n    const d = this.gen.line(x1, y1, x2, y2, options);\n    this.draw(d);\n    return d;\n  }\n\n  rectangle(x, y, width, height, options) {\n    const d = this.gen.rectangle(x, y, width, height, options);\n    this.draw(d);\n    return d;\n  }\n\n  ellipse(x, y, width, height, options) {\n    const d = this.gen.ellipse(x, y, width, height, options);\n    this.draw(d);\n    return d;\n  }\n\n  circle(x, y, diameter, options) {\n    const d = this.gen.circle(x, y, diameter, options);\n    this.draw(d);\n    return d;\n  }\n\n  linearPath(points, options) {\n    const d = this.gen.linearPath(points, options);\n    this.draw(d);\n    return d;\n  }\n\n  polygon(points, options) {\n    const d = this.gen.polygon(points, options);\n    this.draw(d);\n    return d;\n  }\n\n  arc(x, y, width, height, start, stop, closed = false, options) {\n    const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n    this.draw(d);\n    return d;\n  }\n\n  curve(points, options) {\n    const d = this.gen.curve(points, options);\n    this.draw(d);\n    return d;\n  }\n\n  path(d, options) {\n    const drawing = this.gen.path(d, options);\n    this.draw(drawing);\n    return drawing;\n  }\n\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/canvas.js"],"names":["SVGNS","RoughGenerator","hasDocument","document","RoughCanvas","constructor","canvas","config","ctx","getContext","gen","draw","drawable","sets","o","options","getDefaultOptions","drawing","type","save","strokeStyle","stroke","lineWidth","strokeWidth","_drawToContext","restore","fillStyle","fill","fillRule","shape","fillSketch","p2d","Path2D","path","doc","ownerDocument","size","hcanvas","createElement","hcontext","bbox","computeBBox","width","height","translate","x","y","createPattern","console","error","d","svg","createElementNS","setAttribute","pathNode","self","appendChild","body","getBBox","removeChild","err","fweight","fillWeight","rule","beginPath","item","ops","data","op","moveTo","bezierCurveTo","quadraticCurveTo","lineTo","generator","defaultOptions","line","x1","y1","x2","y2","rectangle","ellipse","circle","diameter","linearPath","points","polygon","arc","start","stop","closed","curve"],"mappings":"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","sourcesContent":["import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new RoughGenerator(config, this.canvas);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillPath':\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, fillRule);\n                    ctx.restore();\n                    break;\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n                case 'path2Dfill': {\n                    this.ctx.save();\n                    this.ctx.fillStyle = o.fill || '';\n                    const p2d = new Path2D(drawing.path);\n                    this.ctx.fill(p2d, 'evenodd');\n                    this.ctx.restore();\n                    break;\n                }\n                case 'path2Dpattern': {\n                    const doc = this.canvas.ownerDocument || (hasDocument && document);\n                    if (doc) {\n                        const size = drawing.size;\n                        const hcanvas = doc.createElement('canvas');\n                        const hcontext = hcanvas.getContext('2d');\n                        const bbox = this.computeBBox(drawing.path);\n                        if (bbox && (bbox.width || bbox.height)) {\n                            hcanvas.width = this.canvas.width;\n                            hcanvas.height = this.canvas.height;\n                            hcontext.translate(bbox.x || 0, bbox.y || 0);\n                        }\n                        else {\n                            hcanvas.width = size[0];\n                            hcanvas.height = size[1];\n                        }\n                        this.fillSketch(hcontext, drawing, o);\n                        this.ctx.save();\n                        this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n                        const p2d = new Path2D(drawing.path);\n                        this.ctx.fill(p2d, 'evenodd');\n                        this.ctx.restore();\n                    }\n                    else {\n                        console.error('Pattern fill fail: No defs');\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    computeBBox(d) {\n        if (hasDocument) {\n            try {\n                const svg = document.createElementNS(SVGNS, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(SVGNS, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                document.body.appendChild(svg);\n                const bbox = pathNode.getBBox();\n                document.body.removeChild(svg);\n                return bbox;\n            }\n            catch (err) { }\n        }\n        return null;\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'qcurveTo':\n                    ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}