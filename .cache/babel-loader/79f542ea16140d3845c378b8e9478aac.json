{"ast":null,"code":"import _slicedToArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { getElementAbsoluteCoords, handlerRectangles } from \"../element\";\nimport { roundRect } from \"./roundRect\";\nimport { getScrollBars, SCROLLBAR_COLOR, SCROLLBAR_WIDTH } from \"../scene/scrollbars\";\nimport { getZoomTranslation } from \"../scene/zoom\";\nimport { getSelectedElements } from \"../scene/selection\";\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nexport function renderScene(elements, appState, selectionElement, rc, canvas, sceneState) {\n  var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {},\n      _ref$renderScrollbars = _ref.renderScrollbars,\n      renderScrollbars = _ref$renderScrollbars === void 0 ? true : _ref$renderScrollbars,\n      _ref$renderSelection = _ref.renderSelection,\n      renderSelection = _ref$renderSelection === void 0 ? true : _ref$renderSelection,\n      _ref$renderOptimizati = _ref.renderOptimizations,\n      renderOptimizations = _ref$renderOptimizati === void 0 ? false : _ref$renderOptimizati;\n\n  if (!canvas) {\n    return {\n      atLeastOneVisibleElement: false\n    };\n  }\n\n  var context = canvas.getContext(\"2d\"); // Get initial scale transform as reference for later usage\n\n  var initialContextTransform = context.getTransform(); // When doing calculations based on canvas width we should used normalized one\n\n  var normalizedCanvasWidth = canvas.width / getContextTransformScaleX(initialContextTransform);\n  var normalizedCanvasHeight = canvas.height / getContextTransformScaleY(initialContextTransform);\n  var zoomTranslation = getZoomTranslation(canvas, sceneState.zoom);\n\n  function applyZoom(context) {\n    context.save(); // Handle zoom scaling\n\n    context.setTransform(getContextTransformScaleX(initialContextTransform) * sceneState.zoom, 0, 0, getContextTransformScaleY(initialContextTransform) * sceneState.zoom, getContextTransformTranslateX(context.getTransform()), getContextTransformTranslateY(context.getTransform())); // Handle zoom translation\n\n    context.setTransform(getContextTransformScaleX(context.getTransform()), 0, 0, getContextTransformScaleY(context.getTransform()), getContextTransformTranslateX(initialContextTransform) - zoomTranslation.x, getContextTransformTranslateY(initialContextTransform) - zoomTranslation.y);\n  }\n\n  function resetZoom(context) {\n    context.restore();\n  } // Paint background\n\n\n  context.save();\n\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    var hasTransparence = sceneState.viewBackgroundColor === \"transparent\" || sceneState.viewBackgroundColor.length === 5 || sceneState.viewBackgroundColor.length === 9;\n\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  context.restore(); // Paint visible elements\n\n  var visibleElements = elements.filter(function (element) {\n    return isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, sceneState);\n  });\n  applyZoom(context);\n  visibleElements.forEach(function (element) {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  });\n  resetZoom(context); // Pain selection element\n\n  if (selectionElement) {\n    applyZoom(context);\n    renderElement(selectionElement, rc, context, renderOptimizations, sceneState);\n    resetZoom(context);\n  } // Pain selected elements\n\n\n  if (renderSelection) {\n    var selectedElements = getSelectedElements(elements, appState);\n    var dashledLinePadding = 4 / sceneState.zoom;\n    applyZoom(context);\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    selectedElements.forEach(function (element) {\n      var _getElementAbsoluteCo = getElementAbsoluteCoords(element),\n          _getElementAbsoluteCo2 = _slicedToArray(_getElementAbsoluteCo, 4),\n          elementX1 = _getElementAbsoluteCo2[0],\n          elementY1 = _getElementAbsoluteCo2[1],\n          elementX2 = _getElementAbsoluteCo2[2],\n          elementY2 = _getElementAbsoluteCo2[3];\n\n      var elementWidth = elementX2 - elementX1;\n      var elementHeight = elementY2 - elementY1;\n      var initialLineDash = context.getLineDash();\n      context.setLineDash([8 / sceneState.zoom, 4 / sceneState.zoom]);\n      context.strokeRect(elementX1 - dashledLinePadding, elementY1 - dashledLinePadding, elementWidth + dashledLinePadding * 2, elementHeight + dashledLinePadding * 2);\n      context.setLineDash(initialLineDash);\n    });\n    resetZoom(context); // Paint resize handlers\n\n    if (selectedElements.length === 1 && selectedElements[0].type !== \"text\") {\n      applyZoom(context);\n      context.translate(sceneState.scrollX, sceneState.scrollY);\n      var handlers = handlerRectangles(selectedElements[0], sceneState.zoom);\n      Object.values(handlers).filter(function (handler) {\n        return handler !== undefined;\n      }).forEach(function (handler) {\n        context.strokeRect(handler[0], handler[1], handler[2], handler[3]);\n      });\n      resetZoom(context);\n    }\n  } // Paint remote pointers\n\n\n  for (var clientId in sceneState.remotePointerViewportCoords) {\n    var _sceneState$remotePoi = sceneState.remotePointerViewportCoords[clientId],\n        x = _sceneState$remotePoi.x,\n        y = _sceneState$remotePoi.y;\n    context.beginPath();\n    context.arc(x, y, 5, 0, 2 * Math.PI);\n    context.fill();\n    context.stroke();\n  } // Paint scrollbars\n\n\n  if (renderScrollbars) {\n    var scrollBars = getScrollBars(elements, normalizedCanvasWidth, normalizedCanvasHeight, sceneState);\n    context.save();\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(function (scrollBar) {\n      if (scrollBar) {\n        roundRect(context, scrollBar.x, scrollBar.y, scrollBar.width, scrollBar.height, SCROLLBAR_WIDTH / 2);\n      }\n    });\n    context.restore();\n    return {\n      atLeastOneVisibleElement: visibleElements.length > 0,\n      scrollBars: scrollBars\n    };\n  }\n\n  return {\n    atLeastOneVisibleElement: visibleElements.length > 0\n  };\n}\n\nfunction isVisibleElement(element, viewportWidth, viewportHeight, _ref2) {\n  var scrollX = _ref2.scrollX,\n      scrollY = _ref2.scrollY,\n      zoom = _ref2.zoom;\n\n  var _getElementAbsoluteCo3 = getElementAbsoluteCoords(element),\n      _getElementAbsoluteCo4 = _slicedToArray(_getElementAbsoluteCo3, 4),\n      x1 = _getElementAbsoluteCo4[0],\n      y1 = _getElementAbsoluteCo4[1],\n      x2 = _getElementAbsoluteCo4[2],\n      y2 = _getElementAbsoluteCo4[3]; // Apply zoom\n\n\n  var viewportWidthWithZoom = viewportWidth / zoom;\n  var viewportHeightWithZoom = viewportHeight / zoom;\n  var viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  var viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n  return x2 + scrollX - viewportWidthDiff / 2 >= 0 && x1 + scrollX - viewportWidthDiff / 2 <= viewportWidthWithZoom && y2 + scrollY - viewportHeightDiff / 2 >= 0 && y1 + scrollY - viewportHeightDiff / 2 <= viewportHeightWithZoom;\n} // This should be only called for exporting purposes\n\n\nexport function renderSceneToSvg(elements, rsvg, svgRoot) {\n  var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref3$offsetX = _ref3.offsetX,\n      offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,\n      _ref3$offsetY = _ref3.offsetY,\n      offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY;\n\n  if (!svgRoot) {\n    return;\n  } // render elements\n\n\n  elements.forEach(function (element) {\n    renderElementToSvg(element, rsvg, svgRoot, element.x + offsetX, element.y + offsetY);\n  });\n}\n\nfunction getContextTransformScaleX(transform) {\n  return transform.a;\n}\n\nfunction getContextTransformScaleY(transform) {\n  return transform.d;\n}\n\nfunction getContextTransformTranslateX(transform) {\n  return transform.e;\n}\n\nfunction getContextTransformTranslateY(transform) {\n  return transform.f;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/renderer/renderScene.ts"],"names":["getElementAbsoluteCoords","handlerRectangles","roundRect","getScrollBars","SCROLLBAR_COLOR","SCROLLBAR_WIDTH","getZoomTranslation","getSelectedElements","renderElement","renderElementToSvg","renderScene","elements","appState","selectionElement","rc","canvas","sceneState","renderScrollbars","renderSelection","renderOptimizations","atLeastOneVisibleElement","context","getContext","initialContextTransform","getTransform","normalizedCanvasWidth","width","getContextTransformScaleX","normalizedCanvasHeight","height","getContextTransformScaleY","zoomTranslation","zoom","applyZoom","save","setTransform","getContextTransformTranslateX","getContextTransformTranslateY","x","y","resetZoom","restore","viewBackgroundColor","hasTransparence","length","clearRect","fillStyle","fillRect","visibleElements","filter","element","isVisibleElement","forEach","selectedElements","dashledLinePadding","translate","scrollX","scrollY","elementX1","elementY1","elementX2","elementY2","elementWidth","elementHeight","initialLineDash","getLineDash","setLineDash","strokeRect","type","handlers","Object","values","handler","undefined","clientId","remotePointerViewportCoords","beginPath","arc","Math","PI","fill","stroke","scrollBars","strokeStyle","horizontal","vertical","scrollBar","viewportWidth","viewportHeight","x1","y1","x2","y2","viewportWidthWithZoom","viewportHeightWithZoom","viewportWidthDiff","viewportHeightDiff","renderSceneToSvg","rsvg","svgRoot","offsetX","offsetY","transform","a","d","e","f"],"mappings":"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","sourcesContent":["import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\n\nimport { FlooredNumber, AppState } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getElementAbsoluteCoords, handlerRectangles } from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getZoomTranslation } from \"../scene/zoom\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\n\nexport function renderScene(\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  selectionElement: ExcalidrawElement | null,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    //  doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n  } = {},\n) {\n  if (!canvas) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n\n  // Get initial scale transform as reference for later usage\n  const initialContextTransform = context.getTransform();\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth =\n    canvas.width / getContextTransformScaleX(initialContextTransform);\n  const normalizedCanvasHeight =\n    canvas.height / getContextTransformScaleY(initialContextTransform);\n\n  const zoomTranslation = getZoomTranslation(canvas, sceneState.zoom);\n  function applyZoom(context: CanvasRenderingContext2D): void {\n    context.save();\n\n    // Handle zoom scaling\n    context.setTransform(\n      getContextTransformScaleX(initialContextTransform) * sceneState.zoom,\n      0,\n      0,\n      getContextTransformScaleY(initialContextTransform) * sceneState.zoom,\n      getContextTransformTranslateX(context.getTransform()),\n      getContextTransformTranslateY(context.getTransform()),\n    );\n    // Handle zoom translation\n    context.setTransform(\n      getContextTransformScaleX(context.getTransform()),\n      0,\n      0,\n      getContextTransformScaleY(context.getTransform()),\n      getContextTransformTranslateX(initialContextTransform) -\n        zoomTranslation.x,\n      getContextTransformTranslateY(initialContextTransform) -\n        zoomTranslation.y,\n    );\n  }\n  function resetZoom(context: CanvasRenderingContext2D): void {\n    context.restore();\n  }\n\n  // Paint background\n  context.save();\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 ||\n      sceneState.viewBackgroundColor.length === 9;\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n  context.restore();\n\n  // Paint visible elements\n  const visibleElements = elements.filter(element =>\n    isVisibleElement(\n      element,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    ),\n  );\n\n  applyZoom(context);\n  visibleElements.forEach(element => {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  });\n  resetZoom(context);\n\n  // Pain selection element\n  if (selectionElement) {\n    applyZoom(context);\n    renderElement(\n      selectionElement,\n      rc,\n      context,\n      renderOptimizations,\n      sceneState,\n    );\n    resetZoom(context);\n  }\n\n  // Pain selected elements\n  if (renderSelection) {\n    const selectedElements = getSelectedElements(elements, appState);\n    const dashledLinePadding = 4 / sceneState.zoom;\n\n    applyZoom(context);\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    selectedElements.forEach(element => {\n      const [\n        elementX1,\n        elementY1,\n        elementX2,\n        elementY2,\n      ] = getElementAbsoluteCoords(element);\n\n      const elementWidth = elementX2 - elementX1;\n      const elementHeight = elementY2 - elementY1;\n\n      const initialLineDash = context.getLineDash();\n      context.setLineDash([8 / sceneState.zoom, 4 / sceneState.zoom]);\n      context.strokeRect(\n        elementX1 - dashledLinePadding,\n        elementY1 - dashledLinePadding,\n        elementWidth + dashledLinePadding * 2,\n        elementHeight + dashledLinePadding * 2,\n      );\n      context.setLineDash(initialLineDash);\n    });\n    resetZoom(context);\n\n    // Paint resize handlers\n    if (selectedElements.length === 1 && selectedElements[0].type !== \"text\") {\n      applyZoom(context);\n      context.translate(sceneState.scrollX, sceneState.scrollY);\n      const handlers = handlerRectangles(selectedElements[0], sceneState.zoom);\n      Object.values(handlers)\n        .filter(handler => handler !== undefined)\n        .forEach(handler => {\n          context.strokeRect(handler[0], handler[1], handler[2], handler[3]);\n        });\n      resetZoom(context);\n    }\n  }\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    const { x, y } = sceneState.remotePointerViewportCoords[clientId];\n    context.beginPath();\n    context.arc(x, y, 5, 0, 2 * Math.PI);\n    context.fill();\n    context.stroke();\n  }\n\n  // Paint scrollbars\n  if (renderScrollbars) {\n    const scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    context.save();\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(scrollBar => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.restore();\n    return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n  }\n\n  return { atLeastOneVisibleElement: visibleElements.length > 0 };\n}\n\nfunction isVisibleElement(\n  element: ExcalidrawElement,\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: FlooredNumber;\n    scrollY: FlooredNumber;\n    zoom: number;\n  },\n) {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom;\n  const viewportHeightWithZoom = viewportHeight / zoom;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  return (\n    x2 + scrollX - viewportWidthDiff / 2 >= 0 &&\n    x1 + scrollX - viewportWidthDiff / 2 <= viewportWidthWithZoom &&\n    y2 + scrollY - viewportHeightDiff / 2 >= 0 &&\n    y1 + scrollY - viewportHeightDiff / 2 <= viewportHeightWithZoom\n  );\n}\n\n// This should be only called for exporting purposes\nexport function renderSceneToSvg(\n  elements: readonly ExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach(element => {\n    renderElementToSvg(\n      element,\n      rsvg,\n      svgRoot,\n      element.x + offsetX,\n      element.y + offsetY,\n    );\n  });\n}\n\nfunction getContextTransformScaleX(transform: DOMMatrix): number {\n  return transform.a;\n}\nfunction getContextTransformScaleY(transform: DOMMatrix): number {\n  return transform.d;\n}\nfunction getContextTransformTranslateX(transform: DOMMatrix): number {\n  return transform.e;\n}\nfunction getContextTransformTranslateY(transform: DOMMatrix): number {\n  return transform.f;\n}\n"]},"metadata":{},"sourceType":"module"}