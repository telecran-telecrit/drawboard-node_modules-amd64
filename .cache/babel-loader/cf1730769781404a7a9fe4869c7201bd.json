{"ast":null,"code":"import _slicedToArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { distanceBetweenPointAndSegment } from \"../math\";\nimport { getDiamondPoints, getElementAbsoluteCoords, getLinearElementAbsoluteBounds } from \"./bounds\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\nfunction isElementDraggableFromInside(element, appState) {\n  return element.backgroundColor !== \"transparent\" || appState.selectedElementIds[element.id];\n}\n\nexport function hitTest(element, appState, x, y, zoom) {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  var lineThreshold = 10 / zoom;\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    var px = Math.abs(x - element.x - element.width / 2);\n    var py = Math.abs(y - element.y - element.height / 2);\n    var tx = 0.707;\n    var ty = 0.707;\n    var a = Math.abs(element.width) / 2;\n    var b = Math.abs(element.height) / 2;\n    [0, 1, 2, 3].forEach(function (x) {\n      var xx = a * tx;\n      var yy = b * ty;\n      var ex = (a * a - b * b) * Math.pow(tx, 3) / a;\n      var ey = (b * b - a * a) * Math.pow(ty, 3) / b;\n      var rx = xx - ex;\n      var ry = yy - ey;\n      var qx = px - ex;\n      var qy = py - ey;\n      var r = Math.hypot(ry, rx);\n      var q = Math.hypot(qy, qx);\n      tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));\n      ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));\n      var t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    if (isElementDraggableFromInside(element, appState)) {\n      return a * tx - (px - lineThreshold) >= 0 && b * ty - (py - lineThreshold) >= 0;\n    }\n\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    var _getElementAbsoluteCo = getElementAbsoluteCoords(element),\n        _getElementAbsoluteCo2 = _slicedToArray(_getElementAbsoluteCo, 4),\n        x1 = _getElementAbsoluteCo2[0],\n        y1 = _getElementAbsoluteCo2[1],\n        x2 = _getElementAbsoluteCo2[2],\n        y2 = _getElementAbsoluteCo2[3];\n\n    if (isElementDraggableFromInside(element, appState)) {\n      return x > x1 - lineThreshold && x < x2 + lineThreshold && y > y1 - lineThreshold && y < y2 + lineThreshold;\n    } // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n\n\n    return distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n    distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n    distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n    distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    ;\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n\n    var _getDiamondPoints = getDiamondPoints(element),\n        _getDiamondPoints2 = _slicedToArray(_getDiamondPoints, 8),\n        topX = _getDiamondPoints2[0],\n        topY = _getDiamondPoints2[1],\n        rightX = _getDiamondPoints2[2],\n        rightY = _getDiamondPoints2[3],\n        bottomX = _getDiamondPoints2[4],\n        bottomY = _getDiamondPoints2[5],\n        leftX = _getDiamondPoints2[6],\n        leftY = _getDiamondPoints2[7];\n\n    if (isElementDraggableFromInside(element, appState)) {\n      // TODO: remove this when we normalize coordinates globally\n      if (topY > bottomY) {\n        var _ref = [topY, bottomY];\n        bottomY = _ref[0];\n        topY = _ref[1];\n      }\n\n      if (rightX < leftX) {\n        var _ref2 = [rightX, leftX];\n        leftX = _ref2[0];\n        rightX = _ref2[1];\n      }\n\n      topY -= lineThreshold;\n      bottomY += lineThreshold;\n      leftX -= lineThreshold;\n      rightX += lineThreshold; // all deltas should be < 0. Delta > 0 indicates it's on the outside side\n      //  of the line.\n      //\n      //          (topX, topY)\n      //     D  /             \\ A\n      //      /               \\\n      //  (leftX, leftY)  (rightX, rightY)\n      //    C \\               / B\n      //      \\              /\n      //      (bottomX, bottomY)\n      //\n      // https://stackoverflow.com/a/2752753/927631\n\n      return (// delta from line D\n        (leftX - topX) * (y - leftY) - (leftX - x) * (topY - leftY) <= 0 && // delta from line A\n        (topX - rightX) * (y - rightY) - (x - rightX) * (topY - rightY) <= 0 && // delta from line B\n        (rightX - bottomX) * (y - bottomY) - (x - bottomX) * (rightY - bottomY) <= 0 && // delta from line C\n        (bottomX - leftX) * (y - leftY) - (x - leftX) * (bottomY - leftY) <= 0\n      );\n    }\n\n    return distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) < lineThreshold || distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) < lineThreshold || distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) < lineThreshold || distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) < lineThreshold;\n  } else if (element.type === \"arrow\" || element.type === \"line\") {\n    if (!getShapeForElement(element)) {\n      return false;\n    }\n\n    var shape = getShapeForElement(element);\n\n    var _getLinearElementAbso = getLinearElementAbsoluteBounds(element),\n        _getLinearElementAbso2 = _slicedToArray(_getLinearElementAbso, 4),\n        _x = _getLinearElementAbso2[0],\n        _y = _getLinearElementAbso2[1],\n        _x2 = _getLinearElementAbso2[2],\n        _y2 = _getLinearElementAbso2[3];\n\n    if (x < _x || y < _y - 10 || x > _x2 || y > _y2 + 10) {\n      return false;\n    }\n\n    var relX = x - element.x;\n    var relY = y - element.y; // hit thest all \"subshapes\" of the linear element\n\n    return shape.some(function (subshape) {\n      return hitTestRoughShape(subshape.sets, relX, relY);\n    });\n  } else if (element.type === \"text\") {\n    var _getElementAbsoluteCo3 = getElementAbsoluteCoords(element),\n        _getElementAbsoluteCo4 = _slicedToArray(_getElementAbsoluteCo3, 4),\n        _x3 = _getElementAbsoluteCo4[0],\n        _y3 = _getElementAbsoluteCo4[1],\n        _x4 = _getElementAbsoluteCo4[2],\n        _y4 = _getElementAbsoluteCo4[3];\n\n    return x >= _x3 && x <= _x4 && y >= _y3 && y <= _y4;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  }\n\n  throw new Error(\"Unimplemented type \".concat(element.type));\n}\n\nvar pointInBezierEquation = function pointInBezierEquation(p0, p1, p2, p3, _ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      mx = _ref4[0],\n      my = _ref4[1];\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  var equation = function equation(t, idx) {\n    return Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n  };\n\n  var epsilon = 20; // go through t in increments of 0.01\n\n  var t = 0;\n\n  while (t <= 1.0) {\n    var tx = equation(t, 0);\n    var ty = equation(t, 1);\n    var diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < epsilon) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nvar hitTestRoughShape = function hitTestRoughShape(opSet, x, y) {\n  // read operations from first opSet\n  var ops = opSet[0].ops; // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n\n  var currentP = [0, 0];\n  return ops.some(function (_ref5, idx) {\n    var op = _ref5.op,\n        data = _ref5.data;\n\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data; // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      var p1 = [data[0], data[1]];\n      var p2 = [data[2], data[3]];\n      var p3 = [data[4], data[5]];\n      var p0 = currentP;\n      currentP = p3; // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n\n      var retVal = pointInBezierEquation(p0, p1, p2, p3, [x, y]); // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n\n      return retVal;\n    } else if (op === \"lineTo\") {// TODO: Implement this\n    } else if (op === \"qcurveTo\") {// TODO: Implement this\n    }\n\n    return false;\n  });\n};","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/collision.ts"],"names":["distanceBetweenPointAndSegment","getDiamondPoints","getElementAbsoluteCoords","getLinearElementAbsoluteBounds","getShapeForElement","isElementDraggableFromInside","element","appState","backgroundColor","selectedElementIds","id","hitTest","x","y","zoom","lineThreshold","type","px","Math","abs","width","py","height","tx","ty","a","b","forEach","xx","yy","ex","ey","rx","ry","qx","qy","r","hypot","q","min","max","t","x1","y1","x2","y2","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","shape","relX","relY","some","subshape","hitTestRoughShape","sets","console","warn","Error","pointInBezierEquation","p0","p1","p2","p3","mx","my","equation","idx","pow","epsilon","diff","sqrt","opSet","ops","currentP","op","data","retVal"],"mappings":"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","sourcesContent":["import { distanceBetweenPointAndSegment } from \"../math\";\n\nimport { ExcalidrawElement } from \"./types\";\n\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getLinearElementAbsoluteBounds,\n} from \"./bounds\";\nimport { Point } from \"roughjs/bin/geometry\";\nimport { Drawable, OpSet } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\nfunction isElementDraggableFromInside(\n  element: ExcalidrawElement,\n  appState: AppState,\n): boolean {\n  return (\n    element.backgroundColor !== \"transparent\" ||\n    appState.selectedElementIds[element.id]\n  );\n}\n\nexport function hitTest(\n  element: ExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: number,\n): boolean {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10 / zoom;\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = Math.abs(element.width) / 2;\n    const b = Math.abs(element.height) / 2;\n\n    [0, 1, 2, 3].forEach(x => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    if (isElementDraggableFromInside(element, appState)) {\n      return (\n        a * tx - (px - lineThreshold) >= 0 && b * ty - (py - lineThreshold) >= 0\n      );\n    }\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    if (isElementDraggableFromInside(element, appState)) {\n      return (\n        x > x1 - lineThreshold &&\n        x < x2 + lineThreshold &&\n        y > y1 - lineThreshold &&\n        y < y2 + lineThreshold\n      );\n    }\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n    let [\n      topX,\n      topY,\n      rightX,\n      rightY,\n      bottomX,\n      bottomY,\n      leftX,\n      leftY,\n    ] = getDiamondPoints(element);\n\n    if (isElementDraggableFromInside(element, appState)) {\n      // TODO: remove this when we normalize coordinates globally\n      if (topY > bottomY) {\n        [bottomY, topY] = [topY, bottomY];\n      }\n      if (rightX < leftX) {\n        [leftX, rightX] = [rightX, leftX];\n      }\n\n      topY -= lineThreshold;\n      bottomY += lineThreshold;\n      leftX -= lineThreshold;\n      rightX += lineThreshold;\n\n      // all deltas should be < 0. Delta > 0 indicates it's on the outside side\n      //  of the line.\n      //\n      //          (topX, topY)\n      //     D  /             \\ A\n      //      /               \\\n      //  (leftX, leftY)  (rightX, rightY)\n      //    C \\               / B\n      //      \\              /\n      //      (bottomX, bottomY)\n      //\n      // https://stackoverflow.com/a/2752753/927631\n      return (\n        // delta from line D\n        (leftX - topX) * (y - leftY) - (leftX - x) * (topY - leftY) <= 0 &&\n        // delta from line A\n        (topX - rightX) * (y - rightY) - (x - rightX) * (topY - rightY) <= 0 &&\n        // delta from line B\n        (rightX - bottomX) * (y - bottomY) -\n          (x - bottomX) * (rightY - bottomY) <=\n          0 &&\n        // delta from line C\n        (bottomX - leftX) * (y - leftY) - (x - leftX) * (bottomY - leftY) <= 0\n      );\n    }\n\n    return (\n      distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) <\n        lineThreshold\n    );\n  } else if (element.type === \"arrow\" || element.type === \"line\") {\n    if (!getShapeForElement(element)) {\n      return false;\n    }\n    const shape = getShapeForElement(element) as Drawable[];\n\n    const [x1, y1, x2, y2] = getLinearElementAbsoluteBounds(element);\n    if (x < x1 || y < y1 - 10 || x > x2 || y > y2 + 10) {\n      return false;\n    }\n\n    const relX = x - element.x;\n    const relY = y - element.y;\n\n    // hit thest all \"subshapes\" of the linear element\n    return shape.some(subshape => hitTestRoughShape(subshape.sets, relX, relY));\n  } else if (element.type === \"text\") {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  }\n  throw new Error(`Unimplemented type ${element.type}`);\n}\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  const epsilon = 20;\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < epsilon) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestRoughShape = (opSet: OpSet[], x: number, y: number) => {\n  // read operations from first opSet\n  const ops = opSet[0].ops;\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(p0, p1, p2, p3, [x, y]);\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n"]},"metadata":{},"sourceType":"module"}