{"ast":null,"code":"import _classCallCheck from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nvar hasDocument = typeof document !== 'undefined';\nexport var RoughCanvas =\n/*#__PURE__*/\nfunction () {\n  function RoughCanvas(canvas, config) {\n    _classCallCheck(this, RoughCanvas);\n\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext('2d');\n    this.gen = new RoughGenerator(config, this.canvas);\n  }\n\n  _createClass(RoughCanvas, [{\n    key: \"draw\",\n    value: function draw(drawable) {\n      var sets = drawable.sets || [];\n      var o = drawable.options || this.getDefaultOptions();\n      var ctx = this.ctx;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = sets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var drawing = _step.value;\n\n          switch (drawing.type) {\n            case 'path':\n              ctx.save();\n              ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n              ctx.lineWidth = o.strokeWidth;\n\n              this._drawToContext(ctx, drawing);\n\n              ctx.restore();\n              break;\n\n            case 'fillPath':\n              ctx.save();\n              ctx.fillStyle = o.fill || '';\n\n              this._drawToContext(ctx, drawing);\n\n              ctx.restore();\n              break;\n\n            case 'fillSketch':\n              this.fillSketch(ctx, drawing, o);\n              break;\n\n            case 'path2Dfill':\n              {\n                this.ctx.save();\n                this.ctx.fillStyle = o.fill || '';\n                var p2d = new Path2D(drawing.path);\n                this.ctx.fill(p2d);\n                this.ctx.restore();\n                break;\n              }\n\n            case 'path2Dpattern':\n              {\n                var doc = this.canvas.ownerDocument || hasDocument && document;\n\n                if (doc) {\n                  var size = drawing.size;\n                  var hcanvas = doc.createElement('canvas');\n                  var hcontext = hcanvas.getContext('2d');\n                  var bbox = this.computeBBox(drawing.path);\n\n                  if (bbox && (bbox.width || bbox.height)) {\n                    hcanvas.width = this.canvas.width;\n                    hcanvas.height = this.canvas.height;\n                    hcontext.translate(bbox.x || 0, bbox.y || 0);\n                  } else {\n                    hcanvas.width = size[0];\n                    hcanvas.height = size[1];\n                  }\n\n                  this.fillSketch(hcontext, drawing, o);\n                  this.ctx.save();\n                  this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n\n                  var _p2d = new Path2D(drawing.path);\n\n                  this.ctx.fill(_p2d);\n                  this.ctx.restore();\n                } else {\n                  console.error('Pattern fill fail: No defs');\n                }\n\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"computeBBox\",\n    value: function computeBBox(d) {\n      if (hasDocument) {\n        try {\n          var svg = document.createElementNS(SVGNS, 'svg');\n          svg.setAttribute('width', '0');\n          svg.setAttribute('height', '0');\n          var pathNode = self.document.createElementNS(SVGNS, 'path');\n          pathNode.setAttribute('d', d);\n          svg.appendChild(pathNode);\n          document.body.appendChild(svg);\n          var bbox = pathNode.getBBox();\n          document.body.removeChild(svg);\n          return bbox;\n        } catch (err) {}\n      }\n\n      return null;\n    }\n  }, {\n    key: \"fillSketch\",\n    value: function fillSketch(ctx, drawing, o) {\n      var fweight = o.fillWeight;\n\n      if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n      }\n\n      ctx.save();\n      ctx.strokeStyle = o.fill || '';\n      ctx.lineWidth = fweight;\n\n      this._drawToContext(ctx, drawing);\n\n      ctx.restore();\n    }\n  }, {\n    key: \"_drawToContext\",\n    value: function _drawToContext(ctx, drawing) {\n      ctx.beginPath();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = drawing.ops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var item = _step2.value;\n          var data = item.data;\n\n          switch (item.op) {\n            case 'move':\n              ctx.moveTo(data[0], data[1]);\n              break;\n\n            case 'bcurveTo':\n              ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n              break;\n\n            case 'qcurveTo':\n              ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n              break;\n\n            case 'lineTo':\n              ctx.lineTo(data[0], data[1]);\n              break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (drawing.type === 'fillPath') {\n        ctx.fill();\n      } else {\n        ctx.stroke();\n      }\n    }\n  }, {\n    key: \"getDefaultOptions\",\n    value: function getDefaultOptions() {\n      return this.gen.defaultOptions;\n    }\n  }, {\n    key: \"line\",\n    value: function line(x1, y1, x2, y2, options) {\n      var d = this.gen.line(x1, y1, x2, y2, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"rectangle\",\n    value: function rectangle(x, y, width, height, options) {\n      var d = this.gen.rectangle(x, y, width, height, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"ellipse\",\n    value: function ellipse(x, y, width, height, options) {\n      var d = this.gen.ellipse(x, y, width, height, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"circle\",\n    value: function circle(x, y, diameter, options) {\n      var d = this.gen.circle(x, y, diameter, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"linearPath\",\n    value: function linearPath(points, options) {\n      var d = this.gen.linearPath(points, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"polygon\",\n    value: function polygon(points, options) {\n      var d = this.gen.polygon(points, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(x, y, width, height, start, stop) {\n      var closed = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var options = arguments.length > 7 ? arguments[7] : undefined;\n      var d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(points, options) {\n      var d = this.gen.curve(points, options);\n      this.draw(d);\n      return d;\n    }\n  }, {\n    key: \"path\",\n    value: function path(d, options) {\n      var drawing = this.gen.path(d, options);\n      this.draw(drawing);\n      return drawing;\n    }\n  }, {\n    key: \"generator\",\n    get: function get() {\n      return this.gen;\n    }\n  }]);\n\n  return RoughCanvas;\n}();","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/canvas.js"],"names":["SVGNS","RoughGenerator","hasDocument","document","RoughCanvas","canvas","config","ctx","getContext","gen","drawable","sets","o","options","getDefaultOptions","drawing","type","save","strokeStyle","stroke","lineWidth","strokeWidth","_drawToContext","restore","fillStyle","fill","fillSketch","p2d","Path2D","path","doc","ownerDocument","size","hcanvas","createElement","hcontext","bbox","computeBBox","width","height","translate","x","y","createPattern","console","error","d","svg","createElementNS","setAttribute","pathNode","self","appendChild","body","getBBox","removeChild","err","fweight","fillWeight","beginPath","ops","item","data","op","moveTo","bezierCurveTo","quadraticCurveTo","lineTo","defaultOptions","x1","y1","x2","y2","line","draw","rectangle","ellipse","diameter","circle","points","linearPath","polygon","start","stop","closed","arc","curve"],"mappings":"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","sourcesContent":["import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new RoughGenerator(config, this.canvas);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillPath':\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n                case 'path2Dfill': {\n                    this.ctx.save();\n                    this.ctx.fillStyle = o.fill || '';\n                    const p2d = new Path2D(drawing.path);\n                    this.ctx.fill(p2d);\n                    this.ctx.restore();\n                    break;\n                }\n                case 'path2Dpattern': {\n                    const doc = this.canvas.ownerDocument || (hasDocument && document);\n                    if (doc) {\n                        const size = drawing.size;\n                        const hcanvas = doc.createElement('canvas');\n                        const hcontext = hcanvas.getContext('2d');\n                        const bbox = this.computeBBox(drawing.path);\n                        if (bbox && (bbox.width || bbox.height)) {\n                            hcanvas.width = this.canvas.width;\n                            hcanvas.height = this.canvas.height;\n                            hcontext.translate(bbox.x || 0, bbox.y || 0);\n                        }\n                        else {\n                            hcanvas.width = size[0];\n                            hcanvas.height = size[1];\n                        }\n                        this.fillSketch(hcontext, drawing, o);\n                        this.ctx.save();\n                        this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n                        const p2d = new Path2D(drawing.path);\n                        this.ctx.fill(p2d);\n                        this.ctx.restore();\n                    }\n                    else {\n                        console.error('Pattern fill fail: No defs');\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    computeBBox(d) {\n        if (hasDocument) {\n            try {\n                const svg = document.createElementNS(SVGNS, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(SVGNS, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                document.body.appendChild(svg);\n                const bbox = pathNode.getBBox();\n                document.body.removeChild(svg);\n                return bbox;\n            }\n            catch (err) { }\n        }\n        return null;\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing) {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'qcurveTo':\n                    ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill();\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}