{"ast":null,"code":"export function rotatePoints(points, center, degrees) {\n  if (points && points.length) {\n    const [cx, cy] = center;\n    const angle = Math.PI / 180 * degrees;\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    points.forEach(p => {\n      const [x, y] = p;\n      p[0] = (x - cx) * cos - (y - cy) * sin + cx;\n      p[1] = (x - cx) * sin + (y - cy) * cos + cy;\n    });\n  }\n}\nexport function rotateLines(lines, center, degrees) {\n  const points = [];\n  lines.forEach(line => points.push(...line));\n  rotatePoints(points, center, degrees);\n}\nexport function lineLength(line) {\n  const p1 = line[0];\n  const p2 = line[1];\n  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getPointsOnBezierCurves(points, tolerance) {\n  const newPoints = [];\n  const numSegments = (points.length - 1) / 3;\n\n  for (let i = 0; i < numSegments; i++) {\n    const offset = i * 3;\n    getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n  }\n\n  return newPoints;\n}\n\nfunction lerp(a, b, t) {\n  return [a[0] + (b[0] - a[0]) * t, a[1] + (b[1] - a[1]) * t];\n}\n\nfunction flatness(points, offset) {\n  const p1 = points[offset + 0];\n  const p2 = points[offset + 1];\n  const p3 = points[offset + 2];\n  const p4 = points[offset + 3];\n  let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n  ux *= ux;\n  let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n  uy *= uy;\n  let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n  vx *= vx;\n  let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n  vy *= vy;\n\n  if (ux < vx) {\n    ux = vx;\n  }\n\n  if (uy < vy) {\n    uy = vy;\n  }\n\n  return ux + uy;\n}\n\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n  const outPoints = newPoints || [];\n\n  if (flatness(points, offset) < tolerance) {\n    const p0 = points[offset + 0];\n\n    if (outPoints.length) {\n      const d = lineLength([outPoints[outPoints.length - 1], p0]);\n\n      if (d > 1) {\n        outPoints.push(p0);\n      }\n    } else {\n      outPoints.push(p0);\n    }\n\n    outPoints.push(points[offset + 3]);\n  } else {\n    // subdivide\n    const t = .5;\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    const q1 = lerp(p1, p2, t);\n    const q2 = lerp(p2, p3, t);\n    const q3 = lerp(p3, p4, t);\n    const r1 = lerp(q1, q2, t);\n    const r2 = lerp(q2, q3, t);\n    const red = lerp(r1, r2, t);\n    getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n    getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n  }\n\n  return outPoints;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/geometry.js"],"names":["rotatePoints","points","center","degrees","length","cx","cy","angle","Math","PI","cos","sin","forEach","p","x","y","rotateLines","lines","line","push","lineLength","p1","p2","sqrt","pow","getPointsOnBezierCurves","tolerance","newPoints","numSegments","i","offset","getPointsOnBezierCurveWithSplitting","lerp","a","b","t","flatness","p3","p4","ux","uy","vx","vy","outPoints","p0","d","q1","q2","q3","r1","r2","red"],"mappings":"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","sourcesContent":["export function rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        points.forEach((p) => {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        });\n    }\n}\nexport function rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nexport function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getPointsOnBezierCurves(points, tolerance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    return newPoints;\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = lineLength([outPoints[outPoints.length - 1], p0]);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\n"]},"metadata":{},"sourceType":"module"}