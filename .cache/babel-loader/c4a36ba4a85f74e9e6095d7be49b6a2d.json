{"ast":null,"code":"import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n  constructor(helper) {\n    this.helper = helper;\n  }\n\n  fillPolygon(points, o) {\n    const lines = polygonHachureLines(points, o);\n    return {\n      type: 'fillSketch',\n      ops: this.dashedLine(lines, o)\n    };\n  }\n\n  dashedLine(lines, o) {\n    const offset = o.dashOffset < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashOffset;\n    const gap = o.dashGap < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashGap;\n    let ops = [];\n    lines.forEach(line => {\n      const length = lineLength(line);\n      const count = Math.floor(length / (offset + gap));\n      const startOffset = (length + gap - count * (offset + gap)) / 2;\n      let p1 = line[0];\n      let p2 = line[1];\n\n      if (p1[0] > p2[0]) {\n        p1 = line[1];\n        p2 = line[0];\n      }\n\n      const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n\n      for (let i = 0; i < count; i++) {\n        const lstart = i * (offset + gap);\n        const lend = lstart + offset;\n        const start = [p1[0] + lstart * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha) + startOffset * Math.sin(alpha)];\n        const end = [p1[0] + lend * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lend * Math.sin(alpha) + startOffset * Math.sin(alpha)];\n        ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n      }\n    });\n    return ops;\n  }\n\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/fillers/dashed-filler.js"],"names":["lineLength","polygonHachureLines","DashedFiller","constructor","helper","fillPolygon","points","o","lines","type","ops","dashedLine","offset","dashOffset","hachureGap","strokeWidth","gap","dashGap","forEach","line","length","count","Math","floor","startOffset","p1","p2","alpha","atan","i","lstart","lend","start","cos","sin","end","concat","doubleLineOps"],"mappings":"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","sourcesContent":["import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        const lines = polygonHachureLines(points, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        let ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}