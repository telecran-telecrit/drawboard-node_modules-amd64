{"ast":null,"code":"(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('error-stack-parser', ['stackframe'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('stackframe'));\n  } else {\n    root.ErrorStackParser = factory(root.StackFrame);\n  }\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n        }\n\n        var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n\n        var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame({\n          functionName: functionName,\n          args: args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    }\n  };\n});","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/error-stack-parser/error-stack-parser.js"],"names":["root","factory","define","amd","exports","module","require","ErrorStackParser","StackFrame","FIREFOX_SAFARI_STACK_REGEXP","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","parse","ErrorStackParser$$parse","error","stacktrace","parseOpera","stack","match","parseV8OrIE","parseFFOrSafari","Error","extractLocation","ErrorStackParser$$extractLocation","urlLike","indexOf","regExp","parts","exec","replace","undefined","ErrorStackParser$$parseV8OrIE","filtered","split","filter","line","map","sanitizedLine","location","tokens","slice","locationParts","pop","functionName","join","fileName","lineNumber","columnNumber","source","ErrorStackParser$$parseFFOrSafari","functionNameRegex","matches","ErrorStackParser$$parseOpera","e","message","length","parseOpera9","parseOpera10","parseOpera11","ErrorStackParser$$parseOpera9","lineRE","lines","result","i","len","push","ErrorStackParser$$parseOpera10","ErrorStackParser$$parseOpera11","functionCall","shift","argsRaw","args"],"mappings":"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","sourcesContent":["(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n                }\n                var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n                // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n                // case it has spaces in it, as the string is split on \\s+ later on\n                var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n                // remove the parenthesized location from the line, if it was matched\n                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n\n                var tokens = sanitizedLine.split(/\\s+/).slice(1);\n                // if a location was matched, pass it to extractLocation() otherwise pop the last token\n                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: fileName,\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame({\n                        functionName: line\n                    });\n                } else {\n                    var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n                    var matches = line.match(functionNameRegex);\n                    var functionName = matches && matches[1] ? matches[1] : undefined;\n                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n\n                    return new StackFrame({\n                        functionName: functionName,\n                        fileName: locationParts[0],\n                        lineNumber: locationParts[1],\n                        columnNumber: locationParts[2],\n                        source: line\n                    });\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame({\n                            functionName: match[3] || undefined,\n                            fileName: match[2],\n                            lineNumber: match[1],\n                            source: lines[i]\n                        })\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return filtered.map(function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                    .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                    .replace(/\\([^)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n\n                return new StackFrame({\n                    functionName: functionName,\n                    args: args,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        }\n    };\n}));\n"]},"metadata":{},"sourceType":"script"}