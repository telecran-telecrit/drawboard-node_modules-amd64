{"ast":null,"code":"import { LINE_CONFIRM_THRESHOLD } from \"./constants\"; // https://stackoverflow.com/a/6853926/232122\n\nexport function distanceBetweenPointAndSegment(x, y, x1, y1, x2, y2) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\nexport function rotate(x1, y1, x2, y2, angle) {\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [(x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2, (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2];\n}\n\nconst adjustXYWithRotation = (side, x, y, angle, deltaX, deltaY) => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  deltaX /= 2;\n  deltaY /= 2;\n\n  if (side === \"e\" || side === \"ne\" || side === \"se\") {\n    x += deltaX * (1 - cos);\n    y += deltaX * -sin;\n  }\n\n  if (side === \"s\" || side === \"sw\" || side === \"se\") {\n    x += deltaY * sin;\n    y += deltaY * (1 - cos);\n  }\n\n  if (side === \"w\" || side === \"nw\" || side === \"sw\") {\n    x += deltaX * (1 + cos);\n    y += deltaX * sin;\n  }\n\n  if (side === \"n\" || side === \"nw\" || side === \"ne\") {\n    x += deltaY * -sin;\n    y += deltaY * (1 + cos);\n  }\n\n  return {\n    x,\n    y\n  };\n};\n\nexport const resizeXYWidthHightWithRotation = (side, x, y, width, height, offsetX, offsetY, angle, xPointer, yPointer, offsetPointer, sidesWithSameLength) => {\n  // center point for rotation\n  const cx = x + width / 2;\n  const cy = y + height / 2; // rotation with current angle\n\n  const [rotatedX, rotatedY] = rotate(xPointer, yPointer, cx, cy, -angle);\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (side === \"e\" || side === \"ne\" || side === \"se\") {\n    scaleX = (rotatedX - offsetPointer - x) / width;\n  }\n\n  if (side === \"s\" || side === \"sw\" || side === \"se\") {\n    scaleY = (rotatedY - offsetPointer - y) / height;\n  }\n\n  if (side === \"w\" || side === \"nw\" || side === \"sw\") {\n    scaleX = (x + width - offsetPointer - rotatedX) / width;\n  }\n\n  if (side === \"n\" || side === \"nw\" || side === \"ne\") {\n    scaleY = (y + height - offsetPointer - rotatedY) / height;\n  }\n\n  let nextWidth = width * scaleX;\n  let nextHeight = height * scaleY;\n\n  if (sidesWithSameLength) {\n    nextWidth = nextHeight = Math.max(nextWidth, nextHeight);\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    ...adjustXYWithRotation(side, x - offsetX, y - offsetY, angle, width - nextWidth, height - nextHeight)\n  };\n};\nexport const getPointOnAPath = (point, path) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine = 0;\n  let idx = 0; // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n    lastX = x2;\n    lastY = y2; // if a point is not within the domain of the line segment\n    // it is not on the line segment\n\n    if (px < x1 || px > x2) {\n      return false;\n    } // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n    // coefficient for the line (p0, p1)\n\n\n    const kL = (y2 - y1) / (x2 - x1); // coefficient for the line segment (p0, point)\n\n    const kP1 = (py - y1) / (px - x1); // coefficient for the line segment (point, p1)\n\n    const kP2 = (py - y2) / (px - x2); // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n    // using it for floating point comparisons\n\n    const epsilon = 0.3; // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    } // store the coefficient because we are goint to need it\n\n\n    kLine = kL;\n    idx = i;\n    return true;\n  }); // Return a coordinate that is always on the line segment\n\n  if (retVal === true) {\n    return {\n      x: point[0],\n      y: kLine * point[0],\n      segment: idx\n    };\n  }\n\n  return null;\n};\nexport function distance2d(x1, y1, x2, y2) {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n} // Checks if the first and last point are close enough\n// to be considered a loop\n\nexport function isPathALoop(points) {\n  if (points.length >= 3) {\n    const [firstPoint, lastPoint] = [points[0], points[points.length - 1]];\n    return distance2d(firstPoint[0], firstPoint[1], lastPoint[0], lastPoint[1]) <= LINE_CONFIRM_THRESHOLD;\n  }\n\n  return false;\n} // Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\n\nexport function isPointInPolygon(points, x, y) {\n  const vertices = points.length; // There must be at least 3 vertices in polygon\n\n  if (vertices < 3) {\n    return false;\n  }\n\n  const extreme = [Number.MAX_SAFE_INTEGER, y];\n  const p = [x, y];\n  let count = 0;\n\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n\n    if (doIntersect(current, next, p, extreme)) {\n      if (orientation(current, p, next) === 0) {\n        return onSegment(current, p, next);\n      }\n\n      count++;\n    }\n  } // true if count is off\n\n\n  return count % 2 === 1;\n} // Check if q lies on the line segment pr\n\nfunction onSegment(p, q, r) {\n  return q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) && q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]);\n} // For the ordered points p, q, r, return\n// 0 if p, q, r are collinear\n// 1 if Clockwise\n// 2 if counterclickwise\n\n\nfunction orientation(p, q, r) {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (val === 0) {\n    return 0;\n  }\n\n  return val > 0 ? 1 : 2;\n} // Check is p1q1 intersects with p2q2\n\n\nfunction doIntersect(p1, q1, p2, q2) {\n  const o1 = orientation(p1, q1, p2);\n  const o2 = orientation(p1, q1, q2);\n  const o3 = orientation(p2, q2, p1);\n  const o4 = orientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  } // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) {\n    return true;\n  } // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n\n\n  if (o2 === 0 && onSegment(p1, q2, q1)) {\n    return true;\n  } // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n\n\n  if (o3 === 0 && onSegment(p2, p1, q2)) {\n    return true;\n  } // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n\n\n  if (o4 === 0 && onSegment(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/math.ts"],"names":["LINE_CONFIRM_THRESHOLD","distanceBetweenPointAndSegment","x","y","x1","y1","x2","y2","A","B","C","D","dot","lenSquare","param","xx","yy","dx","dy","Math","hypot","rotate","angle","cos","sin","adjustXYWithRotation","side","deltaX","deltaY","resizeXYWidthHightWithRotation","width","height","offsetX","offsetY","xPointer","yPointer","offsetPointer","sidesWithSameLength","cx","cy","rotatedX","rotatedY","scaleX","scaleY","nextWidth","nextHeight","max","getPointOnAPath","point","path","px","py","start","other","lastX","lastY","kLine","idx","retVal","some","i","kL","kP1","kP2","epsilon","abs","segment","distance2d","xd","yd","isPathALoop","points","length","firstPoint","lastPoint","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","current","next","doIntersect","orientation","onSegment","q","r","min","val","p1","q1","p2","q2","o1","o2","o3","o4"],"mappings":"AACA,SAASA,sBAAT,QAAuC,aAAvC,C,CAEA;;AACA,OAAO,SAASC,8BAAT,CACLC,CADK,EAELC,CAFK,EAGLC,EAHK,EAILC,EAJK,EAKLC,EALK,EAMLC,EANK,EAOL;AACA,QAAMC,CAAC,GAAGN,CAAC,GAAGE,EAAd;AACA,QAAMK,CAAC,GAAGN,CAAC,GAAGE,EAAd;AACA,QAAMK,CAAC,GAAGJ,EAAE,GAAGF,EAAf;AACA,QAAMO,CAAC,GAAGJ,EAAE,GAAGF,EAAf;AAEA,QAAMO,GAAG,GAAGJ,CAAC,GAAGE,CAAJ,GAAQD,CAAC,GAAGE,CAAxB;AACA,QAAME,SAAS,GAAGH,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAA9B;AACA,MAAIG,KAAK,GAAG,CAAC,CAAb;;AACA,MAAID,SAAS,KAAK,CAAlB,EAAqB;AACnB;AACAC,IAAAA,KAAK,GAAGF,GAAG,GAAGC,SAAd;AACD;;AAED,MAAIE,EAAJ,EAAQC,EAAR;;AACA,MAAIF,KAAK,GAAG,CAAZ,EAAe;AACbC,IAAAA,EAAE,GAAGX,EAAL;AACAY,IAAAA,EAAE,GAAGX,EAAL;AACD,GAHD,MAGO,IAAIS,KAAK,GAAG,CAAZ,EAAe;AACpBC,IAAAA,EAAE,GAAGT,EAAL;AACAU,IAAAA,EAAE,GAAGT,EAAL;AACD,GAHM,MAGA;AACLQ,IAAAA,EAAE,GAAGX,EAAE,GAAGU,KAAK,GAAGJ,CAAlB;AACAM,IAAAA,EAAE,GAAGX,EAAE,GAAGS,KAAK,GAAGH,CAAlB;AACD;;AAED,QAAMM,EAAE,GAAGf,CAAC,GAAGa,EAAf;AACA,QAAMG,EAAE,GAAGf,CAAC,GAAGa,EAAf;AACA,SAAOG,IAAI,CAACC,KAAL,CAAWH,EAAX,EAAeC,EAAf,CAAP;AACD;AAED,OAAO,SAASG,MAAT,CACLjB,EADK,EAELC,EAFK,EAGLC,EAHK,EAILC,EAJK,EAKLe,KALK,EAML;AACA;AACA;AACA;AACA,SAAO,CACL,CAAClB,EAAE,GAAGE,EAAN,IAAYa,IAAI,CAACI,GAAL,CAASD,KAAT,CAAZ,GAA8B,CAACjB,EAAE,GAAGE,EAAN,IAAYY,IAAI,CAACK,GAAL,CAASF,KAAT,CAA1C,GAA4DhB,EADvD,EAEL,CAACF,EAAE,GAAGE,EAAN,IAAYa,IAAI,CAACK,GAAL,CAASF,KAAT,CAAZ,GAA8B,CAACjB,EAAE,GAAGE,EAAN,IAAYY,IAAI,CAACI,GAAL,CAASD,KAAT,CAA1C,GAA4Df,EAFvD,CAAP;AAID;;AAED,MAAMkB,oBAAoB,GAAG,CAC3BC,IAD2B,EAE3BxB,CAF2B,EAG3BC,CAH2B,EAI3BmB,KAJ2B,EAK3BK,MAL2B,EAM3BC,MAN2B,KAOxB;AACH,QAAML,GAAG,GAAGJ,IAAI,CAACI,GAAL,CAASD,KAAT,CAAZ;AACA,QAAME,GAAG,GAAGL,IAAI,CAACK,GAAL,CAASF,KAAT,CAAZ;AACAK,EAAAA,MAAM,IAAI,CAAV;AACAC,EAAAA,MAAM,IAAI,CAAV;;AACA,MAAIF,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDxB,IAAAA,CAAC,IAAIyB,MAAM,IAAI,IAAIJ,GAAR,CAAX;AACApB,IAAAA,CAAC,IAAIwB,MAAM,GAAG,CAACH,GAAf;AACD;;AACD,MAAIE,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDxB,IAAAA,CAAC,IAAI0B,MAAM,GAAGJ,GAAd;AACArB,IAAAA,CAAC,IAAIyB,MAAM,IAAI,IAAIL,GAAR,CAAX;AACD;;AACD,MAAIG,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDxB,IAAAA,CAAC,IAAIyB,MAAM,IAAI,IAAIJ,GAAR,CAAX;AACApB,IAAAA,CAAC,IAAIwB,MAAM,GAAGH,GAAd;AACD;;AACD,MAAIE,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDxB,IAAAA,CAAC,IAAI0B,MAAM,GAAG,CAACJ,GAAf;AACArB,IAAAA,CAAC,IAAIyB,MAAM,IAAI,IAAIL,GAAR,CAAX;AACD;;AACD,SAAO;AAAErB,IAAAA,CAAF;AAAKC,IAAAA;AAAL,GAAP;AACD,CA7BD;;AA+BA,OAAO,MAAM0B,8BAA8B,GAAG,CAC5CH,IAD4C,EAE5CxB,CAF4C,EAG5CC,CAH4C,EAI5C2B,KAJ4C,EAK5CC,MAL4C,EAM5CC,OAN4C,EAO5CC,OAP4C,EAQ5CX,KAR4C,EAS5CY,QAT4C,EAU5CC,QAV4C,EAW5CC,aAX4C,EAY5CC,mBAZ4C,KAazC;AACH;AACA,QAAMC,EAAE,GAAGpC,CAAC,GAAG4B,KAAK,GAAG,CAAvB;AACA,QAAMS,EAAE,GAAGpC,CAAC,GAAG4B,MAAM,GAAG,CAAxB,CAHG,CAKH;;AACA,QAAM,CAACS,QAAD,EAAWC,QAAX,IAAuBpB,MAAM,CAACa,QAAD,EAAWC,QAAX,EAAqBG,EAArB,EAAyBC,EAAzB,EAA6B,CAACjB,KAA9B,CAAnC;AAEA,MAAIoB,MAAM,GAAG,CAAb;AACA,MAAIC,MAAM,GAAG,CAAb;;AACA,MAAIjB,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDgB,IAAAA,MAAM,GAAG,CAACF,QAAQ,GAAGJ,aAAX,GAA2BlC,CAA5B,IAAiC4B,KAA1C;AACD;;AACD,MAAIJ,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDiB,IAAAA,MAAM,GAAG,CAACF,QAAQ,GAAGL,aAAX,GAA2BjC,CAA5B,IAAiC4B,MAA1C;AACD;;AACD,MAAIL,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDgB,IAAAA,MAAM,GAAG,CAACxC,CAAC,GAAG4B,KAAJ,GAAYM,aAAZ,GAA4BI,QAA7B,IAAyCV,KAAlD;AACD;;AACD,MAAIJ,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,IAAzB,IAAiCA,IAAI,KAAK,IAA9C,EAAoD;AAClDiB,IAAAA,MAAM,GAAG,CAACxC,CAAC,GAAG4B,MAAJ,GAAaK,aAAb,GAA6BK,QAA9B,IAA0CV,MAAnD;AACD;;AAED,MAAIa,SAAS,GAAGd,KAAK,GAAGY,MAAxB;AACA,MAAIG,UAAU,GAAGd,MAAM,GAAGY,MAA1B;;AACA,MAAIN,mBAAJ,EAAyB;AACvBO,IAAAA,SAAS,GAAGC,UAAU,GAAG1B,IAAI,CAAC2B,GAAL,CAASF,SAAT,EAAoBC,UAApB,CAAzB;AACD;;AAED,SAAO;AACLf,IAAAA,KAAK,EAAEc,SADF;AAELb,IAAAA,MAAM,EAAEc,UAFH;AAGL,OAAGpB,oBAAoB,CACrBC,IADqB,EAErBxB,CAAC,GAAG8B,OAFiB,EAGrB7B,CAAC,GAAG8B,OAHiB,EAIrBX,KAJqB,EAKrBQ,KAAK,GAAGc,SALa,EAMrBb,MAAM,GAAGc,UANY;AAHlB,GAAP;AAYD,CAtDM;AAwDP,OAAO,MAAME,eAAe,GAAG,CAACC,KAAD,EAAeC,IAAf,KAAiC;AAC9D,QAAM,CAACC,EAAD,EAAKC,EAAL,IAAWH,KAAjB;AACA,QAAM,CAACI,KAAD,EAAQ,GAAGC,KAAX,IAAoBJ,IAA1B;AACA,MAAI,CAACK,KAAD,EAAQC,KAAR,IAAiBH,KAArB;AACA,MAAII,KAAa,GAAG,CAApB;AACA,MAAIC,GAAW,GAAG,CAAlB,CAL8D,CAO9D;AACA;;AACA,QAAMC,MAAM,GAAGL,KAAK,CAACM,IAAN,CAAW,CAAC,CAACrD,EAAD,EAAKC,EAAL,CAAD,EAAWqD,CAAX,KAAiB;AACzC;AACA,UAAMxD,EAAE,GAAGkD,KAAX;AACA,UAAMjD,EAAE,GAAGkD,KAAX;AAEAD,IAAAA,KAAK,GAAGhD,EAAR;AACAiD,IAAAA,KAAK,GAAGhD,EAAR,CANyC,CAQzC;AACA;;AACA,QAAI2C,EAAE,GAAG9C,EAAL,IAAW8C,EAAE,GAAG5C,EAApB,EAAwB;AACtB,aAAO,KAAP;AACD,KAZwC,CAczC;AACA;AACA;AAEA;;;AACA,UAAMuD,EAAE,GAAG,CAACtD,EAAE,GAAGF,EAAN,KAAaC,EAAE,GAAGF,EAAlB,CAAX,CAnByC,CAqBzC;;AACA,UAAM0D,GAAG,GAAG,CAACX,EAAE,GAAG9C,EAAN,KAAa6C,EAAE,GAAG9C,EAAlB,CAAZ,CAtByC,CAwBzC;;AACA,UAAM2D,GAAG,GAAG,CAACZ,EAAE,GAAG5C,EAAN,KAAa2C,EAAE,GAAG5C,EAAlB,CAAZ,CAzByC,CA2BzC;AACA;AAEA;;AACA,UAAM0D,OAAO,GAAG,GAAhB,CA/ByC,CAiCzC;AACA;;AACA,QAAI7C,IAAI,CAAC8C,GAAL,CAASH,GAAG,GAAGD,EAAf,IAAqBG,OAArB,IAAgC7C,IAAI,CAAC8C,GAAL,CAASF,GAAG,GAAGF,EAAf,IAAqBG,OAAzD,EAAkE;AAChE,aAAO,KAAP;AACD,KArCwC,CAuCzC;;;AACAR,IAAAA,KAAK,GAAGK,EAAR;AACAJ,IAAAA,GAAG,GAAGG,CAAN;AAEA,WAAO,IAAP;AACD,GA5Cc,CAAf,CAT8D,CAuD9D;;AACA,MAAIF,MAAM,KAAK,IAAf,EAAqB;AACnB,WAAO;AAAExD,MAAAA,CAAC,EAAE8C,KAAK,CAAC,CAAD,CAAV;AAAe7C,MAAAA,CAAC,EAAEqD,KAAK,GAAGR,KAAK,CAAC,CAAD,CAA/B;AAAoCkB,MAAAA,OAAO,EAAET;AAA7C,KAAP;AACD;;AAED,SAAO,IAAP;AACD,CA7DM;AA+DP,OAAO,SAASU,UAAT,CAAoB/D,EAApB,EAAgCC,EAAhC,EAA4CC,EAA5C,EAAwDC,EAAxD,EAAoE;AACzE,QAAM6D,EAAE,GAAG9D,EAAE,GAAGF,EAAhB;AACA,QAAMiE,EAAE,GAAG9D,EAAE,GAAGF,EAAhB;AACA,SAAOc,IAAI,CAACC,KAAL,CAAWgD,EAAX,EAAeC,EAAf,CAAP;AACD,C,CAED;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,MAArB,EAA+C;AACpD,MAAIA,MAAM,CAACC,MAAP,IAAiB,CAArB,EAAwB;AACtB,UAAM,CAACC,UAAD,EAAaC,SAAb,IAA0B,CAACH,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAACA,MAAM,CAACC,MAAP,GAAgB,CAAjB,CAAlB,CAAhC;AACA,WACEL,UAAU,CAACM,UAAU,CAAC,CAAD,CAAX,EAAgBA,UAAU,CAAC,CAAD,CAA1B,EAA+BC,SAAS,CAAC,CAAD,CAAxC,EAA6CA,SAAS,CAAC,CAAD,CAAtD,CAAV,IACA1E,sBAFF;AAID;;AACD,SAAO,KAAP;AACD,C,CAED;AACA;AACA;;AACA,OAAO,SAAS2E,gBAAT,CACLJ,MADK,EAELrE,CAFK,EAGLC,CAHK,EAII;AACT,QAAMyE,QAAQ,GAAGL,MAAM,CAACC,MAAxB,CADS,CAGT;;AACA,MAAII,QAAQ,GAAG,CAAf,EAAkB;AAChB,WAAO,KAAP;AACD;;AACD,QAAMC,OAAc,GAAG,CAACC,MAAM,CAACC,gBAAR,EAA0B5E,CAA1B,CAAvB;AACA,QAAM6E,CAAQ,GAAG,CAAC9E,CAAD,EAAIC,CAAJ,CAAjB;AACA,MAAI8E,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,QAApB,EAA8BhB,CAAC,EAA/B,EAAmC;AACjC,UAAMsB,OAAO,GAAGX,MAAM,CAACX,CAAD,CAAtB;AACA,UAAMuB,IAAI,GAAGZ,MAAM,CAAC,CAACX,CAAC,GAAG,CAAL,IAAUgB,QAAX,CAAnB;;AACA,QAAIQ,WAAW,CAACF,OAAD,EAAUC,IAAV,EAAgBH,CAAhB,EAAmBH,OAAnB,CAAf,EAA4C;AAC1C,UAAIQ,WAAW,CAACH,OAAD,EAAUF,CAAV,EAAaG,IAAb,CAAX,KAAkC,CAAtC,EAAyC;AACvC,eAAOG,SAAS,CAACJ,OAAD,EAAUF,CAAV,EAAaG,IAAb,CAAhB;AACD;;AACDF,MAAAA,KAAK;AACN;AACF,GAnBQ,CAoBT;;;AACA,SAAOA,KAAK,GAAG,CAAR,KAAc,CAArB;AACD,C,CAED;;AACA,SAASK,SAAT,CAAmBN,CAAnB,EAA6BO,CAA7B,EAAuCC,CAAvC,EAAiD;AAC/C,SACED,CAAC,CAAC,CAAD,CAAD,IAAQpE,IAAI,CAAC2B,GAAL,CAASkC,CAAC,CAAC,CAAD,CAAV,EAAeQ,CAAC,CAAC,CAAD,CAAhB,CAAR,IACAD,CAAC,CAAC,CAAD,CAAD,IAAQpE,IAAI,CAACsE,GAAL,CAAST,CAAC,CAAC,CAAD,CAAV,EAAeQ,CAAC,CAAC,CAAD,CAAhB,CADR,IAEAD,CAAC,CAAC,CAAD,CAAD,IAAQpE,IAAI,CAAC2B,GAAL,CAASkC,CAAC,CAAC,CAAD,CAAV,EAAeQ,CAAC,CAAC,CAAD,CAAhB,CAFR,IAGAD,CAAC,CAAC,CAAD,CAAD,IAAQpE,IAAI,CAACsE,GAAL,CAAST,CAAC,CAAC,CAAD,CAAV,EAAeQ,CAAC,CAAC,CAAD,CAAhB,CAJV;AAMD,C,CAED;AACA;AACA;AACA;;;AACA,SAASH,WAAT,CAAqBL,CAArB,EAA+BO,CAA/B,EAAyCC,CAAzC,EAAmD;AACjD,QAAME,GAAG,GAAG,CAACH,CAAC,CAAC,CAAD,CAAD,GAAOP,CAAC,CAAC,CAAD,CAAT,KAAiBQ,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAzB,IAAgC,CAACA,CAAC,CAAC,CAAD,CAAD,GAAOP,CAAC,CAAC,CAAD,CAAT,KAAiBQ,CAAC,CAAC,CAAD,CAAD,GAAOD,CAAC,CAAC,CAAD,CAAzB,CAA5C;;AACA,MAAIG,GAAG,KAAK,CAAZ,EAAe;AACb,WAAO,CAAP;AACD;;AACD,SAAOA,GAAG,GAAG,CAAN,GAAU,CAAV,GAAc,CAArB;AACD,C,CAED;;;AACA,SAASN,WAAT,CAAqBO,EAArB,EAAgCC,EAAhC,EAA2CC,EAA3C,EAAsDC,EAAtD,EAAiE;AAC/D,QAAMC,EAAE,GAAGV,WAAW,CAACM,EAAD,EAAKC,EAAL,EAASC,EAAT,CAAtB;AACA,QAAMG,EAAE,GAAGX,WAAW,CAACM,EAAD,EAAKC,EAAL,EAASE,EAAT,CAAtB;AACA,QAAMG,EAAE,GAAGZ,WAAW,CAACQ,EAAD,EAAKC,EAAL,EAASH,EAAT,CAAtB;AACA,QAAMO,EAAE,GAAGb,WAAW,CAACQ,EAAD,EAAKC,EAAL,EAASF,EAAT,CAAtB;;AAEA,MAAIG,EAAE,KAAKC,EAAP,IAAaC,EAAE,KAAKC,EAAxB,EAA4B;AAC1B,WAAO,IAAP;AACD,GAR8D,CAU/D;;;AACA,MAAIH,EAAE,KAAK,CAAP,IAAYT,SAAS,CAACK,EAAD,EAAKE,EAAL,EAASD,EAAT,CAAzB,EAAuC;AACrC,WAAO,IAAP;AACD,GAb8D,CAe/D;;;AACA,MAAII,EAAE,KAAK,CAAP,IAAYV,SAAS,CAACK,EAAD,EAAKG,EAAL,EAASF,EAAT,CAAzB,EAAuC;AACrC,WAAO,IAAP;AACD,GAlB8D,CAoB/D;;;AACA,MAAIK,EAAE,KAAK,CAAP,IAAYX,SAAS,CAACO,EAAD,EAAKF,EAAL,EAASG,EAAT,CAAzB,EAAuC;AACrC,WAAO,IAAP;AACD,GAvB8D,CAyB/D;;;AACA,MAAII,EAAE,KAAK,CAAP,IAAYZ,SAAS,CAACO,EAAD,EAAKD,EAAL,EAASE,EAAT,CAAzB,EAAuC;AACrC,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD","sourcesContent":["import { Point } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\n\n// https://stackoverflow.com/a/6853926/232122\nexport function distanceBetweenPointAndSegment(\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n) {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n}\n\nexport function rotate(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n) {\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  return [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n}\n\nconst adjustXYWithRotation = (\n  side: \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\",\n  x: number,\n  y: number,\n  angle: number,\n  deltaX: number,\n  deltaY: number,\n) => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  deltaX /= 2;\n  deltaY /= 2;\n  if (side === \"e\" || side === \"ne\" || side === \"se\") {\n    x += deltaX * (1 - cos);\n    y += deltaX * -sin;\n  }\n  if (side === \"s\" || side === \"sw\" || side === \"se\") {\n    x += deltaY * sin;\n    y += deltaY * (1 - cos);\n  }\n  if (side === \"w\" || side === \"nw\" || side === \"sw\") {\n    x += deltaX * (1 + cos);\n    y += deltaX * sin;\n  }\n  if (side === \"n\" || side === \"nw\" || side === \"ne\") {\n    x += deltaY * -sin;\n    y += deltaY * (1 + cos);\n  }\n  return { x, y };\n};\n\nexport const resizeXYWidthHightWithRotation = (\n  side: \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\",\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  offsetX: number,\n  offsetY: number,\n  angle: number,\n  xPointer: number,\n  yPointer: number,\n  offsetPointer: number,\n  sidesWithSameLength: boolean,\n) => {\n  // center point for rotation\n  const cx = x + width / 2;\n  const cy = y + height / 2;\n\n  // rotation with current angle\n  const [rotatedX, rotatedY] = rotate(xPointer, yPointer, cx, cy, -angle);\n\n  let scaleX = 1;\n  let scaleY = 1;\n  if (side === \"e\" || side === \"ne\" || side === \"se\") {\n    scaleX = (rotatedX - offsetPointer - x) / width;\n  }\n  if (side === \"s\" || side === \"sw\" || side === \"se\") {\n    scaleY = (rotatedY - offsetPointer - y) / height;\n  }\n  if (side === \"w\" || side === \"nw\" || side === \"sw\") {\n    scaleX = (x + width - offsetPointer - rotatedX) / width;\n  }\n  if (side === \"n\" || side === \"nw\" || side === \"ne\") {\n    scaleY = (y + height - offsetPointer - rotatedY) / height;\n  }\n\n  let nextWidth = width * scaleX;\n  let nextHeight = height * scaleY;\n  if (sidesWithSameLength) {\n    nextWidth = nextHeight = Math.max(nextWidth, nextHeight);\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    ...adjustXYWithRotation(\n      side,\n      x - offsetX,\n      y - offsetY,\n      angle,\n      width - nextWidth,\n      height - nextHeight,\n    ),\n  };\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport function distance2d(x1: number, y1: number, x2: number, y2: number) {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n}\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport function isPathALoop(points: Point[]): boolean {\n  if (points.length >= 3) {\n    const [firstPoint, lastPoint] = [points[0], points[points.length - 1]];\n    return (\n      distance2d(firstPoint[0], firstPoint[1], lastPoint[0], lastPoint[1]) <=\n      LINE_CONFIRM_THRESHOLD\n    );\n  }\n  return false;\n}\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport function isPointInPolygon(\n  points: Point[],\n  x: number,\n  y: number,\n): boolean {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doIntersect(current, next, p, extreme)) {\n      if (orientation(current, p, next) === 0) {\n        return onSegment(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n}\n\n// Check if q lies on the line segment pr\nfunction onSegment(p: Point, q: Point, r: Point) {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n}\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are collinear\n// 1 if Clockwise\n// 2 if counterclickwise\nfunction orientation(p: Point, q: Point, r: Point) {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n}\n\n// Check is p1q1 intersects with p2q2\nfunction doIntersect(p1: Point, q1: Point, p2: Point, q2: Point) {\n  const o1 = orientation(p1, q1, p2);\n  const o2 = orientation(p1, q1, q2);\n  const o3 = orientation(p2, q2, p1);\n  const o4 = orientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && onSegment(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && onSegment(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}