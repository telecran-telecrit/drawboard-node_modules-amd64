{"ast":null,"code":"import { RoughPath, PathFitter, RoughArcConverter } from './path.js';\nimport { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nconst helper = {\n  randOffset,\n  randOffsetWithRange,\n  ellipse,\n  doubleLineOps\n};\nexport function line(x1, y1, x2, y2, o) {\n  return {\n    type: 'path',\n    ops: _doubleLine(x1, y1, x2, y2, o)\n  };\n}\nexport function linearPath(points, close, o) {\n  const len = (points || []).length;\n\n  if (len > 2) {\n    let ops = [];\n\n    for (let i = 0; i < len - 1; i++) {\n      ops = ops.concat(_doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n    }\n\n    if (close) {\n      ops = ops.concat(_doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n    }\n\n    return {\n      type: 'path',\n      ops\n    };\n  } else if (len === 2) {\n    return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n  }\n\n  return {\n    type: 'path',\n    ops: []\n  };\n}\nexport function polygon(points, o) {\n  return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n  const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n  return polygon(points, o);\n}\nexport function curve(points, o) {\n  const o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n\n  const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);\n\n  return {\n    type: 'path',\n    ops: o1.concat(o2)\n  };\n}\nexport function curveAsBezierPoints(points, o) {\n  const bez = [];\n\n  if (points.length >= 3) {\n    const ops = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n\n    ops.forEach(op => {\n      switch (op.op) {\n        case 'move':\n          bez.push([op.data[0], op.data[1]]);\n          break;\n\n        case 'bcurveTo':\n          bez.push([op.data[0], op.data[1]]);\n          bez.push([op.data[2], op.data[3]]);\n          bez.push([op.data[4], op.data[5]]);\n          break;\n      }\n    });\n  }\n\n  return bez;\n}\nexport function ellipse(x, y, width, height, o) {\n  const params = generateEllipseParams(width, height, o);\n  return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n  const stepCount = Math.max(o.curveStepCount, o.curveStepCount / Math.sqrt(200) * psq);\n  const increment = Math.PI * 2 / stepCount;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  const curveFitRandomness = 1 - o.curveFitting;\n  rx += _offsetOpt(rx * curveFitRandomness, o);\n  ry += _offsetOpt(ry * curveFitRandomness, o);\n  return {\n    increment,\n    rx,\n    ry\n  };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n\n  const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n\n  const o1 = _curve(ap1, null, o);\n\n  const o2 = _curve(ap2, null, o);\n\n  return {\n    estimatedPoints: cp1,\n    opset: {\n      type: 'path',\n      ops: o1.concat(o2)\n    }\n  };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n\n  const ellipseInc = Math.PI * 2 / o.curveStepCount;\n  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n\n  const o1 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n\n  const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n\n  let ops = o1.concat(o2);\n\n  if (closed) {\n    if (roughClosure) {\n      ops = ops.concat(_doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));\n      ops = ops.concat(_doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n    } else {\n      ops.push({\n        op: 'lineTo',\n        data: [cx, cy]\n      });\n      ops.push({\n        op: 'lineTo',\n        data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)]\n      });\n    }\n  }\n\n  return {\n    type: 'path',\n    ops\n  };\n}\nexport function svgPath(path, o) {\n  path = (path || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n  let p = new RoughPath(path);\n\n  if (o.simplification) {\n    const fitter = new PathFitter(p.linearPoints, p.closed);\n    const d = fitter.fit(o.simplification);\n    p = new RoughPath(d);\n  }\n\n  let ops = [];\n  const segments = p.segments || [];\n\n  for (let i = 0; i < segments.length; i++) {\n    const s = segments[i];\n    const prev = i > 0 ? segments[i - 1] : null;\n\n    const opList = _processSegment(p, s, prev, o);\n\n    if (opList && opList.length) {\n      ops = ops.concat(opList);\n    }\n  }\n\n  return {\n    type: 'path',\n    ops\n  };\n} // Fills\n\nexport function solidFillPolygon(points, o) {\n  const ops = [];\n\n  if (points.length) {\n    const offset = o.maxRandomnessOffset || 0;\n    const len = points.length;\n\n    if (len > 2) {\n      ops.push({\n        op: 'move',\n        data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]\n      });\n\n      for (let i = 1; i < len; i++) {\n        ops.push({\n          op: 'lineTo',\n          data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]\n        });\n      }\n    }\n  }\n\n  return {\n    type: 'fillPath',\n    ops\n  };\n}\nexport function patternFillPolygon(points, o) {\n  return getFiller(o, helper).fillPolygon(points, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n  const cx = x;\n  const cy = y;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _offsetOpt(rx * 0.01, o);\n  ry += _offsetOpt(ry * 0.01, o);\n  let strt = start;\n  let stp = stop;\n\n  while (strt < 0) {\n    strt += Math.PI * 2;\n    stp += Math.PI * 2;\n  }\n\n  if (stp - strt > Math.PI * 2) {\n    strt = 0;\n    stp = Math.PI * 2;\n  }\n\n  const increment = (stp - strt) / o.curveStepCount;\n  const points = [];\n\n  for (let angle = strt; angle <= stp; angle = angle + increment) {\n    points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n  }\n\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx, cy]);\n  return patternFillPolygon(points, o);\n}\nexport function randOffset(x, o) {\n  return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n  return _offset(min, max, o);\n}\nexport function doubleLineOps(x1, y1, x2, y2, o) {\n  return _doubleLine(x1, y1, x2, y2, o);\n} // Private helpers\n\nfunction random(ops) {\n  if (!ops.randomizer) {\n    ops.randomizer = new Random(ops.seed || 0);\n  }\n\n  return ops.randomizer.next();\n}\n\nfunction _offset(min, max, ops) {\n  return ops.roughness * ops.roughnessGain * (random(ops) * (max - min) + min);\n}\n\nfunction _offsetOpt(x, ops) {\n  return _offset(-x, x, ops);\n}\n\nfunction _doubleLine(x1, y1, x2, y2, o) {\n  const o1 = _line(x1, y1, x2, y2, o, true, false);\n\n  const o2 = _line(x1, y1, x2, y2, o, true, true);\n\n  return o1.concat(o2);\n}\n\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n  const lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\n  const length = Math.sqrt(lengthSq);\n\n  if (length < 200) {\n    o.roughnessGain = 1;\n  } else if (length > 500) {\n    o.roughnessGain = 0.4;\n  } else {\n    o.roughnessGain = -0.0016668 * length + 1.233334;\n  }\n\n  let offset = o.maxRandomnessOffset || 0;\n\n  if (offset * offset * 100 > lengthSq) {\n    offset = length / 10;\n  }\n\n  const halfOffset = offset / 2;\n  const divergePoint = 0.2 + random(o) * 0.2;\n  let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n  let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n  midDispX = _offsetOpt(midDispX, o);\n  midDispY = _offsetOpt(midDispY, o);\n  const ops = [];\n\n  const randomHalf = () => _offsetOpt(halfOffset, o);\n\n  const randomFull = () => _offsetOpt(offset, o);\n\n  if (move) {\n    if (overlay) {\n      ops.push({\n        op: 'move',\n        data: [x1 + randomHalf(), y1 + randomHalf()]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [x1 + _offsetOpt(offset, o), y1 + _offsetOpt(offset, o)]\n      });\n    }\n  }\n\n  if (overlay) {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(), x2 + randomHalf(), y2 + randomHalf()]\n    });\n  } else {\n    ops.push({\n      op: 'bcurveTo',\n      data: [midDispX + x1 + (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + (y2 - y1) * divergePoint + randomFull(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(), x2 + randomFull(), y2 + randomFull()]\n    });\n  }\n\n  return ops;\n}\n\nfunction _curveWithOffset(points, offset, o) {\n  const ps = [];\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n  ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);\n\n  for (let i = 1; i < points.length; i++) {\n    ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n\n    if (i === points.length - 1) {\n      ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);\n    }\n  }\n\n  return _curve(ps, null, o);\n}\n\nfunction _curve(points, closePoint, o) {\n  const len = points.length;\n  let ops = [];\n\n  if (len > 3) {\n    const b = [];\n    const s = 1 - o.curveTightness;\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n\n    for (let i = 1; i + 2 < len; i++) {\n      const cachedVertArray = points[i];\n      b[0] = [cachedVertArray[0], cachedVertArray[1]];\n      b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n      b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n      b[3] = [points[i + 1][0], points[i + 1][1]];\n      ops.push({\n        op: 'bcurveTo',\n        data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]]\n      });\n    }\n\n    if (closePoint && closePoint.length === 2) {\n      const ro = o.maxRandomnessOffset;\n      ops.push({\n        op: 'lineTo',\n        data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)]\n      });\n    }\n  } else if (len === 3) {\n    ops.push({\n      op: 'move',\n      data: [points[1][0], points[1][1]]\n    });\n    ops.push({\n      op: 'bcurveTo',\n      data: [points[1][0], points[1][1], points[2][0], points[2][1], points[2][0], points[2][1]]\n    });\n  } else if (len === 2) {\n    ops = ops.concat(_doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n  }\n\n  return ops;\n}\n\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n  const corePoints = [];\n  const allPoints = [];\n  const radOffset = _offsetOpt(0.5, o) - Math.PI / 2;\n  allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n\n  for (let angle = radOffset; angle < Math.PI * 2 + radOffset - 0.01; angle = angle + increment) {\n    const p = [_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)];\n    corePoints.push(p);\n    allPoints.push(p);\n  }\n\n  allPoints.push([_offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);\n  allPoints.push([_offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap), _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);\n  allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);\n  return [allPoints, corePoints];\n}\n\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n  const radOffset = strt + _offsetOpt(0.1, o);\n\n  const points = [];\n  points.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);\n\n  for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n    points.push([_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)]);\n  }\n\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n  return _curve(points, null, o);\n}\n\nfunction _bezierTo(x1, y1, x2, y2, x, y, path, o) {\n  const ops = [];\n  const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];\n  let f = [0, 0];\n\n  for (let i = 0; i < 2; i++) {\n    if (i === 0) {\n      ops.push({\n        op: 'move',\n        data: [path.x, path.y]\n      });\n    } else {\n      ops.push({\n        op: 'move',\n        data: [path.x + _offsetOpt(ros[0], o), path.y + _offsetOpt(ros[0], o)]\n      });\n    }\n\n    f = [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n    ops.push({\n      op: 'bcurveTo',\n      data: [x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o), x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o), f[0], f[1]]\n    });\n  }\n\n  path.setPosition(f[0], f[1]);\n  return ops;\n}\n\nfunction _processSegment(path, seg, prevSeg, o) {\n  let ops = [];\n\n  switch (seg.key) {\n    case 'M':\n    case 'm':\n      {\n        const delta = seg.key === 'm';\n\n        if (seg.data.length >= 2) {\n          let x = +seg.data[0];\n          let y = +seg.data[1];\n\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n\n          const ro = 1 * (o.maxRandomnessOffset || 0);\n          x = x + _offsetOpt(ro, o);\n          y = y + _offsetOpt(ro, o);\n          path.setPosition(x, y);\n          ops.push({\n            op: 'move',\n            data: [x, y]\n          });\n        }\n\n        break;\n      }\n\n    case 'L':\n    case 'l':\n      {\n        const delta = seg.key === 'l';\n\n        if (seg.data.length >= 2) {\n          let x = +seg.data[0];\n          let y = +seg.data[1];\n\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n\n          ops = ops.concat(_doubleLine(path.x, path.y, x, y, o));\n          path.setPosition(x, y);\n        }\n\n        break;\n      }\n\n    case 'H':\n    case 'h':\n      {\n        const delta = seg.key === 'h';\n\n        if (seg.data.length) {\n          let x = +seg.data[0];\n\n          if (delta) {\n            x += path.x;\n          }\n\n          ops = ops.concat(_doubleLine(path.x, path.y, x, path.y, o));\n          path.setPosition(x, path.y);\n        }\n\n        break;\n      }\n\n    case 'V':\n    case 'v':\n      {\n        const delta = seg.key === 'v';\n\n        if (seg.data.length) {\n          let y = +seg.data[0];\n\n          if (delta) {\n            y += path.y;\n          }\n\n          ops = ops.concat(_doubleLine(path.x, path.y, path.x, y, o));\n          path.setPosition(path.x, y);\n        }\n\n        break;\n      }\n\n    case 'Z':\n    case 'z':\n      {\n        if (path.first) {\n          ops = ops.concat(_doubleLine(path.x, path.y, path.first[0], path.first[1], o));\n          path.setPosition(path.first[0], path.first[1]);\n          path.first = null;\n        }\n\n        break;\n      }\n\n    case 'C':\n    case 'c':\n      {\n        const delta = seg.key === 'c';\n\n        if (seg.data.length >= 6) {\n          let x1 = +seg.data[0];\n          let y1 = +seg.data[1];\n          let x2 = +seg.data[2];\n          let y2 = +seg.data[3];\n          let x = +seg.data[4];\n          let y = +seg.data[5];\n\n          if (delta) {\n            x1 += path.x;\n            x2 += path.x;\n            x += path.x;\n            y1 += path.y;\n            y2 += path.y;\n            y += path.y;\n          }\n\n          const ob = _bezierTo(x1, y1, x2, y2, x, y, path, o);\n\n          ops = ops.concat(ob);\n          path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n        }\n\n        break;\n      }\n\n    case 'S':\n    case 's':\n      {\n        const delta = seg.key === 's';\n\n        if (seg.data.length >= 4) {\n          let x2 = +seg.data[0];\n          let y2 = +seg.data[1];\n          let x = +seg.data[2];\n          let y = +seg.data[3];\n\n          if (delta) {\n            x2 += path.x;\n            x += path.x;\n            y2 += path.y;\n            y += path.y;\n          }\n\n          let x1 = x2;\n          let y1 = y2;\n          const prevKey = prevSeg ? prevSeg.key : '';\n          let ref = null;\n\n          if (prevKey === 'c' || prevKey === 'C' || prevKey === 's' || prevKey === 'S') {\n            ref = path.bezierReflectionPoint;\n          }\n\n          if (ref) {\n            x1 = ref[0];\n            y1 = ref[1];\n          }\n\n          const ob = _bezierTo(x1, y1, x2, y2, x, y, path, o);\n\n          ops = ops.concat(ob);\n          path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n        }\n\n        break;\n      }\n\n    case 'Q':\n    case 'q':\n      {\n        const delta = seg.key === 'q';\n\n        if (seg.data.length >= 4) {\n          let x1 = +seg.data[0];\n          let y1 = +seg.data[1];\n          let x = +seg.data[2];\n          let y = +seg.data[3];\n\n          if (delta) {\n            x1 += path.x;\n            x += path.x;\n            y1 += path.y;\n            y += path.y;\n          }\n\n          const offset1 = 1 * (1 + o.roughness * 0.2);\n          const offset2 = 1.5 * (1 + o.roughness * 0.22);\n          ops.push({\n            op: 'move',\n            data: [path.x + _offsetOpt(offset1, o), path.y + _offsetOpt(offset1, o)]\n          });\n          let f = [x + _offsetOpt(offset1, o), y + _offsetOpt(offset1, o)];\n          ops.push({\n            op: 'qcurveTo',\n            data: [x1 + _offsetOpt(offset1, o), y1 + _offsetOpt(offset1, o), f[0], f[1]]\n          });\n          ops.push({\n            op: 'move',\n            data: [path.x + _offsetOpt(offset2, o), path.y + _offsetOpt(offset2, o)]\n          });\n          f = [x + _offsetOpt(offset2, o), y + _offsetOpt(offset2, o)];\n          ops.push({\n            op: 'qcurveTo',\n            data: [x1 + _offsetOpt(offset2, o), y1 + _offsetOpt(offset2, o), f[0], f[1]]\n          });\n          path.setPosition(f[0], f[1]);\n          path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n        }\n\n        break;\n      }\n\n    case 'T':\n    case 't':\n      {\n        const delta = seg.key === 't';\n\n        if (seg.data.length >= 2) {\n          let x = +seg.data[0];\n          let y = +seg.data[1];\n\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n\n          let x1 = x;\n          let y1 = y;\n          const prevKey = prevSeg ? prevSeg.key : '';\n          let ref = null;\n\n          if (prevKey === 'q' || prevKey === 'Q' || prevKey === 't' || prevKey === 'T') {\n            ref = path.quadReflectionPoint;\n          }\n\n          if (ref) {\n            x1 = ref[0];\n            y1 = ref[1];\n          }\n\n          const offset1 = 1 * (1 + o.roughness * 0.2);\n          const offset2 = 1.5 * (1 + o.roughness * 0.22);\n          ops.push({\n            op: 'move',\n            data: [path.x + _offsetOpt(offset1, o), path.y + _offsetOpt(offset1, o)]\n          });\n          let f = [x + _offsetOpt(offset1, o), y + _offsetOpt(offset1, o)];\n          ops.push({\n            op: 'qcurveTo',\n            data: [x1 + _offsetOpt(offset1, o), y1 + _offsetOpt(offset1, o), f[0], f[1]]\n          });\n          ops.push({\n            op: 'move',\n            data: [path.x + _offsetOpt(offset2, o), path.y + _offsetOpt(offset2, o)]\n          });\n          f = [x + _offsetOpt(offset2, o), y + _offsetOpt(offset2, o)];\n          ops.push({\n            op: 'qcurveTo',\n            data: [x1 + _offsetOpt(offset2, o), y1 + _offsetOpt(offset2, o), f[0], f[1]]\n          });\n          path.setPosition(f[0], f[1]);\n          path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n        }\n\n        break;\n      }\n\n    case 'A':\n    case 'a':\n      {\n        const delta = seg.key === 'a';\n\n        if (seg.data.length >= 7) {\n          const rx = +seg.data[0];\n          const ry = +seg.data[1];\n          const angle = +seg.data[2];\n          const largeArcFlag = +seg.data[3];\n          const sweepFlag = +seg.data[4];\n          let x = +seg.data[5];\n          let y = +seg.data[6];\n\n          if (delta) {\n            x += path.x;\n            y += path.y;\n          }\n\n          if (x === path.x && y === path.y) {\n            break;\n          }\n\n          if (rx === 0 || ry === 0) {\n            ops = ops.concat(_doubleLine(path.x, path.y, x, y, o));\n            path.setPosition(x, y);\n          } else {\n            for (let i = 0; i < 1; i++) {\n              const arcConverter = new RoughArcConverter([path.x, path.y], [x, y], [rx, ry], angle, largeArcFlag ? true : false, sweepFlag ? true : false);\n              let segment = arcConverter.getNextSegment();\n\n              while (segment) {\n                const ob = _bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);\n\n                ops = ops.concat(ob);\n                segment = arcConverter.getNextSegment();\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n    default:\n      break;\n  }\n\n  return ops;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/renderer.js"],"names":["RoughPath","PathFitter","RoughArcConverter","getFiller","Random","helper","randOffset","randOffsetWithRange","ellipse","doubleLineOps","line","x1","y1","x2","y2","o","type","ops","_doubleLine","linearPath","points","close","len","length","i","concat","polygon","rectangle","x","y","width","height","curve","o1","_curveWithOffset","roughness","o2","curveAsBezierPoints","bez","forEach","op","push","data","params","generateEllipseParams","ellipseWithParams","opset","psq","Math","sqrt","PI","pow","stepCount","max","curveStepCount","increment","rx","abs","ry","curveFitRandomness","curveFitting","_offsetOpt","ellipseParams","ap1","cp1","_computeEllipsePoints","_offset","ap2","_curve","estimatedPoints","arc","start","stop","closed","roughClosure","cx","cy","strt","stp","ellipseInc","arcInc","min","_arc","cos","sin","svgPath","path","replace","p","simplification","fitter","linearPoints","d","fit","segments","s","prev","opList","_processSegment","solidFillPolygon","offset","maxRandomnessOffset","patternFillPolygon","fillPolygon","patternFillArc","angle","random","randomizer","seed","next","roughnessGain","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","ps","closePoint","b","curveTightness","cachedVertArray","ro","overlap","corePoints","allPoints","radOffset","_bezierTo","ros","f","setPosition","seg","prevSeg","key","delta","first","ob","bezierReflectionPoint","prevKey","ref","offset1","offset2","quadReflectionPoint","largeArcFlag","sweepFlag","arcConverter","segment","getNextSegment","cp2","to"],"mappings":"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","sourcesContent":["import { RoughPath, PathFitter, RoughArcConverter } from './path.js';\nimport { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        let ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops = ops.concat(_doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops = ops.concat(_doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y], [x + width, y], [x + width, y + height], [x, y + height]\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    const o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);\n    return { type: 'path', ops: o1.concat(o2) };\n}\nexport function curveAsBezierPoints(points, o) {\n    const bez = [];\n    if (points.length >= 3) {\n        const ops = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n        ops.forEach((op) => {\n            switch (op.op) {\n                case 'move':\n                    bez.push([op.data[0], op.data[1]]);\n                    break;\n                case 'bcurveTo':\n                    bez.push([op.data[0], op.data[1]]);\n                    bez.push([op.data[2], op.data[3]]);\n                    bez.push([op.data[4], op.data[5]]);\n                    break;\n            }\n        });\n    }\n    return bez;\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq);\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n    const o1 = _curve(ap1, null, o);\n    const o2 = _curve(ap2, null, o);\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1.concat(o2) }\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const o1 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n    let ops = o1.concat(o2);\n    if (closed) {\n        if (roughClosure) {\n            ops = ops.concat(_doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));\n            ops = ops.concat(_doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] });\n            ops.push({ op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    path = (path || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n    let p = new RoughPath(path);\n    if (o.simplification) {\n        const fitter = new PathFitter(p.linearPoints, p.closed);\n        const d = fitter.fit(o.simplification);\n        p = new RoughPath(d);\n    }\n    let ops = [];\n    const segments = p.segments || [];\n    for (let i = 0; i < segments.length; i++) {\n        const s = segments[i];\n        const prev = i > 0 ? segments[i - 1] : null;\n        const opList = _processSegment(p, s, prev, o);\n        if (opList && opList.length) {\n            ops = ops.concat(opList);\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(points, o) {\n    const ops = [];\n    if (points.length) {\n        const offset = o.maxRandomnessOffset || 0;\n        const len = points.length;\n        if (len > 2) {\n            ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n            for (let i = 1; i < len; i++) {\n                ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygon(points, o) {\n    return getFiller(o, helper).fillPolygon(points, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygon(points, o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o);\n}\n// Private helpers\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops) {\n    return ops.roughness * ops.roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops) {\n    return _offset(-x, x, ops);\n}\nfunction _doubleLine(x1, y1, x2, y2, o) {\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    if (length < 200) {\n        o.roughnessGain = 1;\n    }\n    else if (length > 500) {\n        o.roughnessGain = 0.4;\n    }\n    else {\n        o.roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o);\n    midDispY = _offsetOpt(midDispY, o);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o);\n    const randomFull = () => _offsetOpt(offset, o);\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + randomHalf(),\n                    y1 + randomHalf()\n                ]\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + _offsetOpt(offset, o),\n                    y1 + _offsetOpt(offset, o)\n                ]\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo', data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + randomHalf(),\n                y2 + randomHalf()\n            ]\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo', data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + randomFull(),\n                y2 + randomFull()\n            ]\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    let ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo', data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1]\n            ]\n        });\n    }\n    else if (len === 2) {\n        ops = ops.concat(_doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const corePoints = [];\n    const allPoints = [];\n    const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle < (Math.PI * 2 + radOffset - 0.01); angle = angle + increment) {\n        const p = [\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle)\n        ];\n        corePoints.push(p);\n        allPoints.push(p);\n    }\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n        _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)\n    ]);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n        _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)\n    ]);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)\n    ]);\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle)\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp)\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp)\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, path, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];\n    let f = [0, 0];\n    for (let i = 0; i < 2; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [path.x, path.y] });\n        }\n        else {\n            ops.push({ op: 'move', data: [path.x + _offsetOpt(ros[0], o), path.y + _offsetOpt(ros[0], o)] });\n        }\n        f = [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo', data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1]\n            ]\n        });\n    }\n    path.setPosition(f[0], f[1]);\n    return ops;\n}\nfunction _processSegment(path, seg, prevSeg, o) {\n    let ops = [];\n    switch (seg.key) {\n        case 'M':\n        case 'm': {\n            const delta = seg.key === 'm';\n            if (seg.data.length >= 2) {\n                let x = +seg.data[0];\n                let y = +seg.data[1];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                const ro = 1 * (o.maxRandomnessOffset || 0);\n                x = x + _offsetOpt(ro, o);\n                y = y + _offsetOpt(ro, o);\n                path.setPosition(x, y);\n                ops.push({ op: 'move', data: [x, y] });\n            }\n            break;\n        }\n        case 'L':\n        case 'l': {\n            const delta = seg.key === 'l';\n            if (seg.data.length >= 2) {\n                let x = +seg.data[0];\n                let y = +seg.data[1];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                ops = ops.concat(_doubleLine(path.x, path.y, x, y, o));\n                path.setPosition(x, y);\n            }\n            break;\n        }\n        case 'H':\n        case 'h': {\n            const delta = seg.key === 'h';\n            if (seg.data.length) {\n                let x = +seg.data[0];\n                if (delta) {\n                    x += path.x;\n                }\n                ops = ops.concat(_doubleLine(path.x, path.y, x, path.y, o));\n                path.setPosition(x, path.y);\n            }\n            break;\n        }\n        case 'V':\n        case 'v': {\n            const delta = seg.key === 'v';\n            if (seg.data.length) {\n                let y = +seg.data[0];\n                if (delta) {\n                    y += path.y;\n                }\n                ops = ops.concat(_doubleLine(path.x, path.y, path.x, y, o));\n                path.setPosition(path.x, y);\n            }\n            break;\n        }\n        case 'Z':\n        case 'z': {\n            if (path.first) {\n                ops = ops.concat(_doubleLine(path.x, path.y, path.first[0], path.first[1], o));\n                path.setPosition(path.first[0], path.first[1]);\n                path.first = null;\n            }\n            break;\n        }\n        case 'C':\n        case 'c': {\n            const delta = seg.key === 'c';\n            if (seg.data.length >= 6) {\n                let x1 = +seg.data[0];\n                let y1 = +seg.data[1];\n                let x2 = +seg.data[2];\n                let y2 = +seg.data[3];\n                let x = +seg.data[4];\n                let y = +seg.data[5];\n                if (delta) {\n                    x1 += path.x;\n                    x2 += path.x;\n                    x += path.x;\n                    y1 += path.y;\n                    y2 += path.y;\n                    y += path.y;\n                }\n                const ob = _bezierTo(x1, y1, x2, y2, x, y, path, o);\n                ops = ops.concat(ob);\n                path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n            }\n            break;\n        }\n        case 'S':\n        case 's': {\n            const delta = seg.key === 's';\n            if (seg.data.length >= 4) {\n                let x2 = +seg.data[0];\n                let y2 = +seg.data[1];\n                let x = +seg.data[2];\n                let y = +seg.data[3];\n                if (delta) {\n                    x2 += path.x;\n                    x += path.x;\n                    y2 += path.y;\n                    y += path.y;\n                }\n                let x1 = x2;\n                let y1 = y2;\n                const prevKey = prevSeg ? prevSeg.key : '';\n                let ref = null;\n                if (prevKey === 'c' || prevKey === 'C' || prevKey === 's' || prevKey === 'S') {\n                    ref = path.bezierReflectionPoint;\n                }\n                if (ref) {\n                    x1 = ref[0];\n                    y1 = ref[1];\n                }\n                const ob = _bezierTo(x1, y1, x2, y2, x, y, path, o);\n                ops = ops.concat(ob);\n                path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n            }\n            break;\n        }\n        case 'Q':\n        case 'q': {\n            const delta = seg.key === 'q';\n            if (seg.data.length >= 4) {\n                let x1 = +seg.data[0];\n                let y1 = +seg.data[1];\n                let x = +seg.data[2];\n                let y = +seg.data[3];\n                if (delta) {\n                    x1 += path.x;\n                    x += path.x;\n                    y1 += path.y;\n                    y += path.y;\n                }\n                const offset1 = 1 * (1 + o.roughness * 0.2);\n                const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset1, o), path.y + _offsetOpt(offset1, o)] });\n                let f = [x + _offsetOpt(offset1, o), y + _offsetOpt(offset1, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset1, o), y1 + _offsetOpt(offset1, o),\n                        f[0], f[1]\n                    ]\n                });\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset2, o), path.y + _offsetOpt(offset2, o)] });\n                f = [x + _offsetOpt(offset2, o), y + _offsetOpt(offset2, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset2, o), y1 + _offsetOpt(offset2, o),\n                        f[0], f[1]\n                    ]\n                });\n                path.setPosition(f[0], f[1]);\n                path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n            }\n            break;\n        }\n        case 'T':\n        case 't': {\n            const delta = seg.key === 't';\n            if (seg.data.length >= 2) {\n                let x = +seg.data[0];\n                let y = +seg.data[1];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                let x1 = x;\n                let y1 = y;\n                const prevKey = prevSeg ? prevSeg.key : '';\n                let ref = null;\n                if (prevKey === 'q' || prevKey === 'Q' || prevKey === 't' || prevKey === 'T') {\n                    ref = path.quadReflectionPoint;\n                }\n                if (ref) {\n                    x1 = ref[0];\n                    y1 = ref[1];\n                }\n                const offset1 = 1 * (1 + o.roughness * 0.2);\n                const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset1, o), path.y + _offsetOpt(offset1, o)] });\n                let f = [x + _offsetOpt(offset1, o), y + _offsetOpt(offset1, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset1, o), y1 + _offsetOpt(offset1, o),\n                        f[0], f[1]\n                    ]\n                });\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset2, o), path.y + _offsetOpt(offset2, o)] });\n                f = [x + _offsetOpt(offset2, o), y + _offsetOpt(offset2, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset2, o), y1 + _offsetOpt(offset2, o),\n                        f[0], f[1]\n                    ]\n                });\n                path.setPosition(f[0], f[1]);\n                path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n            }\n            break;\n        }\n        case 'A':\n        case 'a': {\n            const delta = seg.key === 'a';\n            if (seg.data.length >= 7) {\n                const rx = +seg.data[0];\n                const ry = +seg.data[1];\n                const angle = +seg.data[2];\n                const largeArcFlag = +seg.data[3];\n                const sweepFlag = +seg.data[4];\n                let x = +seg.data[5];\n                let y = +seg.data[6];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                if (x === path.x && y === path.y) {\n                    break;\n                }\n                if (rx === 0 || ry === 0) {\n                    ops = ops.concat(_doubleLine(path.x, path.y, x, y, o));\n                    path.setPosition(x, y);\n                }\n                else {\n                    for (let i = 0; i < 1; i++) {\n                        const arcConverter = new RoughArcConverter([path.x, path.y], [x, y], [rx, ry], angle, largeArcFlag ? true : false, sweepFlag ? true : false);\n                        let segment = arcConverter.getNextSegment();\n                        while (segment) {\n                            const ob = _bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);\n                            ops = ops.concat(ob);\n                            segment = arcConverter.getNextSegment();\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        default:\n            break;\n    }\n    return ops;\n}\n"]},"metadata":{},"sourceType":"module"}