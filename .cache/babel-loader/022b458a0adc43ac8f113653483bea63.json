{"ast":null,"code":"import _slicedToArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { getElementAbsoluteCoords } from \"./bounds\";\nvar handleSizes = {\n  mouse: 8,\n  pen: 16,\n  touch: 28\n};\nexport function handlerRectangles(element, zoom) {\n  var pointerType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"mouse\";\n  var size = handleSizes[pointerType];\n  var handlerWidth = size / zoom;\n  var handlerHeight = size / zoom;\n  var handlerMarginX = size / zoom;\n  var handlerMarginY = size / zoom;\n\n  var _getElementAbsoluteCo = getElementAbsoluteCoords(element),\n      _getElementAbsoluteCo2 = _slicedToArray(_getElementAbsoluteCo, 4),\n      elementX1 = _getElementAbsoluteCo2[0],\n      elementY1 = _getElementAbsoluteCo2[1],\n      elementX2 = _getElementAbsoluteCo2[2],\n      elementY2 = _getElementAbsoluteCo2[3];\n\n  var elementWidth = elementX2 - elementX1;\n  var elementHeight = elementY2 - elementY1;\n  var dashedLineMargin = 4 / zoom;\n  var centeringOffset = (size - 8) / (2 * zoom);\n  var handlers = {\n    nw: [elementX1 - dashedLineMargin - handlerMarginX + centeringOffset, elementY1 - dashedLineMargin - handlerMarginY + centeringOffset, handlerWidth, handlerHeight],\n    ne: [elementX2 + dashedLineMargin - centeringOffset, elementY1 - dashedLineMargin - handlerMarginY + centeringOffset, handlerWidth, handlerHeight],\n    sw: [elementX1 - dashedLineMargin - handlerMarginX + centeringOffset, elementY2 + dashedLineMargin - centeringOffset, handlerWidth, handlerHeight],\n    se: [elementX2 + dashedLineMargin - centeringOffset, elementY2 + dashedLineMargin - centeringOffset, handlerWidth, handlerHeight]\n  }; // We only want to show height handlers (all cardinal directions)  above a certain size\n\n  var minimumSizeForEightHandlers = 5 * size / zoom;\n\n  if (Math.abs(elementWidth) > minimumSizeForEightHandlers) {\n    handlers[\"n\"] = [elementX1 + elementWidth / 2 - handlerWidth / 2, elementY1 - dashedLineMargin - handlerMarginY + centeringOffset, handlerWidth, handlerHeight];\n    handlers[\"s\"] = [elementX1 + elementWidth / 2 - handlerWidth / 2, elementY2 + dashedLineMargin - centeringOffset, handlerWidth, handlerHeight];\n  }\n\n  if (Math.abs(elementHeight) > minimumSizeForEightHandlers) {\n    handlers[\"w\"] = [elementX1 - dashedLineMargin - handlerMarginX + centeringOffset, elementY1 + elementHeight / 2 - handlerHeight / 2, handlerWidth, handlerHeight];\n    handlers[\"e\"] = [elementX2 + dashedLineMargin - centeringOffset, elementY1 + elementHeight / 2 - handlerHeight / 2, handlerWidth, handlerHeight];\n  }\n\n  if (element.type === \"arrow\" || element.type === \"line\") {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      var _element$points = _slicedToArray(element.points, 2),\n          p1 = _element$points[1];\n\n      if (p1[0] === 0 || p1[1] === 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se\n        };\n      }\n\n      if (p1[0] > 0 && p1[1] < 0) {\n        return {\n          ne: handlers.ne,\n          sw: handlers.sw\n        };\n      }\n\n      if (p1[0] > 0 && p1[1] > 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se\n        };\n      }\n\n      if (p1[0] < 0 && p1[1] > 0) {\n        return {\n          ne: handlers.ne,\n          sw: handlers.sw\n        };\n      }\n\n      if (p1[0] < 0 && p1[1] < 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se\n        };\n      }\n    }\n\n    return {\n      n: handlers.n,\n      s: handlers.s,\n      w: handlers.w,\n      e: handlers.e\n    };\n  }\n\n  return handlers;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/handlerRectangles.ts"],"names":["getElementAbsoluteCoords","handleSizes","mouse","pen","touch","handlerRectangles","element","zoom","pointerType","size","handlerWidth","handlerHeight","handlerMarginX","handlerMarginY","elementX1","elementY1","elementX2","elementY2","elementWidth","elementHeight","dashedLineMargin","centeringOffset","handlers","nw","ne","sw","se","minimumSizeForEightHandlers","Math","abs","type","points","length","p1","n","s","w","e"],"mappings":"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","sourcesContent":["import { ExcalidrawElement, PointerType } from \"./types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\n\ntype Sides = \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\";\n\nconst handleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nexport function handlerRectangles(\n  element: ExcalidrawElement,\n  zoom: number,\n  pointerType: PointerType = \"mouse\",\n) {\n  const size = handleSizes[pointerType];\n  const handlerWidth = size / zoom;\n  const handlerHeight = size / zoom;\n\n  const handlerMarginX = size / zoom;\n  const handlerMarginY = size / zoom;\n\n  const [elementX1, elementY1, elementX2, elementY2] = getElementAbsoluteCoords(\n    element,\n  );\n\n  const elementWidth = elementX2 - elementX1;\n  const elementHeight = elementY2 - elementY1;\n\n  const dashedLineMargin = 4 / zoom;\n\n  const centeringOffset = (size - 8) / (2 * zoom);\n\n  const handlers = {\n    nw: [\n      elementX1 - dashedLineMargin - handlerMarginX + centeringOffset,\n      elementY1 - dashedLineMargin - handlerMarginY + centeringOffset,\n      handlerWidth,\n      handlerHeight,\n    ],\n    ne: [\n      elementX2 + dashedLineMargin - centeringOffset,\n      elementY1 - dashedLineMargin - handlerMarginY + centeringOffset,\n      handlerWidth,\n      handlerHeight,\n    ],\n    sw: [\n      elementX1 - dashedLineMargin - handlerMarginX + centeringOffset,\n      elementY2 + dashedLineMargin - centeringOffset,\n      handlerWidth,\n      handlerHeight,\n    ],\n    se: [\n      elementX2 + dashedLineMargin - centeringOffset,\n      elementY2 + dashedLineMargin - centeringOffset,\n      handlerWidth,\n      handlerHeight,\n    ],\n  } as { [T in Sides]: number[] };\n\n  // We only want to show height handlers (all cardinal directions)  above a certain size\n  const minimumSizeForEightHandlers = (5 * size) / zoom;\n  if (Math.abs(elementWidth) > minimumSizeForEightHandlers) {\n    handlers[\"n\"] = [\n      elementX1 + elementWidth / 2 - handlerWidth / 2,\n      elementY1 - dashedLineMargin - handlerMarginY + centeringOffset,\n      handlerWidth,\n      handlerHeight,\n    ];\n    handlers[\"s\"] = [\n      elementX1 + elementWidth / 2 - handlerWidth / 2,\n      elementY2 + dashedLineMargin - centeringOffset,\n      handlerWidth,\n      handlerHeight,\n    ];\n  }\n  if (Math.abs(elementHeight) > minimumSizeForEightHandlers) {\n    handlers[\"w\"] = [\n      elementX1 - dashedLineMargin - handlerMarginX + centeringOffset,\n      elementY1 + elementHeight / 2 - handlerHeight / 2,\n      handlerWidth,\n      handlerHeight,\n    ];\n    handlers[\"e\"] = [\n      elementX2 + dashedLineMargin - centeringOffset,\n      elementY1 + elementHeight / 2 - handlerHeight / 2,\n      handlerWidth,\n      handlerHeight,\n    ];\n  }\n\n  if (element.type === \"arrow\" || element.type === \"line\") {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n\n      if (p1[0] === 0 || p1[1] === 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se,\n        } as typeof handlers;\n      }\n\n      if (p1[0] > 0 && p1[1] < 0) {\n        return {\n          ne: handlers.ne,\n          sw: handlers.sw,\n        } as typeof handlers;\n      }\n\n      if (p1[0] > 0 && p1[1] > 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se,\n        } as typeof handlers;\n      }\n\n      if (p1[0] < 0 && p1[1] > 0) {\n        return {\n          ne: handlers.ne,\n          sw: handlers.sw,\n        } as typeof handlers;\n      }\n\n      if (p1[0] < 0 && p1[1] < 0) {\n        return {\n          nw: handlers.nw,\n          se: handlers.se,\n        } as typeof handlers;\n      }\n    }\n\n    return {\n      n: handlers.n,\n      s: handlers.s,\n      w: handlers.w,\n      e: handlers.e,\n    } as typeof handlers;\n  }\n\n  return handlers;\n}\n"]},"metadata":{},"sourceType":"module"}