{"ast":null,"code":"import _toConsumableArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(points, o) {\n  var rotationCenter = [0, 0];\n  var angle = Math.round(o.hachureAngle + 90);\n\n  if (angle) {\n    rotatePoints(points, rotationCenter, angle);\n  }\n\n  var lines = straightHachureLines(points, o);\n\n  if (angle) {\n    rotatePoints(points, rotationCenter, -angle);\n    rotateLines(lines, rotationCenter, -angle);\n  }\n\n  return lines;\n}\n\nfunction straightHachureLines(points, o) {\n  var vertices = _toConsumableArray(points);\n\n  if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n    vertices.push([vertices[0][0], vertices[0][1]]);\n  }\n\n  var lines = [];\n\n  if (vertices && vertices.length > 2) {\n    var _ret = function () {\n      var gap = o.hachureGap;\n\n      if (gap < 0) {\n        gap = o.strokeWidth * 4;\n      }\n\n      gap = Math.max(gap, 0.1); // Create sorted edges table\n\n      var edges = [];\n\n      for (var i = 0; i < vertices.length - 1; i++) {\n        var p1 = vertices[i];\n        var p2 = vertices[i + 1];\n\n        if (p1[1] !== p2[1]) {\n          var ymin = Math.min(p1[1], p2[1]);\n          edges.push({\n            ymin: ymin,\n            ymax: Math.max(p1[1], p2[1]),\n            x: ymin === p1[1] ? p1[0] : p2[0],\n            islope: (p2[0] - p1[0]) / (p2[1] - p1[1])\n          });\n        }\n      }\n\n      edges.sort(function (e1, e2) {\n        if (e1.ymin < e2.ymin) {\n          return -1;\n        }\n\n        if (e1.ymin > e2.ymin) {\n          return 1;\n        }\n\n        if (e1.x < e2.x) {\n          return -1;\n        }\n\n        if (e1.x > e2.x) {\n          return 1;\n        }\n\n        if (e1.ymax === e2.ymax) {\n          return 0;\n        }\n\n        return (e1.ymax - e2.ymax) / Math.abs(e1.ymax - e2.ymax);\n      });\n\n      if (!edges.length) {\n        return {\n          v: lines\n        };\n      } // Start scanning\n\n\n      var activeEdges = [];\n      var y = edges[0].ymin;\n\n      while (activeEdges.length || edges.length) {\n        if (edges.length) {\n          var ix = -1;\n\n          for (var _i = 0; _i < edges.length; _i++) {\n            if (edges[_i].ymin > y) {\n              break;\n            }\n\n            ix = _i;\n          }\n\n          var removed = edges.splice(0, ix + 1);\n          removed.forEach(function (edge) {\n            activeEdges.push({\n              s: y,\n              edge: edge\n            });\n          });\n        }\n\n        activeEdges = activeEdges.filter(function (ae) {\n          if (ae.edge.ymax <= y) {\n            return false;\n          }\n\n          return true;\n        });\n        activeEdges.sort(function (ae1, ae2) {\n          if (ae1.edge.x === ae2.edge.x) {\n            return 0;\n          }\n\n          return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);\n        }); // fill between the edges\n\n        if (activeEdges.length > 1) {\n          for (var _i2 = 0; _i2 < activeEdges.length; _i2 = _i2 + 2) {\n            var nexti = _i2 + 1;\n\n            if (nexti >= activeEdges.length) {\n              break;\n            }\n\n            var ce = activeEdges[_i2].edge;\n            var ne = activeEdges[nexti].edge;\n            lines.push([[Math.round(ce.x), y], [Math.round(ne.x), y]]);\n          }\n        }\n\n        y += gap;\n        activeEdges.forEach(function (ae) {\n          ae.edge.x = ae.edge.x + gap * ae.edge.islope;\n        });\n      }\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return lines;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/fillers/scan-line-hachure.js"],"names":["rotatePoints","rotateLines","polygonHachureLines","points","o","rotationCenter","angle","Math","round","hachureAngle","lines","straightHachureLines","vertices","join","length","push","gap","hachureGap","strokeWidth","max","edges","i","p1","p2","ymin","min","ymax","x","islope","sort","e1","e2","abs","activeEdges","y","ix","removed","splice","forEach","edge","s","filter","ae","ae1","ae2","nexti","ce","ne"],"mappings":"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","sourcesContent":["import { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(points, o) {\n    const rotationCenter = [0, 0];\n    const angle = Math.round(o.hachureAngle + 90);\n    if (angle) {\n        rotatePoints(points, rotationCenter, angle);\n    }\n    const lines = straightHachureLines(points, o);\n    if (angle) {\n        rotatePoints(points, rotationCenter, -angle);\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(points, o) {\n    const vertices = [...points];\n    if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n        vertices.push([vertices[0][0], vertices[0][1]]);\n    }\n    const lines = [];\n    if (vertices && vertices.length > 2) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        // Create sorted edges table\n        const edges = [];\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1])\n                });\n            }\n        }\n        edges.sort((e1, e2) => {\n            if (e1.ymin < e2.ymin) {\n                return -1;\n            }\n            if (e1.ymin > e2.ymin) {\n                return 1;\n            }\n            if (e1.x < e2.x) {\n                return -1;\n            }\n            if (e1.x > e2.x) {\n                return 1;\n            }\n            if (e1.ymax === e2.ymax) {\n                return 0;\n            }\n            return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n        });\n        if (!edges.length) {\n            return lines;\n        }\n        // Start scanning\n        let activeEdges = [];\n        let y = edges[0].ymin;\n        while (activeEdges.length || edges.length) {\n            if (edges.length) {\n                let ix = -1;\n                for (let i = 0; i < edges.length; i++) {\n                    if (edges[i].ymin > y) {\n                        break;\n                    }\n                    ix = i;\n                }\n                const removed = edges.splice(0, ix + 1);\n                removed.forEach((edge) => {\n                    activeEdges.push({ s: y, edge });\n                });\n            }\n            activeEdges = activeEdges.filter((ae) => {\n                if (ae.edge.ymax <= y) {\n                    return false;\n                }\n                return true;\n            });\n            activeEdges.sort((ae1, ae2) => {\n                if (ae1.edge.x === ae2.edge.x) {\n                    return 0;\n                }\n                return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n            });\n            // fill between the edges\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y]\n                    ]);\n                }\n            }\n            y += gap;\n            activeEdges.forEach((ae) => {\n                ae.edge.x = ae.edge.x + (gap * ae.edge.islope);\n            });\n        }\n    }\n    return lines;\n}\n"]},"metadata":{},"sourceType":"module"}