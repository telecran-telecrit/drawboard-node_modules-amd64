{"ast":null,"code":"import oc from \"open-color\";\nimport { getElementAbsoluteCoords, OMIT_SIDES_FOR_MULTIPLE_ELEMENTS, handlerRectanglesFromCoords, handlerRectangles, getCommonBounds, canResizeMutlipleElements, isTextElement } from \"../element\";\nimport { roundRect } from \"./roundRect\";\nimport { getScrollBars, SCROLLBAR_COLOR, SCROLLBAR_WIDTH } from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport colors from \"../colors\";\n\nfunction colorsForClientId(clientId) {\n  // Naive way of getting an integer out of the clientId\n  const sum = clientId.split(\"\").reduce((a, str) => a + str.charCodeAt(0), 0); // Skip transparent background.\n\n  const backgrounds = colors.elementBackground.slice(1);\n  const strokes = colors.elementStroke.slice(1);\n  return {\n    background: backgrounds[sum % backgrounds.length],\n    stroke: strokes[sum % strokes.length]\n  };\n}\n\nfunction strokeRectWithRotation(context, x, y, width, height, cx, cy, angle, fill) {\n  context.translate(cx, cy);\n  context.rotate(angle);\n\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n}\n\nfunction strokeCircle(context, x, y, width, height) {\n  context.beginPath();\n  context.arc(x + width / 2, y + height / 2, width / 2, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n}\n\nexport function renderScene(elements, appState, selectionElement, scale, rc, canvas, sceneState, // extra options, currently passed by export helper\n{\n  renderScrollbars = true,\n  renderSelection = true,\n  // Whether to employ render optimizations to improve performance.\n  // Should not be turned on for export operations and similar, because it\n  //  doesn't guarantee pixel-perfect output.\n  renderOptimizations = false\n} = {}) {\n  var _appState$wysiwygElem;\n\n  if (!canvas) {\n    return {\n      atLeastOneVisibleElement: false\n    };\n  }\n\n  if (((_appState$wysiwygElem = appState.wysiwygElement) === null || _appState$wysiwygElem === void 0 ? void 0 : _appState$wysiwygElem.changeStyle) && isTextElement(appState.editingElement)) {\n    appState.wysiwygElement.changeStyle({\n      font: appState.editingElement.font,\n      textAlign: appState.editingElement.textAlign,\n      color: appState.editingElement.strokeColor,\n      opacity: appState.editingElement.opacity\n    });\n  }\n\n  const context = canvas.getContext(\"2d\");\n  context.scale(scale, scale); // When doing calculations based on canvas width we should used normalized one\n\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale; // Paint background\n\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence = sceneState.viewBackgroundColor === \"transparent\" || sceneState.viewBackgroundColor.length === 5 || sceneState.viewBackgroundColor.length === 9;\n\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  } // Apply zoom\n\n\n  const zoomTranslationX = -normalizedCanvasWidth * (sceneState.zoom - 1) / 2;\n  const zoomTranslationY = -normalizedCanvasHeight * (sceneState.zoom - 1) / 2;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom, sceneState.zoom); // Paint visible elements\n\n  const visibleElements = elements.filter(element => isVisibleElement(element, normalizedCanvasWidth, normalizedCanvasHeight, sceneState));\n  visibleElements.forEach(element => {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  }); // Pain selection element\n\n  if (selectionElement) {\n    renderElement(selectionElement, rc, context, renderOptimizations, sceneState);\n  } // Paint selected elements\n\n\n  if (renderSelection) {\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = []; // local user\n\n      if (appState.selectedElementIds[element.id]) {\n        selectionColors.push(oc.black);\n      } // remote users\n\n\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(...sceneState.remoteSelectedElementIds[element.id].map(socketId => {\n          const {\n            background\n          } = colorsForClientId(socketId);\n          return background;\n        }));\n      }\n\n      if (selectionColors.length) {\n        acc.push({\n          element,\n          selectionColors\n        });\n      }\n\n      return acc;\n    }, []);\n    selections.forEach(({\n      element,\n      selectionColors\n    }) => {\n      const [elementX1, elementY1, elementX2, elementY2] = getElementAbsoluteCoords(element);\n      const elementWidth = elementX2 - elementX1;\n      const elementHeight = elementY2 - elementY1;\n      const initialLineDash = context.getLineDash();\n      const lineWidth = context.lineWidth;\n      const lineDashOffset = context.lineDashOffset;\n      const strokeStyle = context.strokeStyle;\n      const dashedLinePadding = 4 / sceneState.zoom;\n      const dashWidth = 8 / sceneState.zoom;\n      const spaceWidth = 4 / sceneState.zoom;\n      context.lineWidth = 1 / sceneState.zoom;\n      const count = selectionColors.length;\n\n      for (var i = 0; i < count; ++i) {\n        context.strokeStyle = selectionColors[i];\n        context.setLineDash([dashWidth, spaceWidth + (dashWidth + spaceWidth) * (count - 1)]);\n        context.lineDashOffset = (dashWidth + spaceWidth) * i;\n        strokeRectWithRotation(context, elementX1 - dashedLinePadding, elementY1 - dashedLinePadding, elementWidth + dashedLinePadding * 2, elementHeight + dashedLinePadding * 2, elementX1 + elementWidth / 2, elementY1 + elementHeight / 2, element.angle);\n      }\n\n      context.lineDashOffset = lineDashOffset;\n      context.strokeStyle = strokeStyle;\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n    });\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n    const locallySelectedElements = getSelectedElements(elements, appState); // Paint resize handlers\n\n    if (locallySelectedElements.length === 1) {\n      context.translate(sceneState.scrollX, sceneState.scrollY);\n      context.fillStyle = oc.white;\n      const handlers = handlerRectangles(locallySelectedElements[0], sceneState.zoom);\n      Object.keys(handlers).forEach(key => {\n        const handler = handlers[key];\n\n        if (handler !== undefined) {\n          const lineWidth = context.lineWidth;\n          context.lineWidth = 1 / sceneState.zoom;\n\n          if (key === \"rotation\") {\n            strokeCircle(context, handler[0], handler[1], handler[2], handler[3]);\n          } else if (locallySelectedElements[0].type !== \"text\") {\n            strokeRectWithRotation(context, handler[0], handler[1], handler[2], handler[3], handler[0] + handler[2] / 2, handler[1] + handler[3] / 2, locallySelectedElements[0].angle, true // fill before stroke\n            );\n          }\n\n          context.lineWidth = lineWidth;\n        }\n      });\n      context.translate(-sceneState.scrollX, -sceneState.scrollY);\n    } else if (locallySelectedElements.length > 1) {\n      if (canResizeMutlipleElements(locallySelectedElements)) {\n        const dashedLinePadding = 4 / sceneState.zoom;\n        context.translate(sceneState.scrollX, sceneState.scrollY);\n        context.fillStyle = oc.white;\n        const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n        const initialLineDash = context.getLineDash();\n        context.setLineDash([2 / sceneState.zoom]);\n        const lineWidth = context.lineWidth;\n        context.lineWidth = 1 / sceneState.zoom;\n        strokeRectWithRotation(context, x1 - dashedLinePadding, y1 - dashedLinePadding, x2 - x1 + dashedLinePadding * 2, y2 - y1 + dashedLinePadding * 2, (x1 + x2) / 2, (y1 + y2) / 2, 0);\n        context.lineWidth = lineWidth;\n        context.setLineDash(initialLineDash);\n        const handlers = handlerRectanglesFromCoords([x1, y1, x2, y2], 0, sceneState.zoom, undefined, OMIT_SIDES_FOR_MULTIPLE_ELEMENTS);\n        Object.keys(handlers).forEach(key => {\n          const handler = handlers[key];\n\n          if (handler !== undefined) {\n            const lineWidth = context.lineWidth;\n            context.lineWidth = 1 / sceneState.zoom;\n            strokeRectWithRotation(context, handler[0], handler[1], handler[2], handler[3], handler[0] + handler[2] / 2, handler[1] + handler[3] / 2, 0, true // fill before stroke\n            );\n            context.lineWidth = lineWidth;\n          }\n        });\n        context.translate(-sceneState.scrollX, -sceneState.scrollY);\n      }\n    }\n  } // Reset zoom\n\n\n  context.scale(1 / sceneState.zoom, 1 / sceneState.zoom);\n  context.translate(-zoomTranslationX, -zoomTranslationY); // Paint remote pointers\n\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let {\n      x,\n      y\n    } = sceneState.remotePointerViewportCoords[clientId];\n    const username = sceneState.remotePointerUsernames[clientId];\n    const width = 9;\n    const height = 14;\n    const isOutOfBounds = x < 0 || x > normalizedCanvasWidth - width || y < 0 || y > normalizedCanvasHeight - height;\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n    const {\n      background,\n      stroke\n    } = colorsForClientId(clientId);\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n\n    if (isOutOfBounds) {\n      context.globalAlpha = 0.2;\n    }\n\n    if (sceneState.remotePointerButton && sceneState.remotePointerButton[clientId] === \"down\") {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    if (!isOutOfBounds && username) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(username);\n      const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent; // Border\n\n      context.fillStyle = stroke;\n      context.globalAlpha = globalAlpha;\n      context.fillRect(offsetX - 1, offsetY - 1, measure.width + 2 * paddingHorizontal + 2, measureHeight + 2 * paddingVertical + 2); // Background\n\n      context.fillStyle = background;\n      context.fillRect(offsetX, offsetY, measure.width + 2 * paddingHorizontal, measureHeight + 2 * paddingVertical);\n      context.fillStyle = oc.white;\n      context.fillText(username, offsetX + paddingHorizontal, offsetY + paddingVertical + measure.actualBoundingBoxAscent);\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  } // Paint scrollbars\n\n\n  let scrollBars;\n\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(elements, normalizedCanvasWidth, normalizedCanvasHeight, sceneState);\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach(scrollBar => {\n      if (scrollBar) {\n        roundRect(context, scrollBar.x, scrollBar.y, scrollBar.width, scrollBar.height, SCROLLBAR_WIDTH / 2);\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n  return {\n    atLeastOneVisibleElement: visibleElements.length > 0,\n    scrollBars\n  };\n}\n\nfunction isVisibleElement(element, viewportWidth, viewportHeight, {\n  scrollX,\n  scrollY,\n  zoom\n}) {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element); // Apply zoom\n\n  const viewportWidthWithZoom = viewportWidth / zoom;\n  const viewportHeightWithZoom = viewportHeight / zoom;\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n  return x2 + scrollX - viewportWidthDiff / 2 >= 0 && x1 + scrollX - viewportWidthDiff / 2 <= viewportWidthWithZoom && y2 + scrollY - viewportHeightDiff / 2 >= 0 && y1 + scrollY - viewportHeightDiff / 2 <= viewportHeightWithZoom;\n} // This should be only called for exporting purposes\n\n\nexport function renderSceneToSvg(elements, rsvg, svgRoot, {\n  offsetX = 0,\n  offsetY = 0\n} = {}) {\n  if (!svgRoot) {\n    return;\n  } // render elements\n\n\n  elements.forEach(element => {\n    if (!element.isDeleted) {\n      renderElementToSvg(element, rsvg, svgRoot, element.x + offsetX, element.y + offsetY);\n    }\n  });\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/renderer/renderScene.ts"],"names":["oc","getElementAbsoluteCoords","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","handlerRectanglesFromCoords","handlerRectangles","getCommonBounds","canResizeMutlipleElements","isTextElement","roundRect","getScrollBars","SCROLLBAR_COLOR","SCROLLBAR_WIDTH","getSelectedElements","renderElement","renderElementToSvg","colors","colorsForClientId","clientId","sum","split","reduce","a","str","charCodeAt","backgrounds","elementBackground","slice","strokes","elementStroke","background","length","stroke","strokeRectWithRotation","context","x","y","width","height","cx","cy","angle","fill","translate","rotate","fillRect","strokeRect","strokeCircle","beginPath","arc","Math","PI","renderScene","elements","appState","selectionElement","scale","rc","canvas","sceneState","renderScrollbars","renderSelection","renderOptimizations","atLeastOneVisibleElement","wysiwygElement","changeStyle","editingElement","font","textAlign","color","strokeColor","opacity","getContext","normalizedCanvasWidth","normalizedCanvasHeight","viewBackgroundColor","hasTransparence","clearRect","fillStyle","zoomTranslationX","zoom","zoomTranslationY","visibleElements","filter","element","isVisibleElement","forEach","scrollX","scrollY","selections","acc","selectionColors","selectedElementIds","id","push","black","remoteSelectedElementIds","map","socketId","elementX1","elementY1","elementX2","elementY2","elementWidth","elementHeight","initialLineDash","getLineDash","lineWidth","lineDashOffset","strokeStyle","dashedLinePadding","dashWidth","spaceWidth","count","i","setLineDash","locallySelectedElements","white","handlers","Object","keys","key","handler","undefined","type","x1","y1","x2","y2","remotePointerViewportCoords","username","remotePointerUsernames","isOutOfBounds","max","min","globalAlpha","remotePointerButton","closePath","moveTo","lineTo","offsetX","offsetY","paddingHorizontal","paddingVertical","measure","measureText","measureHeight","actualBoundingBoxDescent","actualBoundingBoxAscent","fillText","scrollBars","horizontal","vertical","scrollBar","viewportWidth","viewportHeight","viewportWidthWithZoom","viewportHeightWithZoom","viewportWidthDiff","viewportHeightDiff","renderSceneToSvg","rsvg","svgRoot","isDeleted"],"mappings":"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","sourcesContent":["import { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport oc from \"open-color\";\n\nimport { FlooredNumber, AppState } from \"../types\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport {\n  getElementAbsoluteCoords,\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  handlerRectanglesFromCoords,\n  handlerRectangles,\n  getCommonBounds,\n  canResizeMutlipleElements,\n  isTextElement,\n} from \"../element\";\n\nimport { roundRect } from \"./roundRect\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  getScrollBars,\n  SCROLLBAR_COLOR,\n  SCROLLBAR_WIDTH,\n} from \"../scene/scrollbars\";\nimport { getSelectedElements } from \"../scene/selection\";\n\nimport { renderElement, renderElementToSvg } from \"./renderElement\";\nimport colors from \"../colors\";\n\ntype HandlerRectanglesRet = keyof ReturnType<typeof handlerRectangles>;\n\nfunction colorsForClientId(clientId: string) {\n  // Naive way of getting an integer out of the clientId\n  const sum = clientId.split(\"\").reduce((a, str) => a + str.charCodeAt(0), 0);\n\n  // Skip transparent background.\n  const backgrounds = colors.elementBackground.slice(1);\n  const strokes = colors.elementStroke.slice(1);\n  return {\n    background: backgrounds[sum % backgrounds.length],\n    stroke: strokes[sum % strokes.length],\n  };\n}\n\nfunction strokeRectWithRotation(\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n  fill?: boolean,\n) {\n  context.translate(cx, cy);\n  context.rotate(angle);\n  if (fill) {\n    context.fillRect(x - cx, y - cy, width, height);\n  }\n  context.strokeRect(x - cx, y - cy, width, height);\n  context.rotate(-angle);\n  context.translate(-cx, -cy);\n}\n\nfunction strokeCircle(\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) {\n  context.beginPath();\n  context.arc(x + width / 2, y + height / 2, width / 2, 0, Math.PI * 2);\n  context.fill();\n  context.stroke();\n}\n\nexport function renderScene(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  selectionElement: NonDeletedExcalidrawElement | null,\n  scale: number,\n  rc: RoughCanvas,\n  canvas: HTMLCanvasElement,\n  sceneState: SceneState,\n  // extra options, currently passed by export helper\n  {\n    renderScrollbars = true,\n    renderSelection = true,\n    // Whether to employ render optimizations to improve performance.\n    // Should not be turned on for export operations and similar, because it\n    //  doesn't guarantee pixel-perfect output.\n    renderOptimizations = false,\n  }: {\n    renderScrollbars?: boolean;\n    renderSelection?: boolean;\n    renderOptimizations?: boolean;\n  } = {},\n) {\n  if (!canvas) {\n    return { atLeastOneVisibleElement: false };\n  }\n\n  if (\n    appState.wysiwygElement?.changeStyle &&\n    isTextElement(appState.editingElement)\n  ) {\n    appState.wysiwygElement.changeStyle({\n      font: appState.editingElement.font,\n      textAlign: appState.editingElement.textAlign,\n      color: appState.editingElement.strokeColor,\n      opacity: appState.editingElement.opacity,\n    });\n  }\n\n  const context = canvas.getContext(\"2d\")!;\n  context.scale(scale, scale);\n\n  // When doing calculations based on canvas width we should used normalized one\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  // Paint background\n  if (typeof sceneState.viewBackgroundColor === \"string\") {\n    const hasTransparence =\n      sceneState.viewBackgroundColor === \"transparent\" ||\n      sceneState.viewBackgroundColor.length === 5 ||\n      sceneState.viewBackgroundColor.length === 9;\n    if (hasTransparence) {\n      context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    }\n    const fillStyle = context.fillStyle;\n    context.fillStyle = sceneState.viewBackgroundColor;\n    context.fillRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n    context.fillStyle = fillStyle;\n  } else {\n    context.clearRect(0, 0, normalizedCanvasWidth, normalizedCanvasHeight);\n  }\n\n  // Apply zoom\n  const zoomTranslationX = (-normalizedCanvasWidth * (sceneState.zoom - 1)) / 2;\n  const zoomTranslationY =\n    (-normalizedCanvasHeight * (sceneState.zoom - 1)) / 2;\n  context.translate(zoomTranslationX, zoomTranslationY);\n  context.scale(sceneState.zoom, sceneState.zoom);\n\n  // Paint visible elements\n  const visibleElements = elements.filter((element) =>\n    isVisibleElement(\n      element,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    ),\n  );\n\n  visibleElements.forEach((element) => {\n    renderElement(element, rc, context, renderOptimizations, sceneState);\n  });\n\n  // Pain selection element\n  if (selectionElement) {\n    renderElement(\n      selectionElement,\n      rc,\n      context,\n      renderOptimizations,\n      sceneState,\n    );\n  }\n\n  // Paint selected elements\n  if (renderSelection) {\n    context.translate(sceneState.scrollX, sceneState.scrollY);\n\n    const selections = elements.reduce((acc, element) => {\n      const selectionColors = [];\n      // local user\n      if (appState.selectedElementIds[element.id]) {\n        selectionColors.push(oc.black);\n      }\n      // remote users\n      if (sceneState.remoteSelectedElementIds[element.id]) {\n        selectionColors.push(\n          ...sceneState.remoteSelectedElementIds[element.id].map((socketId) => {\n            const { background } = colorsForClientId(socketId);\n            return background;\n          }),\n        );\n      }\n      if (selectionColors.length) {\n        acc.push({ element, selectionColors });\n      }\n      return acc;\n    }, [] as { element: ExcalidrawElement; selectionColors: string[] }[]);\n\n    selections.forEach(({ element, selectionColors }) => {\n      const [\n        elementX1,\n        elementY1,\n        elementX2,\n        elementY2,\n      ] = getElementAbsoluteCoords(element);\n\n      const elementWidth = elementX2 - elementX1;\n      const elementHeight = elementY2 - elementY1;\n\n      const initialLineDash = context.getLineDash();\n      const lineWidth = context.lineWidth;\n      const lineDashOffset = context.lineDashOffset;\n      const strokeStyle = context.strokeStyle;\n\n      const dashedLinePadding = 4 / sceneState.zoom;\n      const dashWidth = 8 / sceneState.zoom;\n      const spaceWidth = 4 / sceneState.zoom;\n\n      context.lineWidth = 1 / sceneState.zoom;\n\n      const count = selectionColors.length;\n      for (var i = 0; i < count; ++i) {\n        context.strokeStyle = selectionColors[i];\n        context.setLineDash([\n          dashWidth,\n          spaceWidth + (dashWidth + spaceWidth) * (count - 1),\n        ]);\n        context.lineDashOffset = (dashWidth + spaceWidth) * i;\n        strokeRectWithRotation(\n          context,\n          elementX1 - dashedLinePadding,\n          elementY1 - dashedLinePadding,\n          elementWidth + dashedLinePadding * 2,\n          elementHeight + dashedLinePadding * 2,\n          elementX1 + elementWidth / 2,\n          elementY1 + elementHeight / 2,\n          element.angle,\n        );\n      }\n      context.lineDashOffset = lineDashOffset;\n      context.strokeStyle = strokeStyle;\n      context.lineWidth = lineWidth;\n      context.setLineDash(initialLineDash);\n    });\n    context.translate(-sceneState.scrollX, -sceneState.scrollY);\n\n    const locallySelectedElements = getSelectedElements(elements, appState);\n\n    // Paint resize handlers\n    if (locallySelectedElements.length === 1) {\n      context.translate(sceneState.scrollX, sceneState.scrollY);\n      context.fillStyle = oc.white;\n      const handlers = handlerRectangles(\n        locallySelectedElements[0],\n        sceneState.zoom,\n      );\n      Object.keys(handlers).forEach((key) => {\n        const handler = handlers[key as HandlerRectanglesRet];\n        if (handler !== undefined) {\n          const lineWidth = context.lineWidth;\n          context.lineWidth = 1 / sceneState.zoom;\n          if (key === \"rotation\") {\n            strokeCircle(\n              context,\n              handler[0],\n              handler[1],\n              handler[2],\n              handler[3],\n            );\n          } else if (locallySelectedElements[0].type !== \"text\") {\n            strokeRectWithRotation(\n              context,\n              handler[0],\n              handler[1],\n              handler[2],\n              handler[3],\n              handler[0] + handler[2] / 2,\n              handler[1] + handler[3] / 2,\n              locallySelectedElements[0].angle,\n              true, // fill before stroke\n            );\n          }\n          context.lineWidth = lineWidth;\n        }\n      });\n      context.translate(-sceneState.scrollX, -sceneState.scrollY);\n    } else if (locallySelectedElements.length > 1) {\n      if (canResizeMutlipleElements(locallySelectedElements)) {\n        const dashedLinePadding = 4 / sceneState.zoom;\n        context.translate(sceneState.scrollX, sceneState.scrollY);\n        context.fillStyle = oc.white;\n        const [x1, y1, x2, y2] = getCommonBounds(locallySelectedElements);\n        const initialLineDash = context.getLineDash();\n        context.setLineDash([2 / sceneState.zoom]);\n        const lineWidth = context.lineWidth;\n        context.lineWidth = 1 / sceneState.zoom;\n        strokeRectWithRotation(\n          context,\n          x1 - dashedLinePadding,\n          y1 - dashedLinePadding,\n          x2 - x1 + dashedLinePadding * 2,\n          y2 - y1 + dashedLinePadding * 2,\n          (x1 + x2) / 2,\n          (y1 + y2) / 2,\n          0,\n        );\n        context.lineWidth = lineWidth;\n        context.setLineDash(initialLineDash);\n        const handlers = handlerRectanglesFromCoords(\n          [x1, y1, x2, y2],\n          0,\n          sceneState.zoom,\n          undefined,\n          OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n        );\n        Object.keys(handlers).forEach((key) => {\n          const handler = handlers[key as HandlerRectanglesRet];\n          if (handler !== undefined) {\n            const lineWidth = context.lineWidth;\n            context.lineWidth = 1 / sceneState.zoom;\n            strokeRectWithRotation(\n              context,\n              handler[0],\n              handler[1],\n              handler[2],\n              handler[3],\n              handler[0] + handler[2] / 2,\n              handler[1] + handler[3] / 2,\n              0,\n              true, // fill before stroke\n            );\n            context.lineWidth = lineWidth;\n          }\n        });\n        context.translate(-sceneState.scrollX, -sceneState.scrollY);\n      }\n    }\n  }\n\n  // Reset zoom\n  context.scale(1 / sceneState.zoom, 1 / sceneState.zoom);\n  context.translate(-zoomTranslationX, -zoomTranslationY);\n\n  // Paint remote pointers\n  for (const clientId in sceneState.remotePointerViewportCoords) {\n    let { x, y } = sceneState.remotePointerViewportCoords[clientId];\n    const username = sceneState.remotePointerUsernames[clientId];\n\n    const width = 9;\n    const height = 14;\n\n    const isOutOfBounds =\n      x < 0 ||\n      x > normalizedCanvasWidth - width ||\n      y < 0 ||\n      y > normalizedCanvasHeight - height;\n\n    x = Math.max(x, 0);\n    x = Math.min(x, normalizedCanvasWidth - width);\n    y = Math.max(y, 0);\n    y = Math.min(y, normalizedCanvasHeight - height);\n\n    const { background, stroke } = colorsForClientId(clientId);\n\n    const strokeStyle = context.strokeStyle;\n    const fillStyle = context.fillStyle;\n    const globalAlpha = context.globalAlpha;\n    context.strokeStyle = stroke;\n    context.fillStyle = background;\n    if (isOutOfBounds) {\n      context.globalAlpha = 0.2;\n    }\n\n    if (\n      sceneState.remotePointerButton &&\n      sceneState.remotePointerButton[clientId] === \"down\"\n    ) {\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 3;\n      context.strokeStyle = \"#ffffff88\";\n      context.stroke();\n      context.closePath();\n\n      context.beginPath();\n      context.arc(x, y, 15, 0, 2 * Math.PI, false);\n      context.lineWidth = 1;\n      context.strokeStyle = stroke;\n      context.stroke();\n      context.closePath();\n    }\n\n    context.beginPath();\n    context.moveTo(x, y);\n    context.lineTo(x + 1, y + 14);\n    context.lineTo(x + 4, y + 9);\n    context.lineTo(x + 9, y + 10);\n    context.lineTo(x, y);\n    context.fill();\n    context.stroke();\n\n    if (!isOutOfBounds && username) {\n      const offsetX = x + width;\n      const offsetY = y + height;\n      const paddingHorizontal = 4;\n      const paddingVertical = 4;\n      const measure = context.measureText(username);\n      const measureHeight =\n        measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;\n\n      // Border\n      context.fillStyle = stroke;\n      context.globalAlpha = globalAlpha;\n      context.fillRect(\n        offsetX - 1,\n        offsetY - 1,\n        measure.width + 2 * paddingHorizontal + 2,\n        measureHeight + 2 * paddingVertical + 2,\n      );\n      // Background\n      context.fillStyle = background;\n      context.fillRect(\n        offsetX,\n        offsetY,\n        measure.width + 2 * paddingHorizontal,\n        measureHeight + 2 * paddingVertical,\n      );\n      context.fillStyle = oc.white;\n      context.fillText(\n        username,\n        offsetX + paddingHorizontal,\n        offsetY + paddingVertical + measure.actualBoundingBoxAscent,\n      );\n    }\n\n    context.strokeStyle = strokeStyle;\n    context.fillStyle = fillStyle;\n    context.globalAlpha = globalAlpha;\n    context.closePath();\n  }\n\n  // Paint scrollbars\n  let scrollBars;\n  if (renderScrollbars) {\n    scrollBars = getScrollBars(\n      elements,\n      normalizedCanvasWidth,\n      normalizedCanvasHeight,\n      sceneState,\n    );\n\n    const fillStyle = context.fillStyle;\n    const strokeStyle = context.strokeStyle;\n    context.fillStyle = SCROLLBAR_COLOR;\n    context.strokeStyle = \"rgba(255,255,255,0.8)\";\n    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {\n      if (scrollBar) {\n        roundRect(\n          context,\n          scrollBar.x,\n          scrollBar.y,\n          scrollBar.width,\n          scrollBar.height,\n          SCROLLBAR_WIDTH / 2,\n        );\n      }\n    });\n    context.fillStyle = fillStyle;\n    context.strokeStyle = strokeStyle;\n  }\n\n  context.scale(1 / scale, 1 / scale);\n\n  return { atLeastOneVisibleElement: visibleElements.length > 0, scrollBars };\n}\n\nfunction isVisibleElement(\n  element: ExcalidrawElement,\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: FlooredNumber;\n    scrollY: FlooredNumber;\n    zoom: number;\n  },\n) {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom;\n  const viewportHeightWithZoom = viewportHeight / zoom;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  return (\n    x2 + scrollX - viewportWidthDiff / 2 >= 0 &&\n    x1 + scrollX - viewportWidthDiff / 2 <= viewportWidthWithZoom &&\n    y2 + scrollY - viewportHeightDiff / 2 >= 0 &&\n    y1 + scrollY - viewportHeightDiff / 2 <= viewportHeightWithZoom\n  );\n}\n\n// This should be only called for exporting purposes\nexport function renderSceneToSvg(\n  elements: readonly NonDeletedExcalidrawElement[],\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  {\n    offsetX = 0,\n    offsetY = 0,\n  }: {\n    offsetX?: number;\n    offsetY?: number;\n  } = {},\n) {\n  if (!svgRoot) {\n    return;\n  }\n  // render elements\n  elements.forEach((element) => {\n    if (!element.isDeleted) {\n      renderElementToSvg(\n        element,\n        rsvg,\n        svgRoot,\n        element.x + offsetX,\n        element.y + offsetY,\n      );\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}