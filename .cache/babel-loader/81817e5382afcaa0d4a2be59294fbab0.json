{"ast":null,"code":"import { getDefaultAppState } from \"../appState\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\nimport { fileSave } from \"browser-nativefs\";\nimport { t } from \"../i18n\";\nimport { copyCanvasToClipboardAsPng, copyCanvasToClipboardAsSvg } from \"../clipboard\";\nimport { serializeAsJSON } from \"./json\";\nimport { restore } from \"./restore\";\nimport { restoreFromLocalStorage } from \"./localStorage\";\nexport { loadFromBlob } from \"./blob\";\nexport { saveAsJSON, loadFromJSON } from \"./json\";\nexport { saveToLocalStorage } from \"./localStorage\";\nconst BACKEND_GET = \"https://json.excalidraw.com/api/v1/\";\nconst BACKEND_V2_POST = \"https://json.excalidraw.com/api/v2/post/\";\nconst BACKEND_V2_GET = \"https://json.excalidraw.com/api/v2/\";\nexport const SOCKET_SERVER = \"https://excalidraw-socket.herokuapp.com\";\n// TODO: Defined globally, since file handles aren't yet serializable.\n// Once `FileSystemFileHandle` can be serialized, make this\n// part of `AppState`.\nwindow.handle = null;\n\nfunction byteToHex(byte) {\n  return `0${byte.toString(16)}`.slice(-2);\n}\n\nasync function generateRandomID() {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n}\n\nasync function generateEncryptionKey() {\n  const key = await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: 128\n  }, true, // extractable\n  [\"encrypt\", \"decrypt\"]);\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n}\n\nfunction createIV() {\n  const arr = new Uint8Array(12);\n  return window.crypto.getRandomValues(arr);\n}\n\nexport function getCollaborationLinkData(link) {\n  if (link.length === 0) {\n    return;\n  }\n\n  const hash = new URL(link).hash;\n  return hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n}\nexport async function generateCollaborationLink() {\n  const id = await generateRandomID();\n  const key = await generateEncryptionKey();\n  return `${window.location.origin}${window.location.pathname}#room=${id},${key}`;\n}\n\nasync function getImportedKey(key, usage) {\n  return await window.crypto.subtle.importKey(\"jwk\", {\n    alg: \"A128GCM\",\n    ext: true,\n    k: key,\n    key_ops: [\"encrypt\", \"decrypt\"],\n    kty: \"oct\"\n  }, {\n    name: \"AES-GCM\",\n    length: 128\n  }, false, // extractable\n  [usage]);\n}\n\nexport async function encryptAESGEM(data, key) {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt({\n      name: \"AES-GCM\",\n      iv\n    }, importedKey, data),\n    iv\n  };\n}\nexport async function decryptAESGEM(data, key, iv) {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt({\n      name: \"AES-GCM\",\n      iv: iv\n    }, importedKey, data);\n    const decodedData = new TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n\n  return {\n    type: \"INVALID_RESPONSE\"\n  };\n}\nexport async function exportToBackend(elements, appState) {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n  const key = await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: 128\n  }, true, // extractable\n  [\"encrypt\", \"decrypt\"]); // The iv is set to 0. We are never going to reuse the same key so we don't\n  // need to have an iv. (I hope that's correct...)\n\n  const iv = new Uint8Array(12); // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n\n  const encrypted = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv: iv\n  }, key, encoded); // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: encrypted\n    });\n    const json = await response.json();\n\n    if (json.id) {\n      const url = new URL(window.location.href); // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n\n      url.hash = `json=${json.id},${exportedKey.k}`;\n      const urlString = url.toString();\n      window.prompt(`ðŸ”’${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n}\nexport async function importFromBackend(id, privateKey) {\n  let elements = [];\n  let appState = getDefaultAppState();\n\n  try {\n    const response = await fetch(privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`);\n\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return restore(elements, appState, {\n        scrollToContent: true\n      });\n    }\n\n    let data;\n\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n      const key = await getImportedKey(privateKey, \"decrypt\");\n      const iv = new Uint8Array(12);\n      const decrypted = await window.crypto.subtle.decrypt({\n        name: \"AES-GCM\",\n        iv: iv\n      }, key, buffer); // We need to convert the decrypted array buffer to a string\n\n      const string = new window.TextDecoder(\"utf-8\").decode(new Uint8Array(decrypted));\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    elements = data.elements || elements;\n    appState = data.appState || appState;\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n  } finally {\n    return restore(elements, appState, {\n      scrollToContent: true\n    });\n  }\n}\nexport async function exportCanvas(type, elements, appState, canvas, {\n  exportBackground,\n  exportPadding = 10,\n  viewBackgroundColor,\n  name,\n  scale = 1\n}) {\n  if (elements.length === 0) {\n    return window.alert(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const tempSvg = exportToSvg(elements, {\n      exportBackground,\n      viewBackgroundColor,\n      exportPadding\n    });\n\n    if (type === \"svg\") {\n      await fileSave(new Blob([tempSvg.outerHTML], {\n        type: \"image/svg+xml\"\n      }), {\n        fileName: `${name}.svg`\n      });\n      return;\n    } else if (type === \"clipboard-svg\") {\n      copyCanvasToClipboardAsSvg(tempSvg);\n      return;\n    }\n  }\n\n  const tempCanvas = exportToCanvas(elements, appState, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n    scale\n  });\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n\n  if (type === \"png\") {\n    const fileName = `${name}.png`;\n    tempCanvas.toBlob(async blob => {\n      if (blob) {\n        await fileSave(blob, {\n          fileName: fileName\n        });\n      }\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      copyCanvasToClipboardAsPng(tempCanvas);\n    } catch {\n      window.alert(t(\"alerts.couldNotCopyToClipboard\"));\n    }\n  } else if (type === \"backend\") {\n    const appState = getDefaultAppState();\n\n    if (exportBackground) {\n      appState.viewBackgroundColor = viewBackgroundColor;\n    }\n\n    exportToBackend(elements, appState);\n  } // clean up the DOM\n\n\n  if (tempCanvas !== canvas) {\n    tempCanvas.remove();\n  }\n}\nexport async function loadScene(id, privateKey) {\n  let data;\n\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = await importFromBackend(id, privateKey);\n    window.history.replaceState({}, \"Excalidraw\", window.location.origin);\n  } else {\n    data = restoreFromLocalStorage();\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState && { ...data.appState\n    },\n    commitToHistory: false\n  };\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/data/index.ts"],"names":["getDefaultAppState","exportToCanvas","exportToSvg","fileSave","t","copyCanvasToClipboardAsPng","copyCanvasToClipboardAsSvg","serializeAsJSON","restore","restoreFromLocalStorage","loadFromBlob","saveAsJSON","loadFromJSON","saveToLocalStorage","BACKEND_GET","BACKEND_V2_POST","BACKEND_V2_GET","SOCKET_SERVER","window","handle","byteToHex","byte","toString","slice","generateRandomID","arr","Uint8Array","crypto","getRandomValues","Array","from","join","generateEncryptionKey","key","subtle","generateKey","name","length","exportKey","k","createIV","getCollaborationLinkData","link","hash","URL","match","generateCollaborationLink","id","location","origin","pathname","getImportedKey","usage","importKey","alg","ext","key_ops","kty","encryptAESGEM","data","importedKey","iv","encrypt","decryptAESGEM","decrypted","decrypt","decodedData","TextDecoder","decode","JSON","parse","error","alert","console","type","exportToBackend","elements","appState","json","encoded","TextEncoder","encode","encrypted","exportedKey","response","fetch","method","body","url","href","urlString","prompt","importFromBackend","privateKey","ok","scrollToContent","buffer","arrayBuffer","string","exportCanvas","canvas","exportBackground","exportPadding","viewBackgroundColor","scale","tempSvg","Blob","outerHTML","fileName","tempCanvas","style","display","document","appendChild","toBlob","blob","remove","loadScene","history","replaceState","commitToHistory"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getDefaultAppState } from \"../appState\";\n\nimport { AppState } from \"../types\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\nimport { fileSave } from \"browser-nativefs\";\n\nimport { t } from \"../i18n\";\nimport {\n  copyCanvasToClipboardAsPng,\n  copyCanvasToClipboardAsSvg,\n} from \"../clipboard\";\nimport { serializeAsJSON } from \"./json\";\n\nimport { ExportType } from \"../scene/types\";\nimport { restore } from \"./restore\";\nimport { restoreFromLocalStorage } from \"./localStorage\";\n\nexport { loadFromBlob } from \"./blob\";\nexport { saveAsJSON, loadFromJSON } from \"./json\";\nexport { saveToLocalStorage } from \"./localStorage\";\n\nconst BACKEND_GET = \"https://json.excalidraw.com/api/v1/\";\n\nconst BACKEND_V2_POST = \"https://json.excalidraw.com/api/v2/post/\";\nconst BACKEND_V2_GET = \"https://json.excalidraw.com/api/v2/\";\n\nexport const SOCKET_SERVER = \"https://excalidraw-socket.herokuapp.com\";\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketID: string;\n      pointerCoords: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\n// TODO: Defined globally, since file handles aren't yet serializable.\n// Once `FileSystemFileHandle` can be serialized, make this\n// part of `AppState`.\n(window as any).handle = null;\n\nfunction byteToHex(byte: number): string {\n  return `0${byte.toString(16)}`.slice(-2);\n}\n\nasync function generateRandomID() {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n}\n\nasync function generateEncryptionKey() {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n}\n\nfunction createIV() {\n  const arr = new Uint8Array(12);\n  return window.crypto.getRandomValues(arr);\n}\n\nexport function getCollaborationLinkData(link: string) {\n  if (link.length === 0) {\n    return;\n  }\n  const hash = new URL(link).hash;\n  return hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n}\n\nexport async function generateCollaborationLink() {\n  const id = await generateRandomID();\n  const key = await generateEncryptionKey();\n  return `${window.location.origin}${window.location.pathname}#room=${id},${key}`;\n}\n\nasync function getImportedKey(key: string, usage: string): Promise<CryptoKey> {\n  return await window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n}\n\nexport async function encryptAESGEM(\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n}\n\nexport async function decryptAESGEM(\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted) as any,\n    );\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n}\n\nexport async function exportToBackend(\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  // The iv is set to 0. We are never going to reuse the same key so we don't\n  // need to have an iv. (I hope that's correct...)\n  const iv = new Uint8Array(12);\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    key,\n    encoded,\n  );\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: encrypted,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${exportedKey.k!}`;\n      const urlString = url.toString();\n\n      window.prompt(`ðŸ”’${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n}\n\nexport async function importFromBackend(\n  id: string | null,\n  privateKey: string | undefined,\n) {\n  let elements: readonly ExcalidrawElement[] = [];\n  let appState: AppState = getDefaultAppState();\n\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return restore(elements, appState, { scrollToContent: true });\n    }\n    let data;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n      const key = await getImportedKey(privateKey, \"decrypt\");\n      const iv = new Uint8Array(12);\n      const decrypted = await window.crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv: iv,\n        },\n        key,\n        buffer,\n      );\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    elements = data.elements || elements;\n    appState = data.appState || appState;\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n  } finally {\n    return restore(elements, appState, { scrollToContent: true });\n  }\n}\n\nexport async function exportCanvas(\n  type: ExportType,\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    name,\n    scale = 1,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    name: string;\n    scale?: number;\n  },\n) {\n  if (elements.length === 0) {\n    return window.alert(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const tempSvg = exportToSvg(elements, {\n      exportBackground,\n      viewBackgroundColor,\n      exportPadding,\n    });\n    if (type === \"svg\") {\n      await fileSave(new Blob([tempSvg.outerHTML], { type: \"image/svg+xml\" }), {\n        fileName: `${name}.svg`,\n      });\n      return;\n    } else if (type === \"clipboard-svg\") {\n      copyCanvasToClipboardAsSvg(tempSvg);\n      return;\n    }\n  }\n\n  const tempCanvas = exportToCanvas(elements, appState, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n    scale,\n  });\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n\n  if (type === \"png\") {\n    const fileName = `${name}.png`;\n    tempCanvas.toBlob(async (blob: any) => {\n      if (blob) {\n        await fileSave(blob, {\n          fileName: fileName,\n        });\n      }\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      copyCanvasToClipboardAsPng(tempCanvas);\n    } catch {\n      window.alert(t(\"alerts.couldNotCopyToClipboard\"));\n    }\n  } else if (type === \"backend\") {\n    const appState = getDefaultAppState();\n    if (exportBackground) {\n      appState.viewBackgroundColor = viewBackgroundColor;\n    }\n    exportToBackend(elements, appState);\n  }\n\n  // clean up the DOM\n  if (tempCanvas !== canvas) {\n    tempCanvas.remove();\n  }\n}\n\nexport async function loadScene(id: string | null, privateKey?: string) {\n  let data;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = await importFromBackend(id, privateKey);\n    window.history.replaceState({}, \"Excalidraw\", window.location.origin);\n  } else {\n    data = restoreFromLocalStorage();\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState && { ...data.appState },\n    commitToHistory: false,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}