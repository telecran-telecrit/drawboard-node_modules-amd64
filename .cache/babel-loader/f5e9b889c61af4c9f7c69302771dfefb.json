{"ast":null,"code":"(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('stacktrace', ['error-stack-parser', 'stack-generator', 'stacktrace-gps'], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n  } else {\n    root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n  }\n})(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n  var _options = {\n    filter: function filter(stackframe) {\n      // Filter out stackframes for this library by default\n      return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 && (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 && (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 && (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n    },\n    sourceCache: {}\n  };\n\n  var _generateError = function StackTrace$$GenerateError() {\n    try {\n      // Error must be thrown to get stack in IE\n      throw new Error();\n    } catch (err) {\n      return err;\n    }\n  };\n  /**\n   * Merge 2 given Objects. If a conflict occurs the second object wins.\n   * Does not do deep merges.\n   *\n   * @param {Object} first base object\n   * @param {Object} second overrides\n   * @returns {Object} merged first and second\n   * @private\n   */\n\n\n  function _merge(first, second) {\n    var target = {};\n    [first, second].forEach(function (obj) {\n      for (var prop in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n          target[prop] = obj[prop];\n        }\n      }\n\n      return target;\n    });\n    return target;\n  }\n\n  function _isShapedLikeParsableError(err) {\n    return err.stack || err['opera#sourceloc'];\n  }\n\n  function _filtered(stackframes, filter) {\n    if (typeof filter === 'function') {\n      return stackframes.filter(filter);\n    }\n\n    return stackframes;\n  }\n\n  return {\n    /**\n     * Get a backtrace from invocation point.\n     *\n     * @param {Object} opts\n     * @returns {Array} of StackFrame\n     */\n    get: function StackTrace$$get(opts) {\n      var err = _generateError();\n\n      return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n    },\n\n    /**\n     * Get a backtrace from invocation point.\n     * IMPORTANT: Does not handle source maps or guess function names!\n     *\n     * @param {Object} opts\n     * @returns {Array} of StackFrame\n     */\n    getSync: function StackTrace$$getSync(opts) {\n      opts = _merge(_options, opts);\n\n      var err = _generateError();\n\n      var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n      return _filtered(stack, opts.filter);\n    },\n\n    /**\n     * Given an error object, parse it.\n     *\n     * @param {Error} error object\n     * @param {Object} opts\n     * @returns {Promise} for Array[StackFrame}\n     */\n    fromError: function StackTrace$$fromError(error, opts) {\n      opts = _merge(_options, opts);\n      var gps = new StackTraceGPS(opts);\n      return new Promise(function (resolve) {\n        var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n\n        resolve(Promise.all(stackframes.map(function (sf) {\n          return new Promise(function (resolve) {\n            function resolveOriginal() {\n              resolve(sf);\n            }\n\n            gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n          });\n        })));\n      }.bind(this));\n    },\n\n    /**\n     * Use StackGenerator to generate a backtrace.\n     *\n     * @param {Object} opts\n     * @returns {Promise} of Array[StackFrame]\n     */\n    generateArtificially: function StackTrace$$generateArtificially(opts) {\n      opts = _merge(_options, opts);\n      var stackFrames = StackGenerator.backtrace(opts);\n\n      if (typeof opts.filter === 'function') {\n        stackFrames = stackFrames.filter(opts.filter);\n      }\n\n      return Promise.resolve(stackFrames);\n    },\n\n    /**\n     * Given a function, wrap it such that invocations trigger a callback that\n     * is called with a stack trace.\n     *\n     * @param {Function} fn to be instrumented\n     * @param {Function} callback function to call with a stack trace on invocation\n     * @param {Function} errback optional function to call with error if unable to get stack trace.\n     * @param {Object} thisArg optional context object (e.g. window)\n     */\n    instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n      if (typeof fn !== 'function') {\n        throw new Error('Cannot instrument non-function object');\n      } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n        // Already instrumented, return given Function\n        return fn;\n      }\n\n      var instrumented = function StackTrace$$instrumented() {\n        try {\n          this.get().then(callback, errback)['catch'](errback);\n          return fn.apply(thisArg || this, arguments);\n        } catch (e) {\n          if (_isShapedLikeParsableError(e)) {\n            this.fromError(e).then(callback, errback)['catch'](errback);\n          }\n\n          throw e;\n        }\n      }.bind(this);\n\n      instrumented.__stacktraceOriginalFn = fn;\n      return instrumented;\n    },\n\n    /**\n     * Given a function that has been instrumented,\n     * revert the function to it's original (non-instrumented) state.\n     *\n     * @param {Function} fn to de-instrument\n     */\n    deinstrument: function StackTrace$$deinstrument(fn) {\n      if (typeof fn !== 'function') {\n        throw new Error('Cannot de-instrument non-function object');\n      } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n        return fn.__stacktraceOriginalFn;\n      } else {\n        // Function not instrumented, return original\n        return fn;\n      }\n    },\n\n    /**\n     * Given an error message and Array of StackFrames, serialize and POST to given URL.\n     *\n     * @param {Array} stackframes\n     * @param {String} url\n     * @param {String} errorMsg\n     * @param {Object} requestOptions\n     */\n    report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {\n      return new Promise(function (resolve, reject) {\n        var req = new XMLHttpRequest();\n        req.onerror = reject;\n\n        req.onreadystatechange = function onreadystatechange() {\n          if (req.readyState === 4) {\n            if (req.status >= 200 && req.status < 400) {\n              resolve(req.responseText);\n            } else {\n              reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n            }\n          }\n        };\n\n        req.open('post', url); // Set request headers\n\n        req.setRequestHeader('Content-Type', 'application/json');\n\n        if (requestOptions && typeof requestOptions.headers === 'object') {\n          var headers = requestOptions.headers;\n\n          for (var header in headers) {\n            if (Object.prototype.hasOwnProperty.call(headers, header)) {\n              req.setRequestHeader(header, headers[header]);\n            }\n          }\n        }\n\n        var reportPayload = {\n          stack: stackframes\n        };\n\n        if (errorMsg !== undefined && errorMsg !== null) {\n          reportPayload.message = errorMsg;\n        }\n\n        req.send(JSON.stringify(reportPayload));\n      });\n    }\n  };\n});","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/stacktrace-js/stacktrace.js"],"names":["root","factory","define","amd","exports","module","require","StackTrace","ErrorStackParser","StackGenerator","StackTraceGPS","_options","filter","stackframe","functionName","indexOf","sourceCache","_generateError","StackTrace$$GenerateError","Error","err","_merge","first","second","target","forEach","obj","prop","Object","prototype","hasOwnProperty","call","_isShapedLikeParsableError","stack","_filtered","stackframes","get","StackTrace$$get","opts","fromError","generateArtificially","getSync","StackTrace$$getSync","parse","backtrace","StackTrace$$fromError","error","gps","Promise","resolve","all","map","sf","resolveOriginal","pinpoint","then","bind","StackTrace$$generateArtificially","stackFrames","instrument","StackTrace$$instrument","fn","callback","errback","thisArg","__stacktraceOriginalFn","instrumented","StackTrace$$instrumented","apply","arguments","e","deinstrument","StackTrace$$deinstrument","report","StackTrace$$report","url","errorMsg","requestOptions","reject","req","XMLHttpRequest","onerror","onreadystatechange","readyState","status","responseText","open","setRequestHeader","headers","header","reportPayload","undefined","message","send","JSON","stringify"],"mappings":"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","sourcesContent":["(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stacktrace', ['error-stack-parser', 'stack-generator', 'stacktrace-gps'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('error-stack-parser'), require('stack-generator'), require('stacktrace-gps'));\n    } else {\n        root.StackTrace = factory(root.ErrorStackParser, root.StackGenerator, root.StackTraceGPS);\n    }\n}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {\n    var _options = {\n        filter: function(stackframe) {\n            // Filter out stackframes for this library by default\n            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&\n                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&\n                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;\n        },\n        sourceCache: {}\n    };\n\n    var _generateError = function StackTrace$$GenerateError() {\n        try {\n            // Error must be thrown to get stack in IE\n            throw new Error();\n        } catch (err) {\n            return err;\n        }\n    };\n\n    /**\n     * Merge 2 given Objects. If a conflict occurs the second object wins.\n     * Does not do deep merges.\n     *\n     * @param {Object} first base object\n     * @param {Object} second overrides\n     * @returns {Object} merged first and second\n     * @private\n     */\n    function _merge(first, second) {\n        var target = {};\n\n        [first, second].forEach(function(obj) {\n            for (var prop in obj) {\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                    target[prop] = obj[prop];\n                }\n            }\n            return target;\n        });\n\n        return target;\n    }\n\n    function _isShapedLikeParsableError(err) {\n        return err.stack || err['opera#sourceloc'];\n    }\n\n    function _filtered(stackframes, filter) {\n        if (typeof filter === 'function') {\n            return stackframes.filter(filter);\n        }\n        return stackframes;\n    }\n\n    return {\n        /**\n         * Get a backtrace from invocation point.\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        get: function StackTrace$$get(opts) {\n            var err = _generateError();\n            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);\n        },\n\n        /**\n         * Get a backtrace from invocation point.\n         * IMPORTANT: Does not handle source maps or guess function names!\n         *\n         * @param {Object} opts\n         * @returns {Array} of StackFrame\n         */\n        getSync: function StackTrace$$getSync(opts) {\n            opts = _merge(_options, opts);\n            var err = _generateError();\n            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);\n            return _filtered(stack, opts.filter);\n        },\n\n        /**\n         * Given an error object, parse it.\n         *\n         * @param {Error} error object\n         * @param {Object} opts\n         * @returns {Promise} for Array[StackFrame}\n         */\n        fromError: function StackTrace$$fromError(error, opts) {\n            opts = _merge(_options, opts);\n            var gps = new StackTraceGPS(opts);\n            return new Promise(function(resolve) {\n                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);\n                resolve(Promise.all(stackframes.map(function(sf) {\n                    return new Promise(function(resolve) {\n                        function resolveOriginal() {\n                            resolve(sf);\n                        }\n\n                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);\n                    });\n                })));\n            }.bind(this));\n        },\n\n        /**\n         * Use StackGenerator to generate a backtrace.\n         *\n         * @param {Object} opts\n         * @returns {Promise} of Array[StackFrame]\n         */\n        generateArtificially: function StackTrace$$generateArtificially(opts) {\n            opts = _merge(_options, opts);\n            var stackFrames = StackGenerator.backtrace(opts);\n            if (typeof opts.filter === 'function') {\n                stackFrames = stackFrames.filter(opts.filter);\n            }\n            return Promise.resolve(stackFrames);\n        },\n\n        /**\n         * Given a function, wrap it such that invocations trigger a callback that\n         * is called with a stack trace.\n         *\n         * @param {Function} fn to be instrumented\n         * @param {Function} callback function to call with a stack trace on invocation\n         * @param {Function} errback optional function to call with error if unable to get stack trace.\n         * @param {Object} thisArg optional context object (e.g. window)\n         */\n        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                // Already instrumented, return given Function\n                return fn;\n            }\n\n            var instrumented = function StackTrace$$instrumented() {\n                try {\n                    this.get().then(callback, errback)['catch'](errback);\n                    return fn.apply(thisArg || this, arguments);\n                } catch (e) {\n                    if (_isShapedLikeParsableError(e)) {\n                        this.fromError(e).then(callback, errback)['catch'](errback);\n                    }\n                    throw e;\n                }\n            }.bind(this);\n            instrumented.__stacktraceOriginalFn = fn;\n\n            return instrumented;\n        },\n\n        /**\n         * Given a function that has been instrumented,\n         * revert the function to it's original (non-instrumented) state.\n         *\n         * @param {Function} fn to de-instrument\n         */\n        deinstrument: function StackTrace$$deinstrument(fn) {\n            if (typeof fn !== 'function') {\n                throw new Error('Cannot de-instrument non-function object');\n            } else if (typeof fn.__stacktraceOriginalFn === 'function') {\n                return fn.__stacktraceOriginalFn;\n            } else {\n                // Function not instrumented, return original\n                return fn;\n            }\n        },\n\n        /**\n         * Given an error message and Array of StackFrames, serialize and POST to given URL.\n         *\n         * @param {Array} stackframes\n         * @param {String} url\n         * @param {String} errorMsg\n         * @param {Object} requestOptions\n         */\n        report: function StackTrace$$report(stackframes, url, errorMsg, requestOptions) {\n            return new Promise(function(resolve, reject) {\n                var req = new XMLHttpRequest();\n                req.onerror = reject;\n                req.onreadystatechange = function onreadystatechange() {\n                    if (req.readyState === 4) {\n                        if (req.status >= 200 && req.status < 400) {\n                            resolve(req.responseText);\n                        } else {\n                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));\n                        }\n                    }\n                };\n                req.open('post', url);\n\n                // Set request headers\n                req.setRequestHeader('Content-Type', 'application/json');\n                if (requestOptions && typeof requestOptions.headers === 'object') {\n                    var headers = requestOptions.headers;\n                    for (var header in headers) {\n                        if (Object.prototype.hasOwnProperty.call(headers, header)) {\n                            req.setRequestHeader(header, headers[header]);\n                        }\n                    }\n                }\n\n                var reportPayload = {stack: stackframes};\n                if (errorMsg !== undefined && errorMsg !== null) {\n                    reportPayload.message = errorMsg;\n                }\n\n                req.send(JSON.stringify(reportPayload));\n            });\n        }\n    };\n}));\n"]},"metadata":{},"sourceType":"script"}