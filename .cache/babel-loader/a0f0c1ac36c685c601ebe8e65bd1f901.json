{"ast":null,"code":"/** Deduplication filter */\nvar Dedupe =\n/** @class */\nfunction () {\n  function Dedupe() {\n    /**\n     * @inheritDoc\n     */\n    this.name = Dedupe.id;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  Dedupe.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {\n    addGlobalEventProcessor(function (currentEvent) {\n      var self = getCurrentHub().getIntegration(Dedupe);\n\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (self._shouldDropEvent(currentEvent, self._previousEvent)) {\n            return null;\n          }\n        } catch (_oO) {\n          return self._previousEvent = currentEvent;\n        }\n\n        return self._previousEvent = currentEvent;\n      }\n\n      return currentEvent;\n    });\n  };\n  /** JSDoc */\n\n\n  Dedupe.prototype._shouldDropEvent = function (currentEvent, previousEvent) {\n    if (!previousEvent) {\n      return false;\n    }\n\n    if (this._isSameMessageEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    if (this._isSameExceptionEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    return false;\n  };\n  /** JSDoc */\n\n\n  Dedupe.prototype._isSameMessageEvent = function (currentEvent, previousEvent) {\n    var currentMessage = currentEvent.message;\n    var previousMessage = previousEvent.message; // If neither event has a message property, they were both exceptions, so bail out\n\n    if (!currentMessage && !previousMessage) {\n      return false;\n    } // If only one event has a stacktrace, but not the other one, they are not the same\n\n\n    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {\n      return false;\n    }\n\n    if (currentMessage !== previousMessage) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  };\n  /** JSDoc */\n\n\n  Dedupe.prototype._getFramesFromEvent = function (event) {\n    var exception = event.exception;\n\n    if (exception) {\n      try {\n        // @ts-ignore\n        return exception.values[0].stacktrace.frames;\n      } catch (_oO) {\n        return undefined;\n      }\n    } else if (event.stacktrace) {\n      return event.stacktrace.frames;\n    }\n\n    return undefined;\n  };\n  /** JSDoc */\n\n\n  Dedupe.prototype._isSameStacktrace = function (currentEvent, previousEvent) {\n    var currentFrames = this._getFramesFromEvent(currentEvent);\n\n    var previousFrames = this._getFramesFromEvent(previousEvent); // If neither event has a stacktrace, they are assumed to be the same\n\n\n    if (!currentFrames && !previousFrames) {\n      return true;\n    } // If only one event has a stacktrace, but not the other one, they are not the same\n\n\n    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {\n      return false;\n    }\n\n    currentFrames = currentFrames;\n    previousFrames = previousFrames; // If number of frames differ, they are not the same\n\n    if (previousFrames.length !== currentFrames.length) {\n      return false;\n    } // Otherwise, compare the two\n\n\n    for (var i = 0; i < previousFrames.length; i++) {\n      var frameA = previousFrames[i];\n      var frameB = currentFrames[i];\n\n      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /** JSDoc */\n\n\n  Dedupe.prototype._getExceptionFromEvent = function (event) {\n    return event.exception && event.exception.values && event.exception.values[0];\n  };\n  /** JSDoc */\n\n\n  Dedupe.prototype._isSameExceptionEvent = function (currentEvent, previousEvent) {\n    var previousException = this._getExceptionFromEvent(previousEvent);\n\n    var currentException = this._getExceptionFromEvent(currentEvent);\n\n    if (!previousException || !currentException) {\n      return false;\n    }\n\n    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  };\n  /** JSDoc */\n\n\n  Dedupe.prototype._isSameFingerprint = function (currentEvent, previousEvent) {\n    var currentFingerprint = currentEvent.fingerprint;\n    var previousFingerprint = previousEvent.fingerprint; // If neither event has a fingerprint, they are assumed to be the same\n\n    if (!currentFingerprint && !previousFingerprint) {\n      return true;\n    } // If only one event has a fingerprint, but not the other one, they are not the same\n\n\n    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {\n      return false;\n    }\n\n    currentFingerprint = currentFingerprint;\n    previousFingerprint = previousFingerprint; // Otherwise, compare the two\n\n    try {\n      return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n    } catch (_oO) {\n      return false;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Dedupe.id = 'Dedupe';\n  return Dedupe;\n}();\n\nexport { Dedupe };","map":{"version":3,"sources":["../src/dedupe.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventProcessor, Exception, Hub, Integration, StackFrame } from '@sentry/types';\n\n/** Deduplication filter */\nexport class Dedupe implements Integration {\n  /**\n   * @inheritDoc\n   */\n  private _previousEvent?: Event;\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Dedupe.id;\n\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Dedupe';\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(addGlobalEventProcessor: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    addGlobalEventProcessor((currentEvent: Event) => {\n      const self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (self._shouldDropEvent(currentEvent, self._previousEvent)) {\n            return null;\n          }\n        } catch (_oO) {\n          return (self._previousEvent = currentEvent);\n        }\n\n        return (self._previousEvent = currentEvent);\n      }\n      return currentEvent;\n    });\n  }\n\n  /** JSDoc */\n  private _shouldDropEvent(currentEvent: Event, previousEvent?: Event): boolean {\n    if (!previousEvent) {\n      return false;\n    }\n\n    if (this._isSameMessageEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    if (this._isSameExceptionEvent(currentEvent, previousEvent)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /** JSDoc */\n  private _isSameMessageEvent(currentEvent: Event, previousEvent: Event): boolean {\n    const currentMessage = currentEvent.message;\n    const previousMessage = previousEvent.message;\n\n    // If neither event has a message property, they were both exceptions, so bail out\n    if (!currentMessage && !previousMessage) {\n      return false;\n    }\n\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n      return false;\n    }\n\n    if (currentMessage !== previousMessage) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _getFramesFromEvent(event: Event): StackFrame[] | undefined {\n    const exception = event.exception;\n\n    if (exception) {\n      try {\n        // @ts-ignore\n        return exception.values[0].stacktrace.frames;\n      } catch (_oO) {\n        return undefined;\n      }\n    } else if (event.stacktrace) {\n      return event.stacktrace.frames;\n    }\n    return undefined;\n  }\n\n  /** JSDoc */\n  private _isSameStacktrace(currentEvent: Event, previousEvent: Event): boolean {\n    let currentFrames = this._getFramesFromEvent(currentEvent);\n    let previousFrames = this._getFramesFromEvent(previousEvent);\n\n    // If neither event has a stacktrace, they are assumed to be the same\n    if (!currentFrames && !previousFrames) {\n      return true;\n    }\n\n    // If only one event has a stacktrace, but not the other one, they are not the same\n    if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n      return false;\n    }\n\n    currentFrames = currentFrames as StackFrame[];\n    previousFrames = previousFrames as StackFrame[];\n\n    // If number of frames differ, they are not the same\n    if (previousFrames.length !== currentFrames.length) {\n      return false;\n    }\n\n    // Otherwise, compare the two\n    for (let i = 0; i < previousFrames.length; i++) {\n      const frameA = previousFrames[i];\n      const frameB = currentFrames[i];\n\n      if (\n        frameA.filename !== frameB.filename ||\n        frameA.lineno !== frameB.lineno ||\n        frameA.colno !== frameB.colno ||\n        frameA.function !== frameB.function\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _getExceptionFromEvent(event: Event): Exception | undefined {\n    return event.exception && event.exception.values && event.exception.values[0];\n  }\n\n  /** JSDoc */\n  private _isSameExceptionEvent(currentEvent: Event, previousEvent: Event): boolean {\n    const previousException = this._getExceptionFromEvent(previousEvent);\n    const currentException = this._getExceptionFromEvent(currentEvent);\n\n    if (!previousException || !currentException) {\n      return false;\n    }\n\n    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n      return false;\n    }\n\n    if (!this._isSameFingerprint(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    if (!this._isSameStacktrace(currentEvent, previousEvent)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /** JSDoc */\n  private _isSameFingerprint(currentEvent: Event, previousEvent: Event): boolean {\n    let currentFingerprint = currentEvent.fingerprint;\n    let previousFingerprint = previousEvent.fingerprint;\n\n    // If neither event has a fingerprint, they are assumed to be the same\n    if (!currentFingerprint && !previousFingerprint) {\n      return true;\n    }\n\n    // If only one event has a fingerprint, but not the other one, they are not the same\n    if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n      return false;\n    }\n\n    currentFingerprint = currentFingerprint as string[];\n    previousFingerprint = previousFingerprint as string[];\n\n    // Otherwise, compare the two\n    try {\n      return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n    } catch (_oO) {\n      return false;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}