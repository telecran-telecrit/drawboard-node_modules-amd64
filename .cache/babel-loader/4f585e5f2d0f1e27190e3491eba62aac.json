{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n\nvar util = require('./util'); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\n\n\nvar REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\nvar NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\n\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\n\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\n\n\nSourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n  // The SourceNode we want to fill with the generated code\n  // and the SourceMap\n  var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n  // while all odd indices are the newlines between two adjacent lines\n  // (since `REGEX_NEWLINE` captures its match).\n  // Processed fragments are removed from this array, by calling `shiftNextLine`.\n\n  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n\n  var shiftNextLine = function shiftNextLine() {\n    var lineContents = remainingLines.shift(); // The last line of a file might not have a newline.\n\n    var newLine = remainingLines.shift() || \"\";\n    return lineContents + newLine;\n  }; // We need to remember the position of \"remainingLines\"\n\n\n  var lastGeneratedLine = 1,\n      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n  // To extract it current and last mapping is used.\n  // Here we store the last mapping.\n\n  var lastMapping = null;\n  aSourceMapConsumer.eachMapping(function (mapping) {\n    if (lastMapping !== null) {\n      // We add the code from \"lastMapping\" to \"mapping\":\n      // First check if there is a new line in between.\n      if (lastGeneratedLine < mapping.generatedLine) {\n        // Associate first line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n        lastGeneratedLine++;\n        lastGeneratedColumn = 0; // The remaining code is added without mapping\n      } else {\n        // There is no new line in between.\n        // Associate the code between \"lastGeneratedColumn\" and\n        // \"mapping.generatedColumn\" with \"lastMapping\"\n        var nextLine = remainingLines[0];\n        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n        addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n        lastMapping = mapping;\n        return;\n      }\n    } // We add the generated code until the first mapping\n    // to the SourceNode without any mapping.\n    // Each line is added as separate string.\n\n\n    while (lastGeneratedLine < mapping.generatedLine) {\n      node.add(shiftNextLine());\n      lastGeneratedLine++;\n    }\n\n    if (lastGeneratedColumn < mapping.generatedColumn) {\n      var nextLine = remainingLines[0];\n      node.add(nextLine.substr(0, mapping.generatedColumn));\n      remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n      lastGeneratedColumn = mapping.generatedColumn;\n    }\n\n    lastMapping = mapping;\n  }, this); // We have processed all mappings.\n\n  if (remainingLines.length > 0) {\n    if (lastMapping) {\n      // Associate the remaining code in the current line with \"lastMapping\"\n      addMappingWithCode(lastMapping, shiftNextLine());\n    } // and add the remaining lines without any mapping\n\n\n    node.add(remainingLines.join(\"\"));\n  } // Copy sourcesContent into SourceNode\n\n\n  aSourceMapConsumer.sources.forEach(function (sourceFile) {\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n    if (content != null) {\n      if (aRelativePath != null) {\n        sourceFile = util.join(aRelativePath, sourceFile);\n      }\n\n      node.setSourceContent(sourceFile, content);\n    }\n  });\n  return node;\n\n  function addMappingWithCode(mapping, code) {\n    if (mapping === null || mapping.source === undefined) {\n      node.add(code);\n    } else {\n      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n    }\n  }\n};\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\n\n\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n\n  return this;\n};\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\n\n\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length - 1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n\n  return this;\n};\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\n\n\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    } else {\n      if (chunk !== '') {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name\n        });\n      }\n    }\n  }\n};\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\n\n\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n\n  if (len > 0) {\n    newChildren = [];\n\n    for (i = 0; i < len - 1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n\n  return this;\n};\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\n\n\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  } else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  } else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n\n  return this;\n};\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\n\n\nSourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\n\n\nSourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    if (this.children[i][isSourceNode]) {\n      this.children[i].walkSourceContents(aFn);\n    }\n  }\n\n  var sources = Object.keys(this.sourceContents);\n\n  for (var i = 0, len = sources.length; i < len; i++) {\n    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n  }\n};\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\n\n\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\n\n\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n\n    if (original.source !== null && original.line !== null && original.column !== null) {\n      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0; // Mappings end at eol\n\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n  return {\n    code: generated.code,\n    map: map\n  };\n};\n\nexports.SourceNode = SourceNode;","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/stacktrace-gps/node_modules/source-map/lib/source-node.js"],"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","shiftNextLine","lineContents","shift","newLine","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","addMappingWithCode","nextLine","code","substr","generatedColumn","length","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","undefined","originalLine","originalColumn","prototype","SourceNode_add","aChunk","Array","isArray","chunk","push","TypeError","prepend","SourceNode_prepend","i","unshift","walk","SourceNode_walk","aFn","len","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","replace","SourceNode_setSourceContent","aSourceFile","aSourceContent","toSetString","walkSourceContents","SourceNode_walkSourceContents","Object","keys","fromSetString","toString","SourceNode_toString","str","toStringWithSourceMap","SourceNode_toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports"],"mappings":"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","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n"]},"metadata":{},"sourceType":"script"}