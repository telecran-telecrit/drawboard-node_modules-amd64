{"ast":null,"code":"import _classCallCheck from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport var ZigZagLineFiller =\n/*#__PURE__*/\nfunction () {\n  function ZigZagLineFiller(helper) {\n    _classCallCheck(this, ZigZagLineFiller);\n\n    this.helper = helper;\n  }\n\n  _createClass(ZigZagLineFiller, [{\n    key: \"fillPolygon\",\n    value: function fillPolygon(points, o) {\n      var gap = o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap;\n      var zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n      o = Object.assign({}, o, {\n        hachureGap: gap + zo\n      });\n      var lines = polygonHachureLines(points, o);\n      return {\n        type: 'fillSketch',\n        ops: this.zigzagLines(lines, zo, o)\n      };\n    }\n  }, {\n    key: \"zigzagLines\",\n    value: function zigzagLines(lines, zo, o) {\n      var _this = this;\n\n      var ops = [];\n      lines.forEach(function (line) {\n        var length = lineLength(line);\n        var count = Math.round(length / (2 * zo));\n        var p1 = line[0];\n        var p2 = line[1];\n\n        if (p1[0] > p2[0]) {\n          p1 = line[1];\n          p2 = line[0];\n        }\n\n        var alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n\n        for (var i = 0; i < count; i++) {\n          var lstart = i * 2 * zo;\n          var lend = (i + 1) * 2 * zo;\n          var dz = Math.sqrt(2 * Math.pow(zo, 2));\n          var start = [p1[0] + lstart * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha)];\n          var end = [p1[0] + lend * Math.cos(alpha), p1[1] + lend * Math.sin(alpha)];\n          var middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n          ops = ops.concat(_this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o));\n          ops = ops.concat(_this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n        }\n      });\n      return ops;\n    }\n  }]);\n\n  return ZigZagLineFiller;\n}();","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/fillers/zigzag-line-filler.js"],"names":["lineLength","polygonHachureLines","ZigZagLineFiller","helper","points","o","gap","hachureGap","strokeWidth","zo","zigzagOffset","Object","assign","lines","type","ops","zigzagLines","forEach","line","length","count","Math","round","p1","p2","alpha","atan","i","lstart","lend","dz","sqrt","pow","start","cos","sin","end","middle","PI","concat","doubleLineOps"],"mappings":"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","sourcesContent":["import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = polygonHachureLines(points, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        let ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o));\n                ops = ops.concat(this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}