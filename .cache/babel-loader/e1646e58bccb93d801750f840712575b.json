{"ast":null,"code":"import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n  constructor(helper) {\n    this.helper = helper;\n  }\n\n  fillPolygon(points, o) {\n    const gap = o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap;\n    const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n    o = Object.assign({}, o, {\n      hachureGap: gap + zo\n    });\n    const lines = polygonHachureLines(points, o);\n    return {\n      type: 'fillSketch',\n      ops: this.zigzagLines(lines, zo, o)\n    };\n  }\n\n  zigzagLines(lines, zo, o) {\n    let ops = [];\n    lines.forEach(line => {\n      const length = lineLength(line);\n      const count = Math.round(length / (2 * zo));\n      let p1 = line[0];\n      let p2 = line[1];\n\n      if (p1[0] > p2[0]) {\n        p1 = line[1];\n        p2 = line[0];\n      }\n\n      const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n\n      for (let i = 0; i < count; i++) {\n        const lstart = i * 2 * zo;\n        const lend = (i + 1) * 2 * zo;\n        const dz = Math.sqrt(2 * Math.pow(zo, 2));\n        const start = [p1[0] + lstart * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha)];\n        const end = [p1[0] + lend * Math.cos(alpha), p1[1] + lend * Math.sin(alpha)];\n        const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n        ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o));\n        ops = ops.concat(this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n      }\n    });\n    return ops;\n  }\n\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/fillers/zigzag-line-filler.js"],"names":["lineLength","polygonHachureLines","ZigZagLineFiller","constructor","helper","fillPolygon","points","o","gap","hachureGap","strokeWidth","zo","zigzagOffset","Object","assign","lines","type","ops","zigzagLines","forEach","line","length","count","Math","round","p1","p2","alpha","atan","i","lstart","lend","dz","sqrt","pow","start","cos","sin","end","middle","PI","concat","doubleLineOps"],"mappings":"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","sourcesContent":["import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = polygonHachureLines(points, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        let ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o));\n                ops = ops.concat(this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}