{"ast":null,"code":"import { clearAppStatePropertiesForHistory } from \"./appState\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { isLinearElement } from \"./element/typeChecks\";\nexport class SceneHistory {\n  constructor() {\n    this.recording = true;\n    this.stateHistory = [];\n    this.redoStack = [];\n  }\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map(s => JSON.parse(s)),\n      redoStack: this.redoStack.map(s => JSON.parse(s))\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n  }\n\n  generateEntry(appState, elements) {\n    return JSON.stringify({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (isLinearElement(element) && appState.multiElement && appState.multiElement.id === element.id) {\n          // don't store multi-point arrow if still has only one point\n          if (appState.multiElement && appState.multiElement.id === element.id && element.points.length < 2) {\n            return elements;\n          }\n\n          elements.push(newElementWith(element, {\n            // don't store last point if not committed\n            points: element.lastCommittedPoint !== element.points[element.points.length - 1] ? element.points.slice(0, -1) : element.points,\n            // don't regenerate versionNonce else this will short-circuit our\n            //  bail-on-no-change logic in pushEntry()\n            versionNonce: element.versionNonce\n          }));\n        } else {\n          elements.push(newElementWith(element, {\n            versionNonce: element.versionNonce\n          }));\n        }\n\n        return elements;\n      }, [])\n    });\n  }\n\n  pushEntry(appState, elements) {\n    const newEntry = this.generateEntry(appState, elements);\n\n    if (this.stateHistory.length > 0 && this.stateHistory[this.stateHistory.length - 1] === newEntry) {\n      // If the last entry is the same as this one, ignore it\n      return;\n    }\n\n    this.stateHistory.push(newEntry); // As a new entry was pushed, we invalidate the redo stack\n\n    this.clearRedoStack();\n  }\n\n  restoreEntry(entry) {\n    try {\n      return JSON.parse(entry);\n    } catch {\n      return null;\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce() {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.restoreEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce() {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.restoreEntry(entryToRestore);\n    }\n\n    return null;\n  } // Suspicious that this is called so many places. Seems error-prone.\n\n\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state, elements) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n\n}\nexport const createHistory = () => {\n  const history = new SceneHistory();\n  return {\n    history\n  };\n};","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/history.ts"],"names":["clearAppStatePropertiesForHistory","newElementWith","isLinearElement","SceneHistory","recording","stateHistory","redoStack","getSnapshotForTest","map","s","JSON","parse","clear","length","generateEntry","appState","elements","stringify","reduce","element","multiElement","id","points","push","lastCommittedPoint","slice","versionNonce","pushEntry","newEntry","clearRedoStack","restoreEntry","entry","splice","redoOnce","entryToRestore","pop","undefined","undoOnce","currentEntry","resumeRecording","record","state","createHistory","history"],"mappings":"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","sourcesContent":["import { AppState } from \"./types\";\nimport { ExcalidrawElement } from \"./element/types\";\nimport { clearAppStatePropertiesForHistory } from \"./appState\";\nimport { newElementWith } from \"./element/mutateElement\";\nimport { isLinearElement } from \"./element/typeChecks\";\n\ntype Result = {\n  appState: AppState;\n  elements: ExcalidrawElement[];\n};\n\nexport class SceneHistory {\n  private recording: boolean = true;\n  private stateHistory: string[] = [];\n  private redoStack: string[] = [];\n\n  getSnapshotForTest() {\n    return {\n      recording: this.recording,\n      stateHistory: this.stateHistory.map((s) => JSON.parse(s)),\n      redoStack: this.redoStack.map((s) => JSON.parse(s)),\n    };\n  }\n\n  clear() {\n    this.stateHistory.length = 0;\n    this.redoStack.length = 0;\n  }\n\n  private generateEntry(\n    appState: AppState,\n    elements: readonly ExcalidrawElement[],\n  ) {\n    return JSON.stringify({\n      appState: clearAppStatePropertiesForHistory(appState),\n      elements: elements.reduce((elements, element) => {\n        if (\n          isLinearElement(element) &&\n          appState.multiElement &&\n          appState.multiElement.id === element.id\n        ) {\n          // don't store multi-point arrow if still has only one point\n          if (\n            appState.multiElement &&\n            appState.multiElement.id === element.id &&\n            element.points.length < 2\n          ) {\n            return elements;\n          }\n\n          elements.push(\n            newElementWith(element, {\n              // don't store last point if not committed\n              points:\n                element.lastCommittedPoint !==\n                element.points[element.points.length - 1]\n                  ? element.points.slice(0, -1)\n                  : element.points,\n              // don't regenerate versionNonce else this will short-circuit our\n              //  bail-on-no-change logic in pushEntry()\n              versionNonce: element.versionNonce,\n            }),\n          );\n        } else {\n          elements.push(\n            newElementWith(element, { versionNonce: element.versionNonce }),\n          );\n        }\n        return elements;\n      }, [] as Mutable<typeof elements>),\n    });\n  }\n\n  pushEntry(appState: AppState, elements: readonly ExcalidrawElement[]) {\n    const newEntry = this.generateEntry(appState, elements);\n    if (\n      this.stateHistory.length > 0 &&\n      this.stateHistory[this.stateHistory.length - 1] === newEntry\n    ) {\n      // If the last entry is the same as this one, ignore it\n      return;\n    }\n\n    this.stateHistory.push(newEntry);\n\n    // As a new entry was pushed, we invalidate the redo stack\n    this.clearRedoStack();\n  }\n\n  restoreEntry(entry: string) {\n    try {\n      return JSON.parse(entry);\n    } catch {\n      return null;\n    }\n  }\n\n  clearRedoStack() {\n    this.redoStack.splice(0, this.redoStack.length);\n  }\n\n  redoOnce(): Result | null {\n    if (this.redoStack.length === 0) {\n      return null;\n    }\n\n    const entryToRestore = this.redoStack.pop();\n\n    if (entryToRestore !== undefined) {\n      this.stateHistory.push(entryToRestore);\n      return this.restoreEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  undoOnce(): Result | null {\n    if (this.stateHistory.length === 1) {\n      return null;\n    }\n\n    const currentEntry = this.stateHistory.pop();\n\n    const entryToRestore = this.stateHistory[this.stateHistory.length - 1];\n\n    if (currentEntry !== undefined) {\n      this.redoStack.push(currentEntry);\n      return this.restoreEntry(entryToRestore);\n    }\n\n    return null;\n  }\n\n  // Suspicious that this is called so many places. Seems error-prone.\n  resumeRecording() {\n    this.recording = true;\n  }\n\n  record(state: AppState, elements: readonly ExcalidrawElement[]) {\n    if (this.recording) {\n      this.pushEntry(state, elements);\n      this.recording = false;\n    }\n  }\n}\n\nexport const createHistory: () => { history: SceneHistory } = () => {\n  const history = new SceneHistory();\n  return { history };\n};\n"]},"metadata":{},"sourceType":"module"}