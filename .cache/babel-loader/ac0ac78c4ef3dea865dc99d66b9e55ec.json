{"ast":null,"code":"import { lineLength } from './geometry';\n\nfunction isType(token, type) {\n  return token.type === type;\n}\n\nconst PARAMS = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 4,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\n\nclass ParsedPath {\n  constructor(d) {\n    this.COMMAND = 0;\n    this.NUMBER = 1;\n    this.EOD = 2;\n    this.segments = [];\n    this.parseData(d);\n    this.processPoints();\n  }\n\n  tokenize(d) {\n    const tokens = new Array();\n\n    while (d !== '') {\n      if (d.match(/^([ \\t\\r\\n,]+)/)) {\n        d = d.substr(RegExp.$1.length);\n      } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n        tokens[tokens.length] = {\n          type: this.COMMAND,\n          text: RegExp.$1\n        };\n        d = d.substr(RegExp.$1.length);\n      } else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n        tokens[tokens.length] = {\n          type: this.NUMBER,\n          text: `${parseFloat(RegExp.$1)}`\n        };\n        d = d.substr(RegExp.$1.length);\n      } else {\n        return [];\n      }\n    }\n\n    tokens[tokens.length] = {\n      type: this.EOD,\n      text: ''\n    };\n    return tokens;\n  }\n\n  parseData(d) {\n    const tokens = this.tokenize(d);\n    let index = 0;\n    let token = tokens[index];\n    let mode = 'BOD';\n    this.segments = new Array();\n\n    while (!isType(token, this.EOD)) {\n      let param_length;\n      const params = new Array();\n\n      if (mode === 'BOD') {\n        if (token.text === 'M' || token.text === 'm') {\n          index++;\n          param_length = PARAMS[token.text];\n          mode = token.text;\n        } else {\n          this.parseData('M0,0' + d);\n          return;\n        }\n      } else {\n        if (isType(token, this.NUMBER)) {\n          param_length = PARAMS[mode];\n        } else {\n          index++;\n          param_length = PARAMS[token.text];\n          mode = token.text;\n        }\n      }\n\n      if (index + param_length < tokens.length) {\n        for (let i = index; i < index + param_length; i++) {\n          const numbeToken = tokens[i];\n\n          if (isType(numbeToken, this.NUMBER)) {\n            params[params.length] = +numbeToken.text;\n          } else {\n            console.error('Param not a number: ' + mode + ',' + numbeToken.text);\n            return;\n          }\n        }\n\n        if (typeof PARAMS[mode] === 'number') {\n          const segment = {\n            key: mode,\n            data: params\n          };\n          this.segments.push(segment);\n          index += param_length;\n          token = tokens[index];\n          if (mode === 'M') mode = 'L';\n          if (mode === 'm') mode = 'l';\n        } else {\n          console.error('Bad segment: ' + mode);\n          return;\n        }\n      } else {\n        console.error('Path data ended short');\n      }\n    }\n  }\n\n  get closed() {\n    if (typeof this._closed === 'undefined') {\n      this._closed = false;\n\n      for (const s of this.segments) {\n        if (s.key.toLowerCase() === 'z') {\n          this._closed = true;\n        }\n      }\n    }\n\n    return this._closed;\n  }\n\n  processPoints() {\n    let first = null;\n    let currentPoint = [0, 0];\n\n    for (let i = 0; i < this.segments.length; i++) {\n      const s = this.segments[i];\n\n      switch (s.key) {\n        case 'M':\n        case 'L':\n        case 'T':\n          s.point = [s.data[0], s.data[1]];\n          break;\n\n        case 'm':\n        case 'l':\n        case 't':\n          s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n          break;\n\n        case 'H':\n          s.point = [s.data[0], currentPoint[1]];\n          break;\n\n        case 'h':\n          s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n          break;\n\n        case 'V':\n          s.point = [currentPoint[0], s.data[0]];\n          break;\n\n        case 'v':\n          s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n          break;\n\n        case 'z':\n        case 'Z':\n          if (first) {\n            s.point = [first[0], first[1]];\n          }\n\n          break;\n\n        case 'C':\n          s.point = [s.data[4], s.data[5]];\n          break;\n\n        case 'c':\n          s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n          break;\n\n        case 'S':\n          s.point = [s.data[2], s.data[3]];\n          break;\n\n        case 's':\n          s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n          break;\n\n        case 'Q':\n          s.point = [s.data[2], s.data[3]];\n          break;\n\n        case 'q':\n          s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n          break;\n\n        case 'A':\n          s.point = [s.data[5], s.data[6]];\n          break;\n\n        case 'a':\n          s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n          break;\n      }\n\n      if (s.key === 'm' || s.key === 'M') {\n        first = null;\n      }\n\n      if (s.point) {\n        currentPoint = s.point;\n\n        if (!first) {\n          first = s.point;\n        }\n      }\n\n      if (s.key === 'z' || s.key === 'Z') {\n        first = null;\n      }\n    }\n  }\n\n}\n\nexport class RoughPath {\n  constructor(d) {\n    this._position = [0, 0];\n    this._first = null;\n    this.bezierReflectionPoint = null;\n    this.quadReflectionPoint = null;\n    this.parsed = new ParsedPath(d);\n  }\n\n  get segments() {\n    return this.parsed.segments;\n  }\n\n  get closed() {\n    return this.parsed.closed;\n  }\n\n  get linearPoints() {\n    if (!this._linearPoints) {\n      const lp = [];\n      let points = [];\n\n      for (const s of this.parsed.segments) {\n        const key = s.key.toLowerCase();\n\n        if (key === 'm' || key === 'z') {\n          if (points.length) {\n            lp.push(points);\n            points = [];\n          }\n\n          if (key === 'z') {\n            continue;\n          }\n        }\n\n        if (s.point) {\n          points.push(s.point);\n        }\n      }\n\n      if (points.length) {\n        lp.push(points);\n        points = [];\n      }\n\n      this._linearPoints = lp;\n    }\n\n    return this._linearPoints;\n  }\n\n  get first() {\n    return this._first;\n  }\n\n  set first(v) {\n    this._first = v;\n  }\n\n  setPosition(x, y) {\n    this._position = [x, y];\n\n    if (!this._first) {\n      this._first = [x, y];\n    }\n  }\n\n  get position() {\n    return this._position;\n  }\n\n  get x() {\n    return this._position[0];\n  }\n\n  get y() {\n    return this._position[1];\n  }\n\n} // Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\n\nexport class RoughArcConverter {\n  constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n    this._segIndex = 0;\n    this._numSegs = 0;\n    this._rx = 0;\n    this._ry = 0;\n    this._sinPhi = 0;\n    this._cosPhi = 0;\n    this._C = [0, 0];\n    this._theta = 0;\n    this._delta = 0;\n    this._T = 0;\n    this._from = from;\n\n    if (from[0] === to[0] && from[1] === to[1]) {\n      return;\n    }\n\n    const radPerDeg = Math.PI / 180;\n    this._rx = Math.abs(radii[0]);\n    this._ry = Math.abs(radii[1]);\n    this._sinPhi = Math.sin(angle * radPerDeg);\n    this._cosPhi = Math.cos(angle * radPerDeg);\n    const x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n    const y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n    let root = 0;\n    const numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n\n    if (numerator < 0) {\n      const s = Math.sqrt(1 - numerator / (this._rx * this._rx * this._ry * this._ry));\n      this._rx = this._rx * s;\n      this._ry = this._ry * s;\n      root = 0;\n    } else {\n      root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) * Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n    }\n\n    const cxdash = root * this._rx * y1dash / this._ry;\n    const cydash = -root * this._ry * x1dash / this._rx;\n    this._C = [0, 0];\n    this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n    this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n    this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n    let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n\n    if (!sweepFlag && dtheta > 0) {\n      dtheta -= 2 * Math.PI;\n    } else if (sweepFlag && dtheta < 0) {\n      dtheta += 2 * Math.PI;\n    }\n\n    this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n    this._delta = dtheta / this._numSegs;\n    this._T = 8 / 3 * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n  }\n\n  getNextSegment() {\n    if (this._segIndex === this._numSegs) {\n      return null;\n    }\n\n    const cosTheta1 = Math.cos(this._theta);\n    const sinTheta1 = Math.sin(this._theta);\n    const theta2 = this._theta + this._delta;\n    const cosTheta2 = Math.cos(theta2);\n    const sinTheta2 = Math.sin(theta2);\n    const to = [this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0], this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]];\n    const cp1 = [this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1), this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)];\n    const cp2 = [to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2), to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)];\n    this._theta = theta2;\n    this._from = [to[0], to[1]];\n    this._segIndex++;\n    return {\n      cp1: cp1,\n      cp2: cp2,\n      to: to\n    };\n  }\n\n  calculateVectorAngle(ux, uy, vx, vy) {\n    const ta = Math.atan2(uy, ux);\n    const tb = Math.atan2(vy, vx);\n    if (tb >= ta) return tb - ta;\n    return 2 * Math.PI - (ta - tb);\n  }\n\n}\nexport class PathFitter {\n  constructor(sets, closed) {\n    this.sets = sets;\n    this.closed = closed;\n  }\n\n  fit(simplification) {\n    const outSets = [];\n\n    for (const set of this.sets) {\n      const length = set.length;\n      let estLength = Math.floor(simplification * length);\n\n      if (estLength < 5) {\n        if (length <= 5) {\n          continue;\n        }\n\n        estLength = 5;\n      }\n\n      outSets.push(this.reduce(set, estLength));\n    }\n\n    let d = '';\n\n    for (const set of outSets) {\n      for (let i = 0; i < set.length; i++) {\n        const point = set[i];\n\n        if (i === 0) {\n          d += 'M' + point[0] + ',' + point[1];\n        } else {\n          d += 'L' + point[0] + ',' + point[1];\n        }\n      }\n\n      if (this.closed) {\n        d += 'z ';\n      }\n    }\n\n    return d;\n  }\n\n  reduce(set, count) {\n    if (set.length <= count) {\n      return set;\n    }\n\n    const points = set.slice(0);\n\n    while (points.length > count) {\n      const areas = [];\n      let minArea = -1;\n      let minIndex = -1;\n\n      for (let i = 1; i < points.length - 1; i++) {\n        const a = lineLength([points[i - 1], points[i]]);\n        const b = lineLength([points[i], points[i + 1]]);\n        const c = lineLength([points[i - 1], points[i + 1]]);\n        const s = (a + b + c) / 2.0;\n        const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n        areas.push(area);\n\n        if (minArea < 0 || area < minArea) {\n          minArea = area;\n          minIndex = i;\n        }\n      }\n\n      if (minIndex > 0) {\n        points.splice(minIndex, 1);\n      } else {\n        break;\n      }\n    }\n\n    return points;\n  }\n\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/path.js"],"names":["lineLength","isType","token","type","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","ParsedPath","constructor","d","COMMAND","NUMBER","EOD","segments","parseData","processPoints","tokenize","tokens","Array","match","substr","RegExp","$1","length","text","parseFloat","index","mode","param_length","params","i","numbeToken","console","error","segment","key","data","push","closed","_closed","toLowerCase","first","currentPoint","point","RoughPath","_position","_first","bezierReflectionPoint","quadReflectionPoint","parsed","linearPoints","_linearPoints","lp","points","setPosition","x","y","position","RoughArcConverter","from","to","radii","angle","largeArcFlag","sweepFlag","_segIndex","_numSegs","_rx","_ry","_sinPhi","_cosPhi","_C","_theta","_delta","_T","_from","radPerDeg","Math","PI","abs","sin","cos","x1dash","y1dash","root","numerator","sqrt","cxdash","cydash","calculateVectorAngle","dtheta","ceil","getNextSegment","cosTheta1","sinTheta1","theta2","cosTheta2","sinTheta2","cp1","cp2","ux","uy","vx","vy","ta","atan2","tb","PathFitter","sets","fit","simplification","outSets","set","estLength","floor","reduce","count","slice","areas","minArea","minIndex","b","area","splice"],"mappings":"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","sourcesContent":["import { lineLength } from './geometry';\nfunction isType(token, type) {\n    return token.type === type;\n}\nconst PARAMS = {\n    A: 7,\n    a: 7,\n    C: 6,\n    c: 6,\n    H: 1,\n    h: 1,\n    L: 2,\n    l: 2,\n    M: 2,\n    m: 2,\n    Q: 4,\n    q: 4,\n    S: 4,\n    s: 4,\n    T: 4,\n    t: 2,\n    V: 1,\n    v: 1,\n    Z: 0,\n    z: 0\n};\nclass ParsedPath {\n    constructor(d) {\n        this.COMMAND = 0;\n        this.NUMBER = 1;\n        this.EOD = 2;\n        this.segments = [];\n        this.parseData(d);\n        this.processPoints();\n    }\n    tokenize(d) {\n        const tokens = new Array();\n        while (d !== '') {\n            if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n                tokens[tokens.length] = { type: this.COMMAND, text: RegExp.$1 };\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n                tokens[tokens.length] = { type: this.NUMBER, text: `${parseFloat(RegExp.$1)}` };\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                return [];\n            }\n        }\n        tokens[tokens.length] = { type: this.EOD, text: '' };\n        return tokens;\n    }\n    parseData(d) {\n        const tokens = this.tokenize(d);\n        let index = 0;\n        let token = tokens[index];\n        let mode = 'BOD';\n        this.segments = new Array();\n        while (!isType(token, this.EOD)) {\n            let param_length;\n            const params = new Array();\n            if (mode === 'BOD') {\n                if (token.text === 'M' || token.text === 'm') {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n                else {\n                    this.parseData('M0,0' + d);\n                    return;\n                }\n            }\n            else {\n                if (isType(token, this.NUMBER)) {\n                    param_length = PARAMS[mode];\n                }\n                else {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n            }\n            if ((index + param_length) < tokens.length) {\n                for (let i = index; i < index + param_length; i++) {\n                    const numbeToken = tokens[i];\n                    if (isType(numbeToken, this.NUMBER)) {\n                        params[params.length] = +numbeToken.text;\n                    }\n                    else {\n                        console.error('Param not a number: ' + mode + ',' + numbeToken.text);\n                        return;\n                    }\n                }\n                if (typeof PARAMS[mode] === 'number') {\n                    const segment = { key: mode, data: params };\n                    this.segments.push(segment);\n                    index += param_length;\n                    token = tokens[index];\n                    if (mode === 'M')\n                        mode = 'L';\n                    if (mode === 'm')\n                        mode = 'l';\n                }\n                else {\n                    console.error('Bad segment: ' + mode);\n                    return;\n                }\n            }\n            else {\n                console.error('Path data ended short');\n            }\n        }\n    }\n    get closed() {\n        if (typeof this._closed === 'undefined') {\n            this._closed = false;\n            for (const s of this.segments) {\n                if (s.key.toLowerCase() === 'z') {\n                    this._closed = true;\n                }\n            }\n        }\n        return this._closed;\n    }\n    processPoints() {\n        let first = null;\n        let currentPoint = [0, 0];\n        for (let i = 0; i < this.segments.length; i++) {\n            const s = this.segments[i];\n            switch (s.key) {\n                case 'M':\n                case 'L':\n                case 'T':\n                    s.point = [s.data[0], s.data[1]];\n                    break;\n                case 'm':\n                case 'l':\n                case 't':\n                    s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n                    break;\n                case 'H':\n                    s.point = [s.data[0], currentPoint[1]];\n                    break;\n                case 'h':\n                    s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n                    break;\n                case 'V':\n                    s.point = [currentPoint[0], s.data[0]];\n                    break;\n                case 'v':\n                    s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n                    break;\n                case 'z':\n                case 'Z':\n                    if (first) {\n                        s.point = [first[0], first[1]];\n                    }\n                    break;\n                case 'C':\n                    s.point = [s.data[4], s.data[5]];\n                    break;\n                case 'c':\n                    s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n                    break;\n                case 'S':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 's':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'Q':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 'q':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'A':\n                    s.point = [s.data[5], s.data[6]];\n                    break;\n                case 'a':\n                    s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n                    break;\n            }\n            if (s.key === 'm' || s.key === 'M') {\n                first = null;\n            }\n            if (s.point) {\n                currentPoint = s.point;\n                if (!first) {\n                    first = s.point;\n                }\n            }\n            if (s.key === 'z' || s.key === 'Z') {\n                first = null;\n            }\n        }\n    }\n}\nexport class RoughPath {\n    constructor(d) {\n        this._position = [0, 0];\n        this._first = null;\n        this.bezierReflectionPoint = null;\n        this.quadReflectionPoint = null;\n        this.parsed = new ParsedPath(d);\n    }\n    get segments() {\n        return this.parsed.segments;\n    }\n    get closed() {\n        return this.parsed.closed;\n    }\n    get linearPoints() {\n        if (!this._linearPoints) {\n            const lp = [];\n            let points = [];\n            for (const s of this.parsed.segments) {\n                const key = s.key.toLowerCase();\n                if (key === 'm' || key === 'z') {\n                    if (points.length) {\n                        lp.push(points);\n                        points = [];\n                    }\n                    if (key === 'z') {\n                        continue;\n                    }\n                }\n                if (s.point) {\n                    points.push(s.point);\n                }\n            }\n            if (points.length) {\n                lp.push(points);\n                points = [];\n            }\n            this._linearPoints = lp;\n        }\n        return this._linearPoints;\n    }\n    get first() {\n        return this._first;\n    }\n    set first(v) {\n        this._first = v;\n    }\n    setPosition(x, y) {\n        this._position = [x, y];\n        if (!this._first) {\n            this._first = [x, y];\n        }\n    }\n    get position() {\n        return this._position;\n    }\n    get x() {\n        return this._position[0];\n    }\n    get y() {\n        return this._position[1];\n    }\n}\n// Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\nexport class RoughArcConverter {\n    constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n        this._segIndex = 0;\n        this._numSegs = 0;\n        this._rx = 0;\n        this._ry = 0;\n        this._sinPhi = 0;\n        this._cosPhi = 0;\n        this._C = [0, 0];\n        this._theta = 0;\n        this._delta = 0;\n        this._T = 0;\n        this._from = from;\n        if (from[0] === to[0] && from[1] === to[1]) {\n            return;\n        }\n        const radPerDeg = Math.PI / 180;\n        this._rx = Math.abs(radii[0]);\n        this._ry = Math.abs(radii[1]);\n        this._sinPhi = Math.sin(angle * radPerDeg);\n        this._cosPhi = Math.cos(angle * radPerDeg);\n        const x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n        const y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n        let root = 0;\n        const numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n        if (numerator < 0) {\n            const s = Math.sqrt(1 - (numerator / (this._rx * this._rx * this._ry * this._ry)));\n            this._rx = this._rx * s;\n            this._ry = this._ry * s;\n            root = 0;\n        }\n        else {\n            root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) *\n                Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n        }\n        const cxdash = root * this._rx * y1dash / this._ry;\n        const cydash = -root * this._ry * x1dash / this._rx;\n        this._C = [0, 0];\n        this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n        this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n        this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n        let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n        if ((!sweepFlag) && (dtheta > 0)) {\n            dtheta -= 2 * Math.PI;\n        }\n        else if (sweepFlag && (dtheta < 0)) {\n            dtheta += 2 * Math.PI;\n        }\n        this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n        this._delta = dtheta / this._numSegs;\n        this._T = (8 / 3) * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n    }\n    getNextSegment() {\n        if (this._segIndex === this._numSegs) {\n            return null;\n        }\n        const cosTheta1 = Math.cos(this._theta);\n        const sinTheta1 = Math.sin(this._theta);\n        const theta2 = this._theta + this._delta;\n        const cosTheta2 = Math.cos(theta2);\n        const sinTheta2 = Math.sin(theta2);\n        const to = [\n            this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0],\n            this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]\n        ];\n        const cp1 = [\n            this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1),\n            this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)\n        ];\n        const cp2 = [\n            to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2),\n            to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)\n        ];\n        this._theta = theta2;\n        this._from = [to[0], to[1]];\n        this._segIndex++;\n        return {\n            cp1: cp1,\n            cp2: cp2,\n            to: to\n        };\n    }\n    calculateVectorAngle(ux, uy, vx, vy) {\n        const ta = Math.atan2(uy, ux);\n        const tb = Math.atan2(vy, vx);\n        if (tb >= ta)\n            return tb - ta;\n        return 2 * Math.PI - (ta - tb);\n    }\n}\nexport class PathFitter {\n    constructor(sets, closed) {\n        this.sets = sets;\n        this.closed = closed;\n    }\n    fit(simplification) {\n        const outSets = [];\n        for (const set of this.sets) {\n            const length = set.length;\n            let estLength = Math.floor(simplification * length);\n            if (estLength < 5) {\n                if (length <= 5) {\n                    continue;\n                }\n                estLength = 5;\n            }\n            outSets.push(this.reduce(set, estLength));\n        }\n        let d = '';\n        for (const set of outSets) {\n            for (let i = 0; i < set.length; i++) {\n                const point = set[i];\n                if (i === 0) {\n                    d += 'M' + point[0] + ',' + point[1];\n                }\n                else {\n                    d += 'L' + point[0] + ',' + point[1];\n                }\n            }\n            if (this.closed) {\n                d += 'z ';\n            }\n        }\n        return d;\n    }\n    reduce(set, count) {\n        if (set.length <= count) {\n            return set;\n        }\n        const points = set.slice(0);\n        while (points.length > count) {\n            const areas = [];\n            let minArea = -1;\n            let minIndex = -1;\n            for (let i = 1; i < (points.length - 1); i++) {\n                const a = lineLength([points[i - 1], points[i]]);\n                const b = lineLength([points[i], points[i + 1]]);\n                const c = lineLength([points[i - 1], points[i + 1]]);\n                const s = (a + b + c) / 2.0;\n                const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n                areas.push(area);\n                if ((minArea < 0) || (area < minArea)) {\n                    minArea = area;\n                    minIndex = i;\n                }\n            }\n            if (minIndex > 0) {\n                points.splice(minIndex, 1);\n            }\n            else {\n                break;\n            }\n        }\n        return points;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}