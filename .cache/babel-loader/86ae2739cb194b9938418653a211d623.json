{"ast":null,"code":"import { isInvisiblySmallElement, normalizeDimensions, isTextElement } from \"../element\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { randomId } from \"../random\";\nimport { DEFAULT_TEXT_ALIGN } from \"../appState\";\nexport function restore( // we're making the elements mutable for this API because we want to\n//  efficiently remove/tweak properties on them (to migrate old scenes)\nsavedElements, savedState, opts) {\n  const elements = savedElements.filter(el => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    //  and causing issues if retained\n    return el.type !== \"selection\" && !isInvisiblySmallElement(el);\n  }).map(element => {\n    var _element$roughness, _element$angle;\n\n    let points = [];\n\n    if (element.type === \"arrow\") {\n      if (Array.isArray(element.points)) {\n        // if point array is empty, add one point to the arrow\n        // this is used as fail safe to convert incoming data to a valid\n        // arrow. In the new arrow, width and height are not being usde\n        points = element.points.length > 0 ? element.points : [[0, 0]];\n      } else {\n        // convert old arrow type to a new one\n        // old arrow spec used width and height\n        // to determine the endpoints\n        points = [[0, 0], [element.width, element.height]];\n      }\n\n      element.points = points;\n    } else if (element.type === \"line\") {\n      // old spec, pre-arrows\n      // old spec, post-arrows\n      if (!Array.isArray(element.points) || element.points.length === 0) {\n        points = [[0, 0], [element.width, element.height]];\n      } else {\n        points = element.points;\n      }\n\n      element.points = points;\n    } else {\n      if (isTextElement(element)) {\n        if (!element.textAlign) {\n          element.textAlign = DEFAULT_TEXT_ALIGN;\n        }\n      }\n\n      normalizeDimensions(element); // old spec, where non-linear elements used to have empty points arrays\n\n      if (\"points\" in element) {\n        delete element.points;\n      }\n    }\n\n    return { ...element,\n      // all elements must have version > 0 so getDrawingVersion() will pick up newly added elements\n      version: element.version || 1,\n      id: element.id || randomId(),\n      fillStyle: element.fillStyle || \"hachure\",\n      strokeWidth: element.strokeWidth || 1,\n      roughness: (_element$roughness = element.roughness) !== null && _element$roughness !== void 0 ? _element$roughness : 1,\n      opacity: element.opacity === null || element.opacity === undefined ? 100 : element.opacity,\n      angle: (_element$angle = element.angle) !== null && _element$angle !== void 0 ? _element$angle : 0\n    };\n  });\n\n  if ((opts === null || opts === void 0 ? void 0 : opts.scrollToContent) && savedState) {\n    savedState = { ...savedState,\n      ...calculateScrollCenter(elements)\n    };\n  }\n\n  return {\n    elements: elements,\n    appState: savedState\n  };\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/data/restore.ts"],"names":["isInvisiblySmallElement","normalizeDimensions","isTextElement","calculateScrollCenter","randomId","DEFAULT_TEXT_ALIGN","restore","savedElements","savedState","opts","elements","filter","el","type","map","element","points","Array","isArray","length","width","height","textAlign","version","id","fillStyle","strokeWidth","roughness","opacity","undefined","angle","scrollToContent","appState"],"mappings":"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","sourcesContent":["import { Point } from \"../types\";\n\nimport { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { DataState } from \"./types\";\nimport {\n  isInvisiblySmallElement,\n  normalizeDimensions,\n  isTextElement,\n} from \"../element\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { randomId } from \"../random\";\nimport { DEFAULT_TEXT_ALIGN } from \"../appState\";\n\nexport function restore(\n  // we're making the elements mutable for this API because we want to\n  //  efficiently remove/tweak properties on them (to migrate old scenes)\n  savedElements: readonly Mutable<ExcalidrawElement>[],\n  savedState: AppState | null,\n  opts?: { scrollToContent: boolean },\n): DataState {\n  const elements = savedElements\n    .filter((el) => {\n      // filtering out selection, which is legacy, no longer kept in elements,\n      //  and causing issues if retained\n      return el.type !== \"selection\" && !isInvisiblySmallElement(el);\n    })\n    .map((element) => {\n      let points: Point[] = [];\n      if (element.type === \"arrow\") {\n        if (Array.isArray(element.points)) {\n          // if point array is empty, add one point to the arrow\n          // this is used as fail safe to convert incoming data to a valid\n          // arrow. In the new arrow, width and height are not being usde\n          points = element.points.length > 0 ? element.points : [[0, 0]];\n        } else {\n          // convert old arrow type to a new one\n          // old arrow spec used width and height\n          // to determine the endpoints\n          points = [\n            [0, 0],\n            [element.width, element.height],\n          ];\n        }\n        element.points = points;\n      } else if (element.type === \"line\") {\n        // old spec, pre-arrows\n        // old spec, post-arrows\n        if (!Array.isArray(element.points) || element.points.length === 0) {\n          points = [\n            [0, 0],\n            [element.width, element.height],\n          ];\n        } else {\n          points = element.points;\n        }\n        element.points = points;\n      } else {\n        if (isTextElement(element)) {\n          if (!element.textAlign) {\n            element.textAlign = DEFAULT_TEXT_ALIGN;\n          }\n        }\n\n        normalizeDimensions(element);\n        // old spec, where non-linear elements used to have empty points arrays\n        if (\"points\" in element) {\n          delete element.points;\n        }\n      }\n\n      return {\n        ...element,\n        // all elements must have version > 0 so getDrawingVersion() will pick up newly added elements\n        version: element.version || 1,\n        id: element.id || randomId(),\n        fillStyle: element.fillStyle || \"hachure\",\n        strokeWidth: element.strokeWidth || 1,\n        roughness: element.roughness ?? 1,\n        opacity:\n          element.opacity === null || element.opacity === undefined\n            ? 100\n            : element.opacity,\n        angle: element.angle ?? 0,\n      };\n    });\n\n  if (opts?.scrollToContent && savedState) {\n    savedState = { ...savedState, ...calculateScrollCenter(elements) };\n  }\n\n  return {\n    elements: elements,\n    appState: savedState,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}