{"ast":null,"code":"import { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(points, o) {\n  const rotationCenter = [0, 0];\n  const angle = Math.round(o.hachureAngle + 90);\n\n  if (angle) {\n    rotatePoints(points, rotationCenter, angle);\n  }\n\n  const lines = straightHachureLines(points, o);\n\n  if (angle) {\n    rotatePoints(points, rotationCenter, -angle);\n    rotateLines(lines, rotationCenter, -angle);\n  }\n\n  return lines;\n}\n\nfunction straightHachureLines(points, o) {\n  const vertices = [...points];\n\n  if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n    vertices.push([vertices[0][0], vertices[0][1]]);\n  }\n\n  const lines = [];\n\n  if (vertices && vertices.length > 2) {\n    let gap = o.hachureGap;\n\n    if (gap < 0) {\n      gap = o.strokeWidth * 4;\n    }\n\n    gap = Math.max(gap, 0.1); // Create sorted edges table\n\n    const edges = [];\n\n    for (let i = 0; i < vertices.length - 1; i++) {\n      const p1 = vertices[i];\n      const p2 = vertices[i + 1];\n\n      if (p1[1] !== p2[1]) {\n        const ymin = Math.min(p1[1], p2[1]);\n        edges.push({\n          ymin,\n          ymax: Math.max(p1[1], p2[1]),\n          x: ymin === p1[1] ? p1[0] : p2[0],\n          islope: (p2[0] - p1[0]) / (p2[1] - p1[1])\n        });\n      }\n    }\n\n    edges.sort((e1, e2) => {\n      if (e1.ymin < e2.ymin) {\n        return -1;\n      }\n\n      if (e1.ymin > e2.ymin) {\n        return 1;\n      }\n\n      if (e1.x < e2.x) {\n        return -1;\n      }\n\n      if (e1.x > e2.x) {\n        return 1;\n      }\n\n      if (e1.ymax === e2.ymax) {\n        return 0;\n      }\n\n      return (e1.ymax - e2.ymax) / Math.abs(e1.ymax - e2.ymax);\n    });\n\n    if (!edges.length) {\n      return lines;\n    } // Start scanning\n\n\n    let activeEdges = [];\n    let y = edges[0].ymin;\n\n    while (activeEdges.length || edges.length) {\n      if (edges.length) {\n        let ix = -1;\n\n        for (let i = 0; i < edges.length; i++) {\n          if (edges[i].ymin > y) {\n            break;\n          }\n\n          ix = i;\n        }\n\n        const removed = edges.splice(0, ix + 1);\n        removed.forEach(edge => {\n          activeEdges.push({\n            s: y,\n            edge\n          });\n        });\n      }\n\n      activeEdges = activeEdges.filter(ae => {\n        if (ae.edge.ymax <= y) {\n          return false;\n        }\n\n        return true;\n      });\n      activeEdges.sort((ae1, ae2) => {\n        if (ae1.edge.x === ae2.edge.x) {\n          return 0;\n        }\n\n        return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);\n      }); // fill between the edges\n\n      if (activeEdges.length > 1) {\n        for (let i = 0; i < activeEdges.length; i = i + 2) {\n          const nexti = i + 1;\n\n          if (nexti >= activeEdges.length) {\n            break;\n          }\n\n          const ce = activeEdges[i].edge;\n          const ne = activeEdges[nexti].edge;\n          lines.push([[Math.round(ce.x), y], [Math.round(ne.x), y]]);\n        }\n      }\n\n      y += gap;\n      activeEdges.forEach(ae => {\n        ae.edge.x = ae.edge.x + gap * ae.edge.islope;\n      });\n    }\n  }\n\n  return lines;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/fillers/scan-line-hachure.js"],"names":["rotatePoints","rotateLines","polygonHachureLines","points","o","rotationCenter","angle","Math","round","hachureAngle","lines","straightHachureLines","vertices","join","length","push","gap","hachureGap","strokeWidth","max","edges","i","p1","p2","ymin","min","ymax","x","islope","sort","e1","e2","abs","activeEdges","y","ix","removed","splice","forEach","edge","s","filter","ae","ae1","ae2","nexti","ce","ne"],"mappings":"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","sourcesContent":["import { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(points, o) {\n    const rotationCenter = [0, 0];\n    const angle = Math.round(o.hachureAngle + 90);\n    if (angle) {\n        rotatePoints(points, rotationCenter, angle);\n    }\n    const lines = straightHachureLines(points, o);\n    if (angle) {\n        rotatePoints(points, rotationCenter, -angle);\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(points, o) {\n    const vertices = [...points];\n    if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n        vertices.push([vertices[0][0], vertices[0][1]]);\n    }\n    const lines = [];\n    if (vertices && vertices.length > 2) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        // Create sorted edges table\n        const edges = [];\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1])\n                });\n            }\n        }\n        edges.sort((e1, e2) => {\n            if (e1.ymin < e2.ymin) {\n                return -1;\n            }\n            if (e1.ymin > e2.ymin) {\n                return 1;\n            }\n            if (e1.x < e2.x) {\n                return -1;\n            }\n            if (e1.x > e2.x) {\n                return 1;\n            }\n            if (e1.ymax === e2.ymax) {\n                return 0;\n            }\n            return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n        });\n        if (!edges.length) {\n            return lines;\n        }\n        // Start scanning\n        let activeEdges = [];\n        let y = edges[0].ymin;\n        while (activeEdges.length || edges.length) {\n            if (edges.length) {\n                let ix = -1;\n                for (let i = 0; i < edges.length; i++) {\n                    if (edges[i].ymin > y) {\n                        break;\n                    }\n                    ix = i;\n                }\n                const removed = edges.splice(0, ix + 1);\n                removed.forEach((edge) => {\n                    activeEdges.push({ s: y, edge });\n                });\n            }\n            activeEdges = activeEdges.filter((ae) => {\n                if (ae.edge.ymax <= y) {\n                    return false;\n                }\n                return true;\n            });\n            activeEdges.sort((ae1, ae2) => {\n                if (ae1.edge.x === ae2.edge.x) {\n                    return 0;\n                }\n                return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n            });\n            // fill between the edges\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y]\n                    ]);\n                }\n            }\n            y += gap;\n            activeEdges.forEach((ae) => {\n                ae.edge.x = ae.edge.x + (gap * ae.edge.islope);\n            });\n        }\n    }\n    return lines;\n}\n"]},"metadata":{},"sourceType":"module"}