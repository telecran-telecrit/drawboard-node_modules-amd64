{"ast":null,"code":"import _slicedToArray from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { rotate } from \"../math\";\nimport { getShapeForElement } from \"../renderer/renderElement\"; // If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\n\nexport function getElementAbsoluteCoords(element) {\n  if (element.type === \"arrow\" || element.type === \"line\") {\n    return getLinearElementAbsoluteBounds(element);\n  }\n\n  return [element.x, element.y, element.x + element.width, element.y + element.height];\n}\nexport function getDiamondPoints(element) {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  var topX = Math.floor(element.width / 2) + 1;\n  var topY = 0;\n  var rightX = element.width;\n  var rightY = Math.floor(element.height / 2) + 1;\n  var bottomX = topX;\n  var bottomY = element.height;\n  var leftX = topY;\n  var leftY = rightY;\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n}\nexport function getLinearElementAbsoluteBounds(element) {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    var _element$points$reduc = element.points.reduce(function (limits, _ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          x = _ref2[0],\n          y = _ref2[1];\n\n      limits.minY = Math.min(limits.minY, y);\n      limits.minX = Math.min(limits.minX, x);\n      limits.maxX = Math.max(limits.maxX, x);\n      limits.maxY = Math.max(limits.maxY, y);\n      return limits;\n    }, {\n      minX: Infinity,\n      minY: Infinity,\n      maxX: -Infinity,\n      maxY: -Infinity\n    }),\n        _minX = _element$points$reduc.minX,\n        _minY = _element$points$reduc.minY,\n        _maxX = _element$points$reduc.maxX,\n        _maxY = _element$points$reduc.maxY;\n\n    return [_minX + element.x, _minY + element.y, _maxX + element.x, _maxY + element.y];\n  }\n\n  var shape = getShapeForElement(element); // first element is always the curve\n\n  var ops = shape[0].sets[0].ops;\n  var currentP = [0, 0];\n\n  var _ops$reduce = ops.reduce(function (limits, _ref3) {\n    var op = _ref3.op,\n        data = _ref3.data;\n\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = data; // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      var p1 = [data[0], data[1]];\n      var p2 = [data[2], data[3]];\n      var p3 = [data[4], data[5]];\n      var p0 = currentP;\n      currentP = p3;\n\n      var equation = function equation(t, idx) {\n        return Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n      };\n\n      var t = 0;\n\n      while (t <= 1.0) {\n        var x = equation(t, 0);\n        var y = equation(t, 1);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        t += 0.1;\n      }\n    } else if (op === \"lineTo\") {// TODO: Implement this\n    } else if (op === \"qcurveTo\") {// TODO: Implement this\n    }\n\n    return limits;\n  }, {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  }),\n      minX = _ops$reduce.minX,\n      minY = _ops$reduce.minY,\n      maxX = _ops$reduce.maxX,\n      maxY = _ops$reduce.maxY;\n\n  return [minX + element.x, minY + element.y, maxX + element.x, maxY + element.y];\n}\nexport function getArrowPoints(element, shape) {\n  var ops = shape[0].sets[0].ops;\n  var data = ops[ops.length - 1].data;\n  var p3 = [data[4], data[5]];\n  var p2 = [data[2], data[3]];\n  var p1 = [data[0], data[1]]; // we need to find p0 of the bezier curve\n  // it is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation\n\n  var prevOp = ops[ops.length - 2];\n  var p0 = [0, 0];\n\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  } // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n\n\n  var equation = function equation(t, idx) {\n    return Math.pow(1 - t, 3) * p3[idx] + 3 * t * Math.pow(1 - t, 2) * p2[idx] + 3 * Math.pow(t, 2) * (1 - t) * p1[idx] + p0[idx] * Math.pow(t, 3);\n  }; // we know the last point of the arrow\n\n\n  var x2 = p3[0],\n      y2 = p3[1]; // by using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases\n\n  var _ref4 = [equation(0.3, 0), equation(0.3, 1)],\n      x1 = _ref4[0],\n      y1 = _ref4[1]; // find the normalized direction vector based on the\n  // previously calculated points\n\n  var distance = Math.hypot(x2 - x1, y2 - y1);\n  var nx = (x2 - x1) / distance;\n  var ny = (y2 - y1) / distance;\n  var size = 30; // pixels\n\n  var arrowLength = element.points.reduce(function (total, _ref5, idx, points) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        cx = _ref6[0],\n        cy = _ref6[1];\n\n    var _ref7 = idx > 0 ? points[idx - 1] : [0, 0],\n        _ref8 = _slicedToArray(_ref7, 2),\n        px = _ref8[0],\n        py = _ref8[1];\n\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0); // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  // This value is selected by minizing a minmum size with the whole length of the arrow\n  // intead of last segment of the arrow\n\n  var minSize = Math.min(size, arrowLength / 2);\n  var xs = x2 - nx * minSize;\n  var ys = y2 - ny * minSize;\n  var angle = 20; // degrees\n\n  var _rotate = rotate(xs, ys, x2, y2, -angle * Math.PI / 180),\n      _rotate2 = _slicedToArray(_rotate, 2),\n      x3 = _rotate2[0],\n      y3 = _rotate2[1];\n\n  var _rotate3 = rotate(xs, ys, x2, y2, angle * Math.PI / 180),\n      _rotate4 = _slicedToArray(_rotate3, 2),\n      x4 = _rotate4[0],\n      y4 = _rotate4[1];\n\n  return [x2, y2, x3, y3, x4, y4];\n}\nexport function getCommonBounds(elements) {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n  elements.forEach(function (element) {\n    var _getElementAbsoluteCo = getElementAbsoluteCoords(element),\n        _getElementAbsoluteCo2 = _slicedToArray(_getElementAbsoluteCo, 4),\n        x1 = _getElementAbsoluteCo2[0],\n        y1 = _getElementAbsoluteCo2[1],\n        x2 = _getElementAbsoluteCo2[2],\n        y2 = _getElementAbsoluteCo2[3];\n\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n  return [minX, minY, maxX, maxY];\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/bounds.ts"],"names":["rotate","getShapeForElement","getElementAbsoluteCoords","element","type","getLinearElementAbsoluteBounds","x","y","width","height","getDiamondPoints","topX","Math","floor","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","points","length","reduce","limits","minY","min","minX","maxX","max","maxY","Infinity","shape","ops","sets","currentP","op","data","p1","p2","p3","p0","equation","t","idx","pow","getArrowPoints","prevOp","x2","y2","x1","y1","distance","hypot","nx","ny","size","arrowLength","total","cx","cy","px","py","minSize","xs","ys","angle","PI","x3","y3","x4","y4","getCommonBounds","elements","forEach"],"mappings":"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","sourcesContent":["import { ExcalidrawElement } from \"./types\";\nimport { rotate } from \"../math\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { Point } from \"roughjs/bin/geometry\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport function getElementAbsoluteCoords(element: ExcalidrawElement) {\n  if (element.type === \"arrow\" || element.type === \"line\") {\n    return getLinearElementAbsoluteBounds(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n}\n\nexport function getDiamondPoints(element: ExcalidrawElement) {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n}\n\nexport function getLinearElementAbsoluteBounds(element: ExcalidrawElement) {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = shape[0].sets[0].ops;\n\n  let currentP: Point = [0, 0];\n\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = data as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          const x = equation(t, 0);\n          const y = equation(t, 1);\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n}\n\nexport function getArrowPoints(element: ExcalidrawElement, shape: Drawable[]) {\n  const ops = shape[0].sets[0].ops;\n\n  const data = ops[ops.length - 1].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // we need to find p0 of the bezier curve\n  // it is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation\n  const prevOp = ops[ops.length - 2];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = prevOp.data as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // we know the last point of the arrow\n  const [x2, y2] = p3;\n\n  // by using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // find the normalized direction vector based on the\n  // previously calculated points\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = 30; // pixels\n  const arrowLength = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0);\n\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  // This value is selected by minizing a minmum size with the whole length of the arrow\n  // intead of last segment of the arrow\n  const minSize = Math.min(size, arrowLength / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x2, y2, x3, y3, x4, y4];\n}\n\nexport function getCommonBounds(elements: readonly ExcalidrawElement[]) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach(element => {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n}\n"]},"metadata":{},"sourceType":"module"}