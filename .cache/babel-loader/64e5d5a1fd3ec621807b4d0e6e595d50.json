{"ast":null,"code":"import _classCallCheck from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport var DashedFiller =\n/*#__PURE__*/\nfunction () {\n  function DashedFiller(helper) {\n    _classCallCheck(this, DashedFiller);\n\n    this.helper = helper;\n  }\n\n  _createClass(DashedFiller, [{\n    key: \"fillPolygon\",\n    value: function fillPolygon(points, o) {\n      var lines = polygonHachureLines(points, o);\n      return {\n        type: 'fillSketch',\n        ops: this.dashedLine(lines, o)\n      };\n    }\n  }, {\n    key: \"dashedLine\",\n    value: function dashedLine(lines, o) {\n      var _this = this;\n\n      var offset = o.dashOffset < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashOffset;\n      var gap = o.dashGap < 0 ? o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap : o.dashGap;\n      var ops = [];\n      lines.forEach(function (line) {\n        var length = lineLength(line);\n        var count = Math.floor(length / (offset + gap));\n        var startOffset = (length + gap - count * (offset + gap)) / 2;\n        var p1 = line[0];\n        var p2 = line[1];\n\n        if (p1[0] > p2[0]) {\n          p1 = line[1];\n          p2 = line[0];\n        }\n\n        var alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n\n        for (var i = 0; i < count; i++) {\n          var lstart = i * (offset + gap);\n          var lend = lstart + offset;\n          var start = [p1[0] + lstart * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha) + startOffset * Math.sin(alpha)];\n          var end = [p1[0] + lend * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lend * Math.sin(alpha) + startOffset * Math.sin(alpha)];\n          ops = ops.concat(_this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n        }\n      });\n      return ops;\n    }\n  }]);\n\n  return DashedFiller;\n}();","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/fillers/dashed-filler.js"],"names":["lineLength","polygonHachureLines","DashedFiller","helper","points","o","lines","type","ops","dashedLine","offset","dashOffset","hachureGap","strokeWidth","gap","dashGap","forEach","line","length","count","Math","floor","startOffset","p1","p2","alpha","atan","i","lstart","lend","start","cos","sin","end","concat","doubleLineOps"],"mappings":"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","sourcesContent":["import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        const lines = polygonHachureLines(points, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        let ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}