{"ast":null,"code":"import _classCallCheck from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { lineLength } from './geometry';\n\nfunction isType(token, type) {\n  return token.type === type;\n}\n\nvar PARAMS = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 4,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\n\nvar ParsedPath =\n/*#__PURE__*/\nfunction () {\n  function ParsedPath(d) {\n    _classCallCheck(this, ParsedPath);\n\n    this.COMMAND = 0;\n    this.NUMBER = 1;\n    this.EOD = 2;\n    this.segments = [];\n    this.parseData(d);\n    this.processPoints();\n  }\n\n  _createClass(ParsedPath, [{\n    key: \"tokenize\",\n    value: function tokenize(d) {\n      var tokens = new Array();\n\n      while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n          d = d.substr(RegExp.$1.length);\n        } else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n          tokens[tokens.length] = {\n            type: this.COMMAND,\n            text: RegExp.$1\n          };\n          d = d.substr(RegExp.$1.length);\n        } else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n          tokens[tokens.length] = {\n            type: this.NUMBER,\n            text: \"\".concat(parseFloat(RegExp.$1))\n          };\n          d = d.substr(RegExp.$1.length);\n        } else {\n          return [];\n        }\n      }\n\n      tokens[tokens.length] = {\n        type: this.EOD,\n        text: ''\n      };\n      return tokens;\n    }\n  }, {\n    key: \"parseData\",\n    value: function parseData(d) {\n      var tokens = this.tokenize(d);\n      var index = 0;\n      var token = tokens[index];\n      var mode = 'BOD';\n      this.segments = new Array();\n\n      while (!isType(token, this.EOD)) {\n        var param_length = void 0;\n        var params = new Array();\n\n        if (mode === 'BOD') {\n          if (token.text === 'M' || token.text === 'm') {\n            index++;\n            param_length = PARAMS[token.text];\n            mode = token.text;\n          } else {\n            this.parseData('M0,0' + d);\n            return;\n          }\n        } else {\n          if (isType(token, this.NUMBER)) {\n            param_length = PARAMS[mode];\n          } else {\n            index++;\n            param_length = PARAMS[token.text];\n            mode = token.text;\n          }\n        }\n\n        if (index + param_length < tokens.length) {\n          for (var i = index; i < index + param_length; i++) {\n            var numbeToken = tokens[i];\n\n            if (isType(numbeToken, this.NUMBER)) {\n              params[params.length] = +numbeToken.text;\n            } else {\n              console.error('Param not a number: ' + mode + ',' + numbeToken.text);\n              return;\n            }\n          }\n\n          if (typeof PARAMS[mode] === 'number') {\n            var segment = {\n              key: mode,\n              data: params\n            };\n            this.segments.push(segment);\n            index += param_length;\n            token = tokens[index];\n            if (mode === 'M') mode = 'L';\n            if (mode === 'm') mode = 'l';\n          } else {\n            console.error('Bad segment: ' + mode);\n            return;\n          }\n        } else {\n          console.error('Path data ended short');\n        }\n      }\n    }\n  }, {\n    key: \"processPoints\",\n    value: function processPoints() {\n      var first = null;\n      var currentPoint = [0, 0];\n\n      for (var i = 0; i < this.segments.length; i++) {\n        var s = this.segments[i];\n\n        switch (s.key) {\n          case 'M':\n          case 'L':\n          case 'T':\n            s.point = [s.data[0], s.data[1]];\n            break;\n\n          case 'm':\n          case 'l':\n          case 't':\n            s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n            break;\n\n          case 'H':\n            s.point = [s.data[0], currentPoint[1]];\n            break;\n\n          case 'h':\n            s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n            break;\n\n          case 'V':\n            s.point = [currentPoint[0], s.data[0]];\n            break;\n\n          case 'v':\n            s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n            break;\n\n          case 'z':\n          case 'Z':\n            if (first) {\n              s.point = [first[0], first[1]];\n            }\n\n            break;\n\n          case 'C':\n            s.point = [s.data[4], s.data[5]];\n            break;\n\n          case 'c':\n            s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n            break;\n\n          case 'S':\n            s.point = [s.data[2], s.data[3]];\n            break;\n\n          case 's':\n            s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n            break;\n\n          case 'Q':\n            s.point = [s.data[2], s.data[3]];\n            break;\n\n          case 'q':\n            s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n            break;\n\n          case 'A':\n            s.point = [s.data[5], s.data[6]];\n            break;\n\n          case 'a':\n            s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n            break;\n        }\n\n        if (s.key === 'm' || s.key === 'M') {\n          first = null;\n        }\n\n        if (s.point) {\n          currentPoint = s.point;\n\n          if (!first) {\n            first = s.point;\n          }\n        }\n\n        if (s.key === 'z' || s.key === 'Z') {\n          first = null;\n        }\n      }\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      if (typeof this._closed === 'undefined') {\n        this._closed = false;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.segments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var s = _step.value;\n\n            if (s.key.toLowerCase() === 'z') {\n              this._closed = true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return this._closed;\n    }\n  }]);\n\n  return ParsedPath;\n}();\n\nexport var RoughPath =\n/*#__PURE__*/\nfunction () {\n  function RoughPath(d) {\n    _classCallCheck(this, RoughPath);\n\n    this._position = [0, 0];\n    this._first = null;\n    this.bezierReflectionPoint = null;\n    this.quadReflectionPoint = null;\n    this.parsed = new ParsedPath(d);\n  }\n\n  _createClass(RoughPath, [{\n    key: \"setPosition\",\n    value: function setPosition(x, y) {\n      this._position = [x, y];\n\n      if (!this._first) {\n        this._first = [x, y];\n      }\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      return this.parsed.segments;\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this.parsed.closed;\n    }\n  }, {\n    key: \"linearPoints\",\n    get: function get() {\n      if (!this._linearPoints) {\n        var lp = [];\n        var points = [];\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.parsed.segments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var s = _step2.value;\n            var key = s.key.toLowerCase();\n\n            if (key === 'm' || key === 'z') {\n              if (points.length) {\n                lp.push(points);\n                points = [];\n              }\n\n              if (key === 'z') {\n                continue;\n              }\n            }\n\n            if (s.point) {\n              points.push(s.point);\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        if (points.length) {\n          lp.push(points);\n          points = [];\n        }\n\n        this._linearPoints = lp;\n      }\n\n      return this._linearPoints;\n    }\n  }, {\n    key: \"first\",\n    get: function get() {\n      return this._first;\n    },\n    set: function set(v) {\n      this._first = v;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this._position;\n    }\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this._position[0];\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this._position[1];\n    }\n  }]);\n\n  return RoughPath;\n}(); // Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\n\nexport var RoughArcConverter =\n/*#__PURE__*/\nfunction () {\n  function RoughArcConverter(from, to, radii, angle, largeArcFlag, sweepFlag) {\n    _classCallCheck(this, RoughArcConverter);\n\n    this._segIndex = 0;\n    this._numSegs = 0;\n    this._rx = 0;\n    this._ry = 0;\n    this._sinPhi = 0;\n    this._cosPhi = 0;\n    this._C = [0, 0];\n    this._theta = 0;\n    this._delta = 0;\n    this._T = 0;\n    this._from = from;\n\n    if (from[0] === to[0] && from[1] === to[1]) {\n      return;\n    }\n\n    var radPerDeg = Math.PI / 180;\n    this._rx = Math.abs(radii[0]);\n    this._ry = Math.abs(radii[1]);\n    this._sinPhi = Math.sin(angle * radPerDeg);\n    this._cosPhi = Math.cos(angle * radPerDeg);\n    var x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n    var y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n    var root = 0;\n    var numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n\n    if (numerator < 0) {\n      var s = Math.sqrt(1 - numerator / (this._rx * this._rx * this._ry * this._ry));\n      this._rx = this._rx * s;\n      this._ry = this._ry * s;\n      root = 0;\n    } else {\n      root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) * Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n    }\n\n    var cxdash = root * this._rx * y1dash / this._ry;\n    var cydash = -root * this._ry * x1dash / this._rx;\n    this._C = [0, 0];\n    this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n    this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n    this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n    var dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n\n    if (!sweepFlag && dtheta > 0) {\n      dtheta -= 2 * Math.PI;\n    } else if (sweepFlag && dtheta < 0) {\n      dtheta += 2 * Math.PI;\n    }\n\n    this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n    this._delta = dtheta / this._numSegs;\n    this._T = 8 / 3 * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n  }\n\n  _createClass(RoughArcConverter, [{\n    key: \"getNextSegment\",\n    value: function getNextSegment() {\n      if (this._segIndex === this._numSegs) {\n        return null;\n      }\n\n      var cosTheta1 = Math.cos(this._theta);\n      var sinTheta1 = Math.sin(this._theta);\n      var theta2 = this._theta + this._delta;\n      var cosTheta2 = Math.cos(theta2);\n      var sinTheta2 = Math.sin(theta2);\n      var to = [this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0], this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]];\n      var cp1 = [this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1), this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)];\n      var cp2 = [to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2), to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)];\n      this._theta = theta2;\n      this._from = [to[0], to[1]];\n      this._segIndex++;\n      return {\n        cp1: cp1,\n        cp2: cp2,\n        to: to\n      };\n    }\n  }, {\n    key: \"calculateVectorAngle\",\n    value: function calculateVectorAngle(ux, uy, vx, vy) {\n      var ta = Math.atan2(uy, ux);\n      var tb = Math.atan2(vy, vx);\n      if (tb >= ta) return tb - ta;\n      return 2 * Math.PI - (ta - tb);\n    }\n  }]);\n\n  return RoughArcConverter;\n}();\nexport var PathFitter =\n/*#__PURE__*/\nfunction () {\n  function PathFitter(sets, closed) {\n    _classCallCheck(this, PathFitter);\n\n    this.sets = sets;\n    this.closed = closed;\n  }\n\n  _createClass(PathFitter, [{\n    key: \"fit\",\n    value: function fit(simplification) {\n      var outSets = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.sets[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var set = _step3.value;\n          var length = set.length;\n          var estLength = Math.floor(simplification * length);\n\n          if (estLength < 5) {\n            if (length <= 5) {\n              continue;\n            }\n\n            estLength = 5;\n          }\n\n          outSets.push(this.reduce(set, estLength));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var d = '';\n\n      for (var _i = 0, _outSets = outSets; _i < _outSets.length; _i++) {\n        var _set = _outSets[_i];\n\n        for (var i = 0; i < _set.length; i++) {\n          var point = _set[i];\n\n          if (i === 0) {\n            d += 'M' + point[0] + ',' + point[1];\n          } else {\n            d += 'L' + point[0] + ',' + point[1];\n          }\n        }\n\n        if (this.closed) {\n          d += 'z ';\n        }\n      }\n\n      return d;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(set, count) {\n      if (set.length <= count) {\n        return set;\n      }\n\n      var points = set.slice(0);\n\n      while (points.length > count) {\n        var areas = [];\n        var minArea = -1;\n        var minIndex = -1;\n\n        for (var i = 1; i < points.length - 1; i++) {\n          var a = lineLength([points[i - 1], points[i]]);\n          var b = lineLength([points[i], points[i + 1]]);\n          var c = lineLength([points[i - 1], points[i + 1]]);\n          var s = (a + b + c) / 2.0;\n          var area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n          areas.push(area);\n\n          if (minArea < 0 || area < minArea) {\n            minArea = area;\n            minIndex = i;\n          }\n        }\n\n        if (minIndex > 0) {\n          points.splice(minIndex, 1);\n        } else {\n          break;\n        }\n      }\n\n      return points;\n    }\n  }]);\n\n  return PathFitter;\n}();","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/path.js"],"names":["lineLength","isType","token","type","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","ParsedPath","d","COMMAND","NUMBER","EOD","segments","parseData","processPoints","tokens","Array","match","substr","RegExp","$1","length","text","parseFloat","tokenize","index","mode","param_length","params","i","numbeToken","console","error","segment","key","data","push","first","currentPoint","point","_closed","toLowerCase","RoughPath","_position","_first","bezierReflectionPoint","quadReflectionPoint","parsed","x","y","closed","_linearPoints","lp","points","RoughArcConverter","from","to","radii","angle","largeArcFlag","sweepFlag","_segIndex","_numSegs","_rx","_ry","_sinPhi","_cosPhi","_C","_theta","_delta","_T","_from","radPerDeg","Math","PI","abs","sin","cos","x1dash","y1dash","root","numerator","sqrt","cxdash","cydash","calculateVectorAngle","dtheta","ceil","cosTheta1","sinTheta1","theta2","cosTheta2","sinTheta2","cp1","cp2","ux","uy","vx","vy","ta","atan2","tb","PathFitter","sets","simplification","outSets","set","estLength","floor","reduce","count","slice","areas","minArea","minIndex","b","area","splice"],"mappings":"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","sourcesContent":["import { lineLength } from './geometry';\nfunction isType(token, type) {\n    return token.type === type;\n}\nconst PARAMS = {\n    A: 7,\n    a: 7,\n    C: 6,\n    c: 6,\n    H: 1,\n    h: 1,\n    L: 2,\n    l: 2,\n    M: 2,\n    m: 2,\n    Q: 4,\n    q: 4,\n    S: 4,\n    s: 4,\n    T: 4,\n    t: 2,\n    V: 1,\n    v: 1,\n    Z: 0,\n    z: 0\n};\nclass ParsedPath {\n    constructor(d) {\n        this.COMMAND = 0;\n        this.NUMBER = 1;\n        this.EOD = 2;\n        this.segments = [];\n        this.parseData(d);\n        this.processPoints();\n    }\n    tokenize(d) {\n        const tokens = new Array();\n        while (d !== '') {\n            if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n                tokens[tokens.length] = { type: this.COMMAND, text: RegExp.$1 };\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n                tokens[tokens.length] = { type: this.NUMBER, text: `${parseFloat(RegExp.$1)}` };\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                return [];\n            }\n        }\n        tokens[tokens.length] = { type: this.EOD, text: '' };\n        return tokens;\n    }\n    parseData(d) {\n        const tokens = this.tokenize(d);\n        let index = 0;\n        let token = tokens[index];\n        let mode = 'BOD';\n        this.segments = new Array();\n        while (!isType(token, this.EOD)) {\n            let param_length;\n            const params = new Array();\n            if (mode === 'BOD') {\n                if (token.text === 'M' || token.text === 'm') {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n                else {\n                    this.parseData('M0,0' + d);\n                    return;\n                }\n            }\n            else {\n                if (isType(token, this.NUMBER)) {\n                    param_length = PARAMS[mode];\n                }\n                else {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n            }\n            if ((index + param_length) < tokens.length) {\n                for (let i = index; i < index + param_length; i++) {\n                    const numbeToken = tokens[i];\n                    if (isType(numbeToken, this.NUMBER)) {\n                        params[params.length] = +numbeToken.text;\n                    }\n                    else {\n                        console.error('Param not a number: ' + mode + ',' + numbeToken.text);\n                        return;\n                    }\n                }\n                if (typeof PARAMS[mode] === 'number') {\n                    const segment = { key: mode, data: params };\n                    this.segments.push(segment);\n                    index += param_length;\n                    token = tokens[index];\n                    if (mode === 'M')\n                        mode = 'L';\n                    if (mode === 'm')\n                        mode = 'l';\n                }\n                else {\n                    console.error('Bad segment: ' + mode);\n                    return;\n                }\n            }\n            else {\n                console.error('Path data ended short');\n            }\n        }\n    }\n    get closed() {\n        if (typeof this._closed === 'undefined') {\n            this._closed = false;\n            for (const s of this.segments) {\n                if (s.key.toLowerCase() === 'z') {\n                    this._closed = true;\n                }\n            }\n        }\n        return this._closed;\n    }\n    processPoints() {\n        let first = null;\n        let currentPoint = [0, 0];\n        for (let i = 0; i < this.segments.length; i++) {\n            const s = this.segments[i];\n            switch (s.key) {\n                case 'M':\n                case 'L':\n                case 'T':\n                    s.point = [s.data[0], s.data[1]];\n                    break;\n                case 'm':\n                case 'l':\n                case 't':\n                    s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n                    break;\n                case 'H':\n                    s.point = [s.data[0], currentPoint[1]];\n                    break;\n                case 'h':\n                    s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n                    break;\n                case 'V':\n                    s.point = [currentPoint[0], s.data[0]];\n                    break;\n                case 'v':\n                    s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n                    break;\n                case 'z':\n                case 'Z':\n                    if (first) {\n                        s.point = [first[0], first[1]];\n                    }\n                    break;\n                case 'C':\n                    s.point = [s.data[4], s.data[5]];\n                    break;\n                case 'c':\n                    s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n                    break;\n                case 'S':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 's':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'Q':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 'q':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'A':\n                    s.point = [s.data[5], s.data[6]];\n                    break;\n                case 'a':\n                    s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n                    break;\n            }\n            if (s.key === 'm' || s.key === 'M') {\n                first = null;\n            }\n            if (s.point) {\n                currentPoint = s.point;\n                if (!first) {\n                    first = s.point;\n                }\n            }\n            if (s.key === 'z' || s.key === 'Z') {\n                first = null;\n            }\n        }\n    }\n}\nexport class RoughPath {\n    constructor(d) {\n        this._position = [0, 0];\n        this._first = null;\n        this.bezierReflectionPoint = null;\n        this.quadReflectionPoint = null;\n        this.parsed = new ParsedPath(d);\n    }\n    get segments() {\n        return this.parsed.segments;\n    }\n    get closed() {\n        return this.parsed.closed;\n    }\n    get linearPoints() {\n        if (!this._linearPoints) {\n            const lp = [];\n            let points = [];\n            for (const s of this.parsed.segments) {\n                const key = s.key.toLowerCase();\n                if (key === 'm' || key === 'z') {\n                    if (points.length) {\n                        lp.push(points);\n                        points = [];\n                    }\n                    if (key === 'z') {\n                        continue;\n                    }\n                }\n                if (s.point) {\n                    points.push(s.point);\n                }\n            }\n            if (points.length) {\n                lp.push(points);\n                points = [];\n            }\n            this._linearPoints = lp;\n        }\n        return this._linearPoints;\n    }\n    get first() {\n        return this._first;\n    }\n    set first(v) {\n        this._first = v;\n    }\n    setPosition(x, y) {\n        this._position = [x, y];\n        if (!this._first) {\n            this._first = [x, y];\n        }\n    }\n    get position() {\n        return this._position;\n    }\n    get x() {\n        return this._position[0];\n    }\n    get y() {\n        return this._position[1];\n    }\n}\n// Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\nexport class RoughArcConverter {\n    constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n        this._segIndex = 0;\n        this._numSegs = 0;\n        this._rx = 0;\n        this._ry = 0;\n        this._sinPhi = 0;\n        this._cosPhi = 0;\n        this._C = [0, 0];\n        this._theta = 0;\n        this._delta = 0;\n        this._T = 0;\n        this._from = from;\n        if (from[0] === to[0] && from[1] === to[1]) {\n            return;\n        }\n        const radPerDeg = Math.PI / 180;\n        this._rx = Math.abs(radii[0]);\n        this._ry = Math.abs(radii[1]);\n        this._sinPhi = Math.sin(angle * radPerDeg);\n        this._cosPhi = Math.cos(angle * radPerDeg);\n        const x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n        const y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n        let root = 0;\n        const numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n        if (numerator < 0) {\n            const s = Math.sqrt(1 - (numerator / (this._rx * this._rx * this._ry * this._ry)));\n            this._rx = this._rx * s;\n            this._ry = this._ry * s;\n            root = 0;\n        }\n        else {\n            root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) *\n                Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n        }\n        const cxdash = root * this._rx * y1dash / this._ry;\n        const cydash = -root * this._ry * x1dash / this._rx;\n        this._C = [0, 0];\n        this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n        this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n        this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n        let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n        if ((!sweepFlag) && (dtheta > 0)) {\n            dtheta -= 2 * Math.PI;\n        }\n        else if (sweepFlag && (dtheta < 0)) {\n            dtheta += 2 * Math.PI;\n        }\n        this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n        this._delta = dtheta / this._numSegs;\n        this._T = (8 / 3) * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n    }\n    getNextSegment() {\n        if (this._segIndex === this._numSegs) {\n            return null;\n        }\n        const cosTheta1 = Math.cos(this._theta);\n        const sinTheta1 = Math.sin(this._theta);\n        const theta2 = this._theta + this._delta;\n        const cosTheta2 = Math.cos(theta2);\n        const sinTheta2 = Math.sin(theta2);\n        const to = [\n            this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0],\n            this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]\n        ];\n        const cp1 = [\n            this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1),\n            this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)\n        ];\n        const cp2 = [\n            to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2),\n            to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)\n        ];\n        this._theta = theta2;\n        this._from = [to[0], to[1]];\n        this._segIndex++;\n        return {\n            cp1: cp1,\n            cp2: cp2,\n            to: to\n        };\n    }\n    calculateVectorAngle(ux, uy, vx, vy) {\n        const ta = Math.atan2(uy, ux);\n        const tb = Math.atan2(vy, vx);\n        if (tb >= ta)\n            return tb - ta;\n        return 2 * Math.PI - (ta - tb);\n    }\n}\nexport class PathFitter {\n    constructor(sets, closed) {\n        this.sets = sets;\n        this.closed = closed;\n    }\n    fit(simplification) {\n        const outSets = [];\n        for (const set of this.sets) {\n            const length = set.length;\n            let estLength = Math.floor(simplification * length);\n            if (estLength < 5) {\n                if (length <= 5) {\n                    continue;\n                }\n                estLength = 5;\n            }\n            outSets.push(this.reduce(set, estLength));\n        }\n        let d = '';\n        for (const set of outSets) {\n            for (let i = 0; i < set.length; i++) {\n                const point = set[i];\n                if (i === 0) {\n                    d += 'M' + point[0] + ',' + point[1];\n                }\n                else {\n                    d += 'L' + point[0] + ',' + point[1];\n                }\n            }\n            if (this.closed) {\n                d += 'z ';\n            }\n        }\n        return d;\n    }\n    reduce(set, count) {\n        if (set.length <= count) {\n            return set;\n        }\n        const points = set.slice(0);\n        while (points.length > count) {\n            const areas = [];\n            let minArea = -1;\n            let minIndex = -1;\n            for (let i = 1; i < (points.length - 1); i++) {\n                const a = lineLength([points[i - 1], points[i]]);\n                const b = lineLength([points[i], points[i + 1]]);\n                const c = lineLength([points[i - 1], points[i + 1]]);\n                const s = (a + b + c) / 2.0;\n                const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n                areas.push(area);\n                if ((minArea < 0) || (area < minArea)) {\n                    minArea = area;\n                    minIndex = i;\n                }\n            }\n            if (minIndex > 0) {\n                points.splice(minIndex, 1);\n            }\n            else {\n                break;\n            }\n        }\n        return points;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}