{"ast":null,"code":"import { isTextElement } from \"../element/typeChecks\";\nimport { getDiamondPoints, getArrowPoints, getElementAbsoluteCoords } from \"../element/bounds\";\nimport { SVG_NS, distance } from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nconst CANVAS_PADDING = 20;\n\nfunction generateElementCanvas(element, zoom) {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\");\n  const isLinear = /\\b(arrow|line)\\b/.test(element.type);\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinear) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width = distance(x1, x2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height = distance(y1, y2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvasOffsetX = element.x > x1 ? Math.floor(distance(element.x, x1)) * window.devicePixelRatio : 0;\n    canvasOffsetY = element.y > y1 ? Math.floor(distance(element.y, y1)) * window.devicePixelRatio : 0;\n    context.translate(canvasOffsetX * zoom, canvasOffsetY * zoom);\n  } else {\n    canvas.width = element.width * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height = element.height * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n  }\n\n  context.translate(CANVAS_PADDING, CANVAS_PADDING);\n  context.scale(window.devicePixelRatio * zoom, window.devicePixelRatio * zoom);\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(-CANVAS_PADDING, -CANVAS_PADDING);\n  context.scale(1 / (window.devicePixelRatio * zoom), 1 / (window.devicePixelRatio * zoom));\n  return {\n    element,\n    canvas,\n    canvasZoom: zoom,\n    canvasOffsetX,\n    canvasOffsetY\n  };\n}\n\nfunction drawElementOnCanvas(element, rc, context) {\n  context.globalAlpha = element.opacity / 100;\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        rc.draw(getShapeForElement(element));\n        break;\n      }\n\n    case \"arrow\":\n    case \"line\":\n      {\n        getShapeForElement(element).forEach(shape => rc.draw(shape));\n        break;\n      }\n\n    default:\n      {\n        if (isTextElement(element)) {\n          const font = context.font;\n          context.font = element.font;\n          const fillStyle = context.fillStyle;\n          context.fillStyle = element.strokeColor;\n          const textAlign = context.textAlign;\n          context.textAlign = element.textAlign; // Canvas does not support multiline text by default\n\n          const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          const lineHeight = element.height / lines.length;\n          const verticalOffset = element.height - element.baseline;\n          const horizontalOffset = element.textAlign === \"center\" ? element.width / 2 : element.textAlign === \"right\" ? element.width : 0;\n\n          for (let i = 0; i < lines.length; i++) {\n            context.fillText(lines[i], 0 + horizontalOffset, (i + 1) * lineHeight - verticalOffset);\n          }\n\n          context.fillStyle = fillStyle;\n          context.font = font;\n          context.textAlign = textAlign;\n        } else {\n          throw new Error(`Unimplemented type ${element.type}`);\n        }\n      }\n  }\n\n  context.globalAlpha = 1;\n}\n\nconst elementWithCanvasCache = new WeakMap();\nconst shapeCache = new WeakMap();\nexport function getShapeForElement(element) {\n  return shapeCache.get(element);\n}\nexport function invalidateShapeForElement(element) {\n  shapeCache.delete(element);\n}\n\nfunction generateElement(element, generator, sceneState) {\n  let shape = shapeCache.get(element) || null;\n\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        shape = generator.rectangle(0, 0, element.width, element.height, {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed\n        });\n        break;\n\n      case \"diamond\":\n        {\n          const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);\n          shape = generator.polygon([[topX, topY], [rightX, rightY], [bottomX, bottomY], [leftX, leftY]], {\n            stroke: element.strokeColor,\n            fill: element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor,\n            fillStyle: element.fillStyle,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed\n          });\n          break;\n        }\n\n      case \"ellipse\":\n        shape = generator.ellipse(element.width / 2, element.height / 2, element.width, element.height, {\n          stroke: element.strokeColor,\n          fill: element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed,\n          curveFitting: 1\n        });\n        break;\n\n      case \"line\":\n      case \"arrow\":\n        {\n          const options = {\n            stroke: element.strokeColor,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed\n          }; // points array can be empty in the beginning, so it is important to add\n          // initial position to it\n\n          const points = element.points.length ? element.points : [[0, 0]]; // If shape is a line and is a closed shape,\n          // fill the shape if a color is set.\n\n          if (element.type === \"line\") {\n            if (isPathALoop(element.points)) {\n              options.fillStyle = element.fillStyle;\n              options.fill = element.backgroundColor === \"transparent\" ? undefined : element.backgroundColor;\n            }\n          } // curve is always the first element\n          // this simplifies finding the curve for an element\n\n\n          shape = [generator.curve(points, options)]; // add lines only in arrow\n\n          if (element.type === \"arrow\") {\n            const [x2, y2, x3, y3, x4, y4] = getArrowPoints(element, shape);\n            shape.push(...[generator.line(x3, y3, x2, y2, options), generator.line(x4, y4, x2, y2, options)]);\n          }\n\n          break;\n        }\n\n      case \"text\":\n        {\n          // just to ensure we don't regenerate element.canvas on rerenders\n          shape = [];\n          break;\n        }\n    }\n\n    shapeCache.set(element, shape);\n  }\n\n  const zoom = sceneState ? sceneState.zoom : 1;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom = prevElementWithCanvas && prevElementWithCanvas.canvasZoom !== zoom && !(sceneState === null || sceneState === void 0 ? void 0 : sceneState.shouldCacheIgnoreZoom);\n\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n\n  return prevElementWithCanvas;\n}\n\nfunction drawElementFromCanvas(elementWithCanvas, rc, context, sceneState) {\n  const element = elementWithCanvas.element;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n  context.drawImage(elementWithCanvas.canvas, -(x2 - x1) / 2 * window.devicePixelRatio - CANVAS_PADDING / elementWithCanvas.canvasZoom, -(y2 - y1) / 2 * window.devicePixelRatio - CANVAS_PADDING / elementWithCanvas.canvasZoom, elementWithCanvas.canvas.width / elementWithCanvas.canvasZoom, elementWithCanvas.canvas.height / elementWithCanvas.canvasZoom);\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n}\n\nexport function renderElement(element, rc, context, renderOptimizations, sceneState) {\n  const generator = rc.generator;\n\n  switch (element.type) {\n    case \"selection\":\n      {\n        context.translate(element.x + sceneState.scrollX, element.y + sceneState.scrollY);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n        context.fillRect(0, 0, element.width, element.height);\n        context.fillStyle = fillStyle;\n        context.translate(-element.x - sceneState.scrollX, -element.y - sceneState.scrollY);\n        break;\n      }\n\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"text\":\n      {\n        const elementWithCanvas = generateElement(element, generator, sceneState);\n\n        if (renderOptimizations) {\n          drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n        } else {\n          const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n          const cx = (x1 + x2) / 2 + sceneState.scrollX;\n          const cy = (y1 + y2) / 2 + sceneState.scrollY;\n          const shiftX = (x2 - x1) / 2 - (element.x - x1);\n          const shiftY = (y2 - y1) / 2 - (element.y - y1);\n          context.translate(cx, cy);\n          context.rotate(element.angle);\n          context.translate(-shiftX, -shiftY);\n          drawElementOnCanvas(element, rc, context);\n          context.translate(shiftX, shiftY);\n          context.rotate(-element.angle);\n          context.translate(-cx, -cy);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n  }\n}\nexport function renderElementToSvg(element, rsvg, svgRoot, offsetX, offsetY) {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = 180 * element.angle / Math.PI;\n  const generator = rsvg.generator;\n\n  switch (element.type) {\n    case \"selection\":\n      {\n        // Since this is used only during editing experience, which is canvas based,\n        // this should not happen\n        throw new Error(\"Selection rendering is not supported for SVG\");\n      }\n\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n      {\n        generateElement(element, generator);\n        const node = rsvg.draw(getShapeForElement(element));\n        const opacity = element.opacity / 100;\n\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n\n        node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n        svgRoot.appendChild(node);\n        break;\n      }\n\n    case \"line\":\n    case \"arrow\":\n      {\n        generateElement(element, generator);\n        const group = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n        const opacity = element.opacity / 100;\n        getShapeForElement(element).forEach(shape => {\n          const node = rsvg.draw(shape);\n\n          if (opacity !== 1) {\n            node.setAttribute(\"stroke-opacity\", `${opacity}`);\n            node.setAttribute(\"fill-opacity\", `${opacity}`);\n          }\n\n          node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n          group.appendChild(node);\n        });\n        svgRoot.appendChild(group);\n        break;\n      }\n\n    default:\n      {\n        if (isTextElement(element)) {\n          const opacity = element.opacity / 100;\n          const node = svgRoot.ownerDocument.createElementNS(SVG_NS, \"g\");\n\n          if (opacity !== 1) {\n            node.setAttribute(\"stroke-opacity\", `${opacity}`);\n            node.setAttribute(\"fill-opacity\", `${opacity}`);\n          }\n\n          node.setAttribute(\"transform\", `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`);\n          const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n          const lineHeight = element.height / lines.length;\n          const verticalOffset = element.height - element.baseline;\n          const horizontalOffset = element.textAlign === \"center\" ? element.width / 2 : element.textAlign === \"right\" ? element.width : 0;\n          const fontSplit = element.font.split(\" \").filter(d => !!d.trim());\n          let fontFamily = fontSplit[0];\n          let fontSize = \"20px\";\n\n          if (fontSplit.length > 1) {\n            fontFamily = fontSplit[1];\n            fontSize = fontSplit[0];\n          }\n\n          const textAnchor = element.textAlign === \"center\" ? \"middle\" : element.textAlign === \"right\" ? \"end\" : \"start\";\n\n          for (let i = 0; i < lines.length; i++) {\n            const text = svgRoot.ownerDocument.createElementNS(SVG_NS, \"text\");\n            text.textContent = lines[i];\n            text.setAttribute(\"x\", `${horizontalOffset}`);\n            text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n            text.setAttribute(\"font-family\", fontFamily);\n            text.setAttribute(\"font-size\", fontSize);\n            text.setAttribute(\"fill\", element.strokeColor);\n            text.setAttribute(\"text-anchor\", textAnchor);\n            node.appendChild(text);\n          }\n\n          svgRoot.appendChild(node);\n        } else {\n          // @ts-ignore\n          throw new Error(`Unimplemented type ${element.type}`);\n        }\n      }\n  }\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/renderer/renderElement.ts"],"names":["isTextElement","getDiamondPoints","getArrowPoints","getElementAbsoluteCoords","SVG_NS","distance","isPathALoop","rough","CANVAS_PADDING","generateElementCanvas","element","zoom","canvas","document","createElement","context","getContext","isLinear","test","type","canvasOffsetX","canvasOffsetY","x1","y1","x2","y2","width","window","devicePixelRatio","height","x","Math","floor","y","translate","scale","rc","drawElementOnCanvas","canvasZoom","globalAlpha","opacity","draw","getShapeForElement","forEach","shape","font","fillStyle","strokeColor","textAlign","lines","text","replace","split","lineHeight","length","verticalOffset","baseline","horizontalOffset","i","fillText","Error","elementWithCanvasCache","WeakMap","shapeCache","get","invalidateShapeForElement","delete","generateElement","generator","sceneState","rectangle","stroke","fill","backgroundColor","undefined","strokeWidth","roughness","seed","topX","topY","rightX","rightY","bottomX","bottomY","leftX","leftY","polygon","ellipse","curveFitting","options","points","curve","x3","y3","x4","y4","push","line","set","prevElementWithCanvas","shouldRegenerateBecauseZoom","shouldCacheIgnoreZoom","elementWithCanvas","drawElementFromCanvas","cx","scrollX","cy","scrollY","rotate","angle","drawImage","renderElement","renderOptimizations","fillRect","shiftX","shiftY","renderElementToSvg","rsvg","svgRoot","offsetX","offsetY","degree","PI","node","setAttribute","appendChild","group","ownerDocument","createElementNS","fontSplit","filter","d","trim","fontFamily","fontSize","textAnchor","textContent"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { isTextElement } from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getArrowPoints,\n  getElementAbsoluteCoords,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport { SVG_NS, distance } from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\n\nconst CANVAS_PADDING = 20;\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: number;\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nfunction generateElementCanvas(\n  element: NonDeletedExcalidrawElement,\n  zoom: number,\n): ExcalidrawElementWithCanvas {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n\n  const isLinear = /\\b(arrow|line)\\b/.test(element.type);\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinear) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) * window.devicePixelRatio\n        : 0;\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) * window.devicePixelRatio\n        : 0;\n    context.translate(canvasOffsetX * zoom, canvasOffsetY * zoom);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n  }\n\n  context.translate(CANVAS_PADDING, CANVAS_PADDING);\n  context.scale(window.devicePixelRatio * zoom, window.devicePixelRatio * zoom);\n\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(-CANVAS_PADDING, -CANVAS_PADDING);\n  context.scale(\n    1 / (window.devicePixelRatio * zoom),\n    1 / (window.devicePixelRatio * zoom),\n  );\n  return { element, canvas, canvasZoom: zoom, canvasOffsetX, canvasOffsetY };\n}\n\nfunction drawElementOnCanvas(\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"line\": {\n      (getShapeForElement(element) as Drawable[]).forEach((shape) =>\n        rc.draw(shape),\n      );\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const font = context.font;\n        context.font = element.font;\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        const textAlign = context.textAlign;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let i = 0; i < lines.length; i++) {\n          context.fillText(\n            lines[i],\n            0 + horizontalOffset,\n            (i + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n        context.textAlign = textAlign;\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n}\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport function getShapeForElement(element: ExcalidrawElement) {\n  return shapeCache.get(element);\n}\n\nexport function invalidateShapeForElement(element: ExcalidrawElement) {\n  shapeCache.delete(element);\n}\n\nfunction generateElement(\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n  sceneState?: SceneState,\n) {\n  let shape = shapeCache.get(element) || null;\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n    switch (element.type) {\n      case \"rectangle\":\n        shape = generator.rectangle(0, 0, element.width, element.height, {\n          stroke: element.strokeColor,\n          fill:\n            element.backgroundColor === \"transparent\"\n              ? undefined\n              : element.backgroundColor,\n          fillStyle: element.fillStyle,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed,\n        });\n\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          {\n            stroke: element.strokeColor,\n            fill:\n              element.backgroundColor === \"transparent\"\n                ? undefined\n                : element.backgroundColor,\n            fillStyle: element.fillStyle,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed,\n          },\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          {\n            stroke: element.strokeColor,\n            fill:\n              element.backgroundColor === \"transparent\"\n                ? undefined\n                : element.backgroundColor,\n            fillStyle: element.fillStyle,\n            strokeWidth: element.strokeWidth,\n            roughness: element.roughness,\n            seed: element.seed,\n            curveFitting: 1,\n          },\n        );\n        break;\n      case \"line\":\n      case \"arrow\": {\n        const options: Options = {\n          stroke: element.strokeColor,\n          strokeWidth: element.strokeWidth,\n          roughness: element.roughness,\n          seed: element.seed,\n        };\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // If shape is a line and is a closed shape,\n        // fill the shape if a color is set.\n        if (element.type === \"line\") {\n          if (isPathALoop(element.points)) {\n            options.fillStyle = element.fillStyle;\n            options.fill =\n              element.backgroundColor === \"transparent\"\n                ? undefined\n                : element.backgroundColor;\n          }\n        }\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        shape = [generator.curve(points as [number, number][], options)];\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const [x2, y2, x3, y3, x4, y4] = getArrowPoints(element, shape);\n          shape.push(\n            ...[\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ],\n          );\n        }\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n  const zoom = sceneState ? sceneState.zoom : 1;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom &&\n    !sceneState?.shouldCacheIgnoreZoom;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n}\n\nfunction drawElementFromCanvas(\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) {\n  const element = elementWithCanvas.element;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      CANVAS_PADDING / elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      CANVAS_PADDING / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n}\n\nexport function renderElement(\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      context.translate(\n        -element.x - sceneState.scrollX,\n        -element.y - sceneState.scrollY,\n      );\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"arrow\":\n    case \"text\": {\n      const elementWithCanvas = generateElement(element, generator, sceneState);\n\n      if (renderOptimizations) {\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n}\n\nexport function renderElementToSvg(\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElement(element, generator);\n      const node = rsvg.draw(getShapeForElement(element) as Drawable);\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"arrow\": {\n      generateElement(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = rsvg.draw(shape);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const fontSplit = element.font.split(\" \").filter((d) => !!d.trim());\n        let fontFamily = fontSplit[0];\n        let fontSize = \"20px\";\n        if (fontSplit.length > 1) {\n          fontFamily = fontSplit[1];\n          fontSize = fontSplit[0];\n        }\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", fontFamily);\n          text.setAttribute(\"font-size\", fontSize);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}