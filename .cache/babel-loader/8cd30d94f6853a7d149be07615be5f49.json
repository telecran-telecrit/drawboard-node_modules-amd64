{"ast":null,"code":"import { getSelectedElements } from \"./scene\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\nexport const probablySupportsClipboardReadText = \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\nexport const probablySupportsClipboardWriteText = \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\nexport const probablySupportsClipboardBlob = \"clipboard\" in navigator && \"write\" in navigator.clipboard && \"ClipboardItem\" in window && \"toBlob\" in HTMLCanvasElement.prototype;\nexport async function copyToAppClipboard(elements, appState) {\n  CLIPBOARD = JSON.stringify(getSelectedElements(elements, appState));\n\n  try {\n    // when copying to in-app clipboard, clear system clipboard so that if\n    //  system clip contains text on paste we know it was copied *after* user\n    //  copied elements, and thus we should prefer the text content.\n    await copyTextToSystemClipboard(null);\n    PREFER_APP_CLIPBOARD = false;\n  } catch {\n    // if clearing system clipboard didn't work, we should prefer in-app\n    //  clipboard even if there's text in system clipboard on paste, because\n    //  we can't be sure of the order of copy operations\n    PREFER_APP_CLIPBOARD = true;\n  }\n}\nexport function getAppClipboard() {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    const clipboardElements = JSON.parse(CLIPBOARD);\n\n    if (Array.isArray(clipboardElements) && clipboardElements.length > 0 && clipboardElements[0].type // need to implement a better check here...\n    ) {\n        return {\n          elements: clipboardElements\n        };\n      }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return {};\n}\nexport async function getClipboardContent(event) {\n  try {\n    var _event$clipboardData;\n\n    const text = event ? (_event$clipboardData = event.clipboardData) === null || _event$clipboardData === void 0 ? void 0 : _event$clipboardData.getData(\"text/plain\").trim() : probablySupportsClipboardReadText && (await navigator.clipboard.readText());\n\n    if (text && !PREFER_APP_CLIPBOARD && !text.includes(SVG_EXPORT_TAG)) {\n      return {\n        text\n      };\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return getAppClipboard();\n}\nexport async function copyCanvasToClipboardAsPng(canvas) {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob(async function (blob) {\n        try {\n          await navigator.clipboard.write([new window.ClipboardItem({\n            \"image/png\": blob\n          })]);\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\nexport async function copyCanvasToClipboardAsSvg(svgroot) {\n  try {\n    await navigator.clipboard.writeText(svgroot.outerHTML);\n  } catch (error) {\n    console.error(error);\n  }\n}\nexport async function copyTextToSystemClipboard(text) {\n  let copied = false;\n\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      //  not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  } // Note that execCommand doesn't allow copying empty strings, so if we're\n  //  clearing clipboard using this API, we must copy at least an empty char\n\n\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n} // adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\n\nfunction copyTextViaExecCommand(text) {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n  const textarea = document.createElement(\"textarea\");\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`; // Prevent zooming on iOS\n\n  textarea.style.fontSize = \"12pt\";\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n  document.body.appendChild(textarea);\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n  return success;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/clipboard.ts"],"names":["getSelectedElements","SVG_EXPORT_TAG","CLIPBOARD","PREFER_APP_CLIPBOARD","probablySupportsClipboardReadText","navigator","clipboard","probablySupportsClipboardWriteText","probablySupportsClipboardBlob","window","HTMLCanvasElement","prototype","copyToAppClipboard","elements","appState","JSON","stringify","copyTextToSystemClipboard","getAppClipboard","clipboardElements","parse","Array","isArray","length","type","error","console","getClipboardContent","event","text","clipboardData","getData","trim","readText","includes","copyCanvasToClipboardAsPng","canvas","Promise","resolve","reject","toBlob","blob","write","ClipboardItem","copyCanvasToClipboardAsSvg","svgroot","writeText","outerHTML","copied","copyTextViaExecCommand","Error","isRTL","document","documentElement","getAttribute","textarea","createElement","style","border","padding","margin","position","yPosition","pageYOffset","scrollTop","top","fontSize","setAttribute","value","body","appendChild","success","select","setSelectionRange","execCommand","remove"],"mappings":"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","sourcesContent":["import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { getSelectedElements } from \"./scene\";\nimport { AppState } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nexport async function copyToAppClipboard(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) {\n  CLIPBOARD = JSON.stringify(getSelectedElements(elements, appState));\n  try {\n    // when copying to in-app clipboard, clear system clipboard so that if\n    //  system clip contains text on paste we know it was copied *after* user\n    //  copied elements, and thus we should prefer the text content.\n    await copyTextToSystemClipboard(null);\n    PREFER_APP_CLIPBOARD = false;\n  } catch {\n    // if clearing system clipboard didn't work, we should prefer in-app\n    //  clipboard even if there's text in system clipboard on paste, because\n    //  we can't be sure of the order of copy operations\n    PREFER_APP_CLIPBOARD = true;\n  }\n}\n\nexport function getAppClipboard(): {\n  elements?: readonly ExcalidrawElement[];\n} {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    const clipboardElements = JSON.parse(CLIPBOARD);\n\n    if (\n      Array.isArray(clipboardElements) &&\n      clipboardElements.length > 0 &&\n      clipboardElements[0].type // need to implement a better check here...\n    ) {\n      return { elements: clipboardElements };\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return {};\n}\n\nexport async function getClipboardContent(\n  event: ClipboardEvent | null,\n): Promise<{\n  text?: string;\n  elements?: readonly ExcalidrawElement[];\n}> {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\").trim()\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    if (text && !PREFER_APP_CLIPBOARD && !text.includes(SVG_EXPORT_TAG)) {\n      return { text };\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return getAppClipboard();\n}\n\nexport async function copyCanvasToClipboardAsPng(canvas: HTMLCanvasElement) {\n  return new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob(async function (blob: any) {\n        try {\n          await navigator.clipboard.write([\n            new window.ClipboardItem({ \"image/png\": blob }),\n          ]);\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nexport async function copyCanvasToClipboardAsSvg(svgroot: SVGSVGElement) {\n  try {\n    await navigator.clipboard.writeText(svgroot.outerHTML);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nexport async function copyTextToSystemClipboard(text: string | null) {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      //  not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  //  clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n}\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nfunction copyTextViaExecCommand(text: string) {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n}\n"]},"metadata":{},"sourceType":"module"}