{"ast":null,"code":"function swap(elements, indexA, indexB) {\n  var element = elements[indexA];\n  elements[indexA] = elements[indexB];\n  elements[indexB] = element;\n}\n\nexport function moveOneLeft(elements, indicesToMove) {\n  indicesToMove.sort(function (a, b) {\n    return a - b;\n  });\n  var isSorted = true; // We go from left to right to avoid overriding the wrong elements\n\n  indicesToMove.forEach(function (index, i) {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === i;\n\n    if (isSorted) {\n      return;\n    }\n\n    swap(elements, index - 1, index);\n  });\n  return elements;\n}\nexport function moveOneRight(elements, indicesToMove) {\n  var reversedIndicesToMove = indicesToMove.sort(function (a, b) {\n    return b - a;\n  });\n  var isSorted = true; // We go from right to left to avoid overriding the wrong elements\n\n  reversedIndicesToMove.forEach(function (index, i) {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === elements.length - i - 1;\n\n    if (isSorted) {\n      return;\n    }\n\n    swap(elements, index + 1, index);\n  });\n  return elements;\n} // Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [c, f, a, b, d, e, g]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the right.\n//\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//          -> ->\n//\n// which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//\n// Now, we need to move all the elements from marker 1 to the beginning by two (not one)\n// slots to the right, which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//  ---|--^  ^\n//     ------|\n//\n// which gives us\n//\n//        |1       |0\n// [_, _, a, b, d, e, g]\n//\n// At this point, we can fill back the leftmost elements with the array we saved at\n// the beginning\n//\n//        |1       |0\n// [c, f, a, b, d, e, g]\n//\n// And we are done!\n\nexport function moveAllLeft(elements, indicesToMove) {\n  indicesToMove.sort(function (a, b) {\n    return a - b;\n  }); // Copy the elements to move\n\n  var leftMostElements = indicesToMove.map(function (index) {\n    return elements[index];\n  });\n  var reversedIndicesToMove = indicesToMove // We go from right to left to avoid overriding elements.\n  .reverse() // We add 0 for the final marker\n  .concat([0]);\n  reversedIndicesToMove.forEach(function (index, i) {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    } // We go from the next marker to the right (i - 1) to the current one (index)\n\n\n    for (var pos = reversedIndicesToMove[i - 1] - 1; pos >= index; --pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos + i] = elements[pos];\n    }\n  }); // The final step\n\n  leftMostElements.forEach(function (element, i) {\n    elements[i] = element;\n  });\n  return elements;\n} // Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [a, b, d, e, g, c, f]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the left.\n//\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//          <- <-\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//\n// Now, we need to move all the elements from marker 1 to the end by two (not one)\n// slots to the left, which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//              ^------\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, g, _, _]\n//\n// At this point, we can fill back the rightmost elements with the array we saved at\n// the beginning\n//\n//        |0       |1\n// [a, b, d, e, g, c, f]\n//\n// And we are done!\n\nexport function moveAllRight(elements, indicesToMove) {\n  var reversedIndicesToMove = indicesToMove.sort(function (a, b) {\n    return b - a;\n  }); // Copy the elements to move\n\n  var rightMostElements = reversedIndicesToMove.map(function (index) {\n    return elements[index];\n  });\n  indicesToMove = reversedIndicesToMove // We go from left to right to avoid overriding elements.\n  .reverse() // We last element index for the final marker\n  .concat([elements.length]);\n  indicesToMove.forEach(function (index, i) {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    } // We go from the next marker to the left (i - 1) to the current one (index)\n\n\n    for (var pos = indicesToMove[i - 1] + 1; pos < index; ++pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos - i] = elements[pos];\n    }\n  }); // The final step\n\n  rightMostElements.forEach(function (element, i) {\n    elements[elements.length - i - 1] = element;\n  });\n  return elements;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/zindex.ts"],"names":["swap","elements","indexA","indexB","element","moveOneLeft","indicesToMove","sort","a","b","isSorted","forEach","index","i","moveOneRight","reversedIndicesToMove","length","moveAllLeft","leftMostElements","map","reverse","concat","pos","moveAllRight","rightMostElements"],"mappings":"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","sourcesContent":["function swap<T>(elements: T[], indexA: number, indexB: number) {\n  const element = elements[indexA];\n  elements[indexA] = elements[indexB];\n  elements[indexB] = element;\n}\n\nexport function moveOneLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n  let isSorted = true;\n  // We go from left to right to avoid overriding the wrong elements\n  indicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === i;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index - 1, index);\n  });\n\n  return elements;\n}\n\nexport function moveOneRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a,\n  );\n  let isSorted = true;\n\n  // We go from right to left to avoid overriding the wrong elements\n  reversedIndicesToMove.forEach((index, i) => {\n    // We don't want to bubble the first elements that are sorted as they are\n    // already in their correct position\n    isSorted = isSorted && index === elements.length - i - 1;\n    if (isSorted) {\n      return;\n    }\n    swap(elements, index + 1, index);\n  });\n  return elements;\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [c, f, a, b, d, e, g]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the right.\n//\n//        |1       |0\n// [a, b, _, d, e, _, g]\n//          -> ->\n//\n// which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//\n// Now, we need to move all the elements from marker 1 to the beginning by two (not one)\n// slots to the right, which gives us\n//\n//        |1       |0\n// [a, b, _, _, d, e, g]\n//  ---|--^  ^\n//     ------|\n//\n// which gives us\n//\n//        |1       |0\n// [_, _, a, b, d, e, g]\n//\n// At this point, we can fill back the leftmost elements with the array we saved at\n// the beginning\n//\n//        |1       |0\n// [c, f, a, b, d, e, g]\n//\n// And we are done!\nexport function moveAllLeft<T>(elements: T[], indicesToMove: number[]) {\n  indicesToMove.sort((a: number, b: number) => a - b);\n\n  // Copy the elements to move\n  const leftMostElements = indicesToMove.map(index => elements[index]);\n\n  const reversedIndicesToMove = indicesToMove\n    // We go from right to left to avoid overriding elements.\n    .reverse()\n    // We add 0 for the final marker\n    .concat([0]);\n\n  reversedIndicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the right (i - 1) to the current one (index)\n    for (let pos = reversedIndicesToMove[i - 1] - 1; pos >= index; --pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos + i] = elements[pos];\n    }\n  });\n\n  // The final step\n  leftMostElements.forEach((element, i) => {\n    elements[i] = element;\n  });\n\n  return elements;\n}\n\n// Let's go through an example\n//        |        |\n// [a, b, c, d, e, f, g]\n// -->\n// [a, b, d, e, g, c, f]\n//\n// We are going to override all the elements we want to move, so we keep them in an array\n// that we will restore at the end.\n// [c, f]\n//\n// From now on, we'll never read those values from the array anymore\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//\n// The idea is that we want to shift all the elements between the marker 0 and 1\n// by one slot to the left.\n//\n//        |0       |1\n// [a, b, _, d, e, _, g]\n//          <- <-\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//\n// Now, we need to move all the elements from marker 1 to the end by two (not one)\n// slots to the left, which gives us\n//\n//        |0       |1\n// [a, b, d, e, _, _, g]\n//              ^------\n//\n// which gives us\n//\n//        |0       |1\n// [a, b, d, e, g, _, _]\n//\n// At this point, we can fill back the rightmost elements with the array we saved at\n// the beginning\n//\n//        |0       |1\n// [a, b, d, e, g, c, f]\n//\n// And we are done!\nexport function moveAllRight<T>(elements: T[], indicesToMove: number[]) {\n  const reversedIndicesToMove = indicesToMove.sort(\n    (a: number, b: number) => b - a,\n  );\n\n  // Copy the elements to move\n  const rightMostElements = reversedIndicesToMove.map(index => elements[index]);\n\n  indicesToMove = reversedIndicesToMove\n    // We go from left to right to avoid overriding elements.\n    .reverse()\n    // We last element index for the final marker\n    .concat([elements.length]);\n\n  indicesToMove.forEach((index, i) => {\n    // We skip the first one as it is not paired with anything else\n    if (i === 0) {\n      return;\n    }\n\n    // We go from the next marker to the left (i - 1) to the current one (index)\n    for (let pos = indicesToMove[i - 1] + 1; pos < index; ++pos) {\n      // We move by 1 the first time, 2 the second... So we can use the index i in the array\n      elements[pos - i] = elements[pos];\n    }\n  });\n\n  // The final step\n  rightMostElements.forEach((element, i) => {\n    elements[elements.length - i - 1] = element;\n  });\n\n  return elements;\n}\n"]},"metadata":{},"sourceType":"module"}