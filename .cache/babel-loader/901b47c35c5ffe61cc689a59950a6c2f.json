{"ast":null,"code":"import _classCallCheck from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/pro/Solutions/drawboard-light/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { SVGNS } from './core';\nimport { line as _line, solidFillPolygon, patternFillPolygon, rectangle as _rectangle, ellipseWithParams, generateEllipseParams, linearPath as _linearPath, arc as _arc, patternFillArc, curve as _curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math';\nvar hasSelf = typeof self !== 'undefined';\nvar NOS = 'none';\nexport var RoughGenerator =\n/*#__PURE__*/\nfunction () {\n  function RoughGenerator(config, surface) {\n    _classCallCheck(this, RoughGenerator);\n\n    this.defaultOptions = {\n      maxRandomnessOffset: 2,\n      roughness: 1,\n      bowing: 1,\n      stroke: '#000',\n      strokeWidth: 1,\n      curveTightness: 0,\n      curveFitting: 0.95,\n      curveStepCount: 9,\n      fillStyle: 'hachure',\n      fillWeight: -1,\n      hachureAngle: -41,\n      hachureGap: -1,\n      dashOffset: -1,\n      dashGap: -1,\n      zigzagOffset: -1,\n      seed: 0,\n      roughnessGain: 1\n    };\n    this.config = config || {};\n    this.surface = surface;\n\n    if (this.config.options) {\n      this.defaultOptions = this._options(this.config.options);\n    }\n  }\n\n  _createClass(RoughGenerator, [{\n    key: \"_options\",\n    value: function _options(options) {\n      return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n  }, {\n    key: \"_drawable\",\n    value: function _drawable(shape, sets, options) {\n      return {\n        shape: shape,\n        sets: sets || [],\n        options: options || this.defaultOptions\n      };\n    }\n  }, {\n    key: \"line\",\n    value: function line(x1, y1, x2, y2, options) {\n      var o = this._options(options);\n\n      return this._drawable('line', [_line(x1, y1, x2, y2, o)], o);\n    }\n  }, {\n    key: \"rectangle\",\n    value: function rectangle(x, y, width, height, options) {\n      var o = this._options(options);\n\n      var paths = [];\n\n      var outline = _rectangle(x, y, width, height, o);\n\n      if (o.fill) {\n        var points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon(points, o));\n        } else {\n          paths.push(patternFillPolygon(points, o));\n        }\n      }\n\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n\n      return this._drawable('rectangle', paths, o);\n    }\n  }, {\n    key: \"ellipse\",\n    value: function ellipse(x, y, width, height, options) {\n      var o = this._options(options);\n\n      var paths = [];\n      var ellipseParams = generateEllipseParams(width, height, o);\n      var ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n\n      if (o.fill) {\n        if (o.fillStyle === 'solid') {\n          var shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n          shape.type = 'fillPath';\n          paths.push(shape);\n        } else {\n          paths.push(patternFillPolygon(ellipseResponse.estimatedPoints, o));\n        }\n      }\n\n      if (o.stroke !== NOS) {\n        paths.push(ellipseResponse.opset);\n      }\n\n      return this._drawable('ellipse', paths, o);\n    }\n  }, {\n    key: \"circle\",\n    value: function circle(x, y, diameter, options) {\n      var ret = this.ellipse(x, y, diameter, diameter, options);\n      ret.shape = 'circle';\n      return ret;\n    }\n  }, {\n    key: \"linearPath\",\n    value: function linearPath(points, options) {\n      var o = this._options(options);\n\n      return this._drawable('linearPath', [_linearPath(points, false, o)], o);\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(x, y, width, height, start, stop) {\n      var closed = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var options = arguments.length > 7 ? arguments[7] : undefined;\n\n      var o = this._options(options);\n\n      var paths = [];\n\n      var outline = _arc(x, y, width, height, start, stop, closed, true, o);\n\n      if (closed && o.fill) {\n        if (o.fillStyle === 'solid') {\n          var shape = _arc(x, y, width, height, start, stop, true, false, o);\n\n          shape.type = 'fillPath';\n          paths.push(shape);\n        } else {\n          paths.push(patternFillArc(x, y, width, height, start, stop, o));\n        }\n      }\n\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n\n      return this._drawable('arc', paths, o);\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(points, options) {\n      var o = this._options(options);\n\n      return this._drawable('curve', [_curve(points, o)], o);\n    }\n  }, {\n    key: \"polygon\",\n    value: function polygon(points, options) {\n      var o = this._options(options);\n\n      var paths = [];\n\n      var outline = _linearPath(points, true, o);\n\n      if (o.fill) {\n        if (o.fillStyle === 'solid') {\n          paths.push(solidFillPolygon(points, o));\n        } else {\n          paths.push(patternFillPolygon(points, o));\n        }\n      }\n\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n\n      return this._drawable('polygon', paths, o);\n    }\n  }, {\n    key: \"path\",\n    value: function path(d, options) {\n      var o = this._options(options);\n\n      var paths = [];\n\n      if (!d) {\n        return this._drawable('path', paths, o);\n      }\n\n      var outline = svgPath(d, o);\n\n      if (o.fill) {\n        if (o.fillStyle === 'solid') {\n          var shape = {\n            type: 'path2Dfill',\n            path: d,\n            ops: []\n          };\n          paths.push(shape);\n        } else {\n          var size = this.computePathSize(d);\n          var points = [[0, 0], [size[0], 0], [size[0], size[1]], [0, size[1]]];\n\n          var _shape = patternFillPolygon(points, o);\n\n          _shape.type = 'path2Dpattern';\n          _shape.size = size;\n          _shape.path = d;\n          paths.push(_shape);\n        }\n      }\n\n      if (o.stroke !== NOS) {\n        paths.push(outline);\n      }\n\n      return this._drawable('path', paths, o);\n    }\n  }, {\n    key: \"computePathSize\",\n    value: function computePathSize(d) {\n      var size = [0, 0];\n\n      if (hasSelf && self.document) {\n        try {\n          var svg = self.document.createElementNS(SVGNS, 'svg');\n          svg.setAttribute('width', '0');\n          svg.setAttribute('height', '0');\n          var pathNode = self.document.createElementNS(SVGNS, 'path');\n          pathNode.setAttribute('d', d);\n          svg.appendChild(pathNode);\n          self.document.body.appendChild(svg);\n          var bb = pathNode.getBBox();\n\n          if (bb) {\n            size[0] = bb.width || 0;\n            size[1] = bb.height || 0;\n          }\n\n          self.document.body.removeChild(svg);\n        } catch (err) {}\n      }\n\n      var canvasSize = this.getCanvasSize();\n\n      if (!(size[0] * size[1])) {\n        size = canvasSize;\n      }\n\n      return size;\n    }\n  }, {\n    key: \"getCanvasSize\",\n    value: function getCanvasSize() {\n      var val = function val(w) {\n        if (w && typeof w === 'object') {\n          if (w.baseVal && w.baseVal.value) {\n            return w.baseVal.value;\n          }\n        }\n\n        return w || 100;\n      };\n\n      if (this.surface) {\n        return [val(this.surface.width), val(this.surface.height)];\n      }\n\n      return [100, 100];\n    }\n  }, {\n    key: \"opsToPath\",\n    value: function opsToPath(drawing) {\n      var path = '';\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = drawing.ops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var item = _step.value;\n          var data = item.data;\n\n          switch (item.op) {\n            case 'move':\n              path += \"M\".concat(data[0], \" \").concat(data[1], \" \");\n              break;\n\n            case 'bcurveTo':\n              path += \"C\".concat(data[0], \" \").concat(data[1], \", \").concat(data[2], \" \").concat(data[3], \", \").concat(data[4], \" \").concat(data[5], \" \");\n              break;\n\n            case 'qcurveTo':\n              path += \"Q\".concat(data[0], \" \").concat(data[1], \", \").concat(data[2], \" \").concat(data[3], \" \");\n              break;\n\n            case 'lineTo':\n              path += \"L\".concat(data[0], \" \").concat(data[1], \" \");\n              break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return path.trim();\n    }\n  }, {\n    key: \"toPaths\",\n    value: function toPaths(drawable) {\n      var sets = drawable.sets || [];\n      var o = drawable.options || this.defaultOptions;\n      var paths = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = sets[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var drawing = _step2.value;\n          var path = null;\n\n          switch (drawing.type) {\n            case 'path':\n              path = {\n                d: this.opsToPath(drawing),\n                stroke: o.stroke,\n                strokeWidth: o.strokeWidth,\n                fill: NOS\n              };\n              break;\n\n            case 'fillPath':\n              path = {\n                d: this.opsToPath(drawing),\n                stroke: NOS,\n                strokeWidth: 0,\n                fill: o.fill || NOS\n              };\n              break;\n\n            case 'fillSketch':\n              path = this.fillSketch(drawing, o);\n              break;\n\n            case 'path2Dfill':\n              path = {\n                d: drawing.path || '',\n                stroke: NOS,\n                strokeWidth: 0,\n                fill: o.fill || NOS\n              };\n              break;\n\n            case 'path2Dpattern':\n              {\n                var size = drawing.size;\n                var pattern = {\n                  x: 0,\n                  y: 0,\n                  width: 1,\n                  height: 1,\n                  viewBox: \"0 0 \".concat(Math.round(size[0]), \" \").concat(Math.round(size[1])),\n                  patternUnits: 'objectBoundingBox',\n                  path: this.fillSketch(drawing, o)\n                };\n                path = {\n                  d: drawing.path,\n                  stroke: NOS,\n                  strokeWidth: 0,\n                  pattern: pattern\n                };\n                break;\n              }\n          }\n\n          if (path) {\n            paths.push(path);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return paths;\n    }\n  }, {\n    key: \"fillSketch\",\n    value: function fillSketch(drawing, o) {\n      var fweight = o.fillWeight;\n\n      if (fweight < 0) {\n        fweight = o.strokeWidth / 2;\n      }\n\n      return {\n        d: this.opsToPath(drawing),\n        stroke: o.fill || NOS,\n        strokeWidth: fweight,\n        fill: NOS\n      };\n    }\n  }], [{\n    key: \"newSeed\",\n    value: function newSeed() {\n      return randomSeed();\n    }\n  }]);\n\n  return RoughGenerator;\n}();","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/node_modules/roughjs/bin/generator.js"],"names":["SVGNS","line","solidFillPolygon","patternFillPolygon","rectangle","ellipseWithParams","generateEllipseParams","linearPath","arc","patternFillArc","curve","svgPath","randomSeed","hasSelf","self","NOS","RoughGenerator","config","surface","defaultOptions","maxRandomnessOffset","roughness","bowing","stroke","strokeWidth","curveTightness","curveFitting","curveStepCount","fillStyle","fillWeight","hachureAngle","hachureGap","dashOffset","dashGap","zigzagOffset","seed","roughnessGain","options","_options","Object","assign","shape","sets","x1","y1","x2","y2","o","_drawable","x","y","width","height","paths","outline","fill","points","push","ellipseParams","ellipseResponse","opset","type","estimatedPoints","diameter","ret","ellipse","start","stop","closed","d","path","ops","size","computePathSize","document","svg","createElementNS","setAttribute","pathNode","appendChild","body","bb","getBBox","removeChild","err","canvasSize","getCanvasSize","val","w","baseVal","value","drawing","item","data","op","trim","drawable","opsToPath","fillSketch","pattern","viewBox","Math","round","patternUnits","fweight"],"mappings":"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","sourcesContent":["import { SVGNS } from './core';\nimport { line, solidFillPolygon, patternFillPolygon, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math';\nconst hasSelf = typeof self !== 'undefined';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config, surface) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            roughnessGain: 1\n        };\n        this.config = config || {};\n        this.surface = surface;\n        if (this.config.options) {\n            this.defaultOptions = this._options(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _options(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _drawable(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygon(ellipseResponse.estimatedPoints, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._drawable('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [curve(points, o)], o);\n    }\n    polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        const outline = svgPath(d, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('path', paths, o);\n    }\n    computePathSize(d) {\n        let size = [0, 0];\n        if (hasSelf && self.document) {\n            try {\n                const svg = self.document.createElementNS(SVGNS, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(SVGNS, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                self.document.body.appendChild(svg);\n                const bb = pathNode.getBBox();\n                if (bb) {\n                    size[0] = bb.width || 0;\n                    size[1] = bb.height || 0;\n                }\n                self.document.body.removeChild(svg);\n            }\n            catch (err) { }\n        }\n        const canvasSize = this.getCanvasSize();\n        if (!(size[0] * size[1])) {\n            size = canvasSize;\n        }\n        return size;\n    }\n    getCanvasSize() {\n        const val = (w) => {\n            if (w && typeof w === 'object') {\n                if (w.baseVal && w.baseVal.value) {\n                    return w.baseVal.value;\n                }\n            }\n            return w || 100;\n        };\n        if (this.surface) {\n            return [val(this.surface.width), val(this.surface.height)];\n        }\n        return [100, 100];\n    }\n    opsToPath(drawing) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'qcurveTo':\n                    path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n                case 'path2Dfill':\n                    path = {\n                        d: drawing.path || '',\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS\n                    };\n                    break;\n                case 'path2Dpattern': {\n                    const size = drawing.size;\n                    const pattern = {\n                        x: 0, y: 0, width: 1, height: 1,\n                        viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n                        patternUnits: 'objectBoundingBox',\n                        path: this.fillSketch(drawing, o)\n                    };\n                    path = {\n                        d: drawing.path,\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        pattern: pattern\n                    };\n                    break;\n                }\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}