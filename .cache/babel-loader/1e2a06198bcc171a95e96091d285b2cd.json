{"ast":null,"code":"import { mutateElement } from \"./mutateElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\nexport function isInvisiblySmallElement(element) {\n  if (isLinearElement(element)) {\n    return element.points.length < 2;\n  }\n\n  return element.width === 0 && element.height === 0;\n}\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\n\nexport function getPerfectElementSize(elementType, width, height) {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (elementType === \"line\" || elementType === \"arrow\") {\n    const lockedAngle = Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;\n\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height = Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) || height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n\n  return {\n    width,\n    height\n  };\n}\nexport function resizePerfectLineForNWHandler(element, x, y) {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0\n    });\n  } else {\n    const nextHeight = Math.sign(distanceToAnchorY) * Math.sign(distanceToAnchorX) * element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight\n    });\n  }\n}\n/**\n * @returns {boolean} whether element was normalized\n */\n\nexport function normalizeDimensions(element) {\n  if (!element || element.width >= 0 && element.height >= 0) {\n    return false;\n  }\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    mutateElement(element, {\n      width: nextWidth,\n      x: element.x - nextWidth\n    });\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    mutateElement(element, {\n      height: nextHeight,\n      y: element.y - nextHeight\n    });\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/pro/Solutions/drawboard-light/src/element/sizeHelpers.ts"],"names":["mutateElement","isLinearElement","SHIFT_LOCKING_ANGLE","isInvisiblySmallElement","element","points","length","width","height","getPerfectElementSize","elementType","absWidth","Math","abs","absHeight","lockedAngle","round","atan","PI","tan","sign","resizePerfectLineForNWHandler","x","y","anchorX","anchorY","distanceToAnchorX","distanceToAnchorY","nextHeight","normalizeDimensions","nextWidth"],"mappings":"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","sourcesContent":["import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport function isInvisiblySmallElement(element: ExcalidrawElement): boolean {\n  if (isLinearElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n}\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport function getPerfectElementSize(\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (elementType === \"line\" || elementType === \"arrow\") {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n}\n\nexport function resizePerfectLineForNWHandler(\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n}\n\n/**\n * @returns {boolean} whether element was normalized\n */\nexport function normalizeDimensions(\n  element: ExcalidrawElement | null,\n): element is ExcalidrawElement {\n  if (!element || (element.width >= 0 && element.height >= 0)) {\n    return false;\n  }\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    mutateElement(element, {\n      width: nextWidth,\n      x: element.x - nextWidth,\n    });\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    mutateElement(element, {\n      height: nextHeight,\n      y: element.y - nextHeight,\n    });\n  }\n\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}